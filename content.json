{"posts":[{"title":"Gradle插件开发秘籍之断点调试（基于Intellij）","text":"Gradle插件开发这件事说大不大说小不小，但是对于有一定体量规模的Java项目来讲，从插件开发入手来思考解决问题，有的时候能找到意想不到的法门。所以说这是一门锦上添花的手艺。 废话少说，相信对于很多Gradle插件开发朋友们，开发过程中很大的一个痛点就是，插件的调试很痛苦，下面我就分享一下在这方面的心得。 1. 增加运行参数好吧这个很菜鸟，比如很常用参数的是–stacktrace，报错后会打印出堆栈信息 2. Log输出控制这个不多说了，println就可以了，可以自己设置一些分级和flag。 3. Attach a debugger！先上最终效果图： 如上图，是可以正常地设置断点调试和step into和step out、resume等等。实现办法和原理：大家都知道Gradle基于Groovy，而Groovy其实就是Java，所以也同样遵循JDWP协议，只是这个技巧似乎在国内的文章中没有人出来分享，我就在此分享给大家。首先，在你要执行gradle命令的环境中加入如下环境变量（以Linux、MacOS为例）： export GRADLE_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot; 其中，address等号后面的参数就表示debugger要监听的端口，这里我们设置为5005。然后执行gradle或gradlew任务，会发现有如下提示： 这时任务就不会继续执行了，挂起等待Debugger的handshake！这时我们启动IDE，以Intellij为例，打开我们的gradle插件项目（包含正在运行的插件源码的项目），然后找到工具栏的执行区域，进入如下： 在界面里添加一个运行项，Remote： 需要配置的最核心参数就是如图所示的端口号，就是上文中的address: 注意到下面有一个Search sources using …意思是从什么范围查找源码，保持默认就好了，这个debugger收到JDWP消息后会从当前工程中搜索源码，基于当前的源码进行与gradle命令行中的JDWP agent进行交互。 OK，如果插件源码中打好断点，执行到代码时就会挂起在相应位置了，大部分调试功能都很好使，大家可以尝试一下！这个技巧还是比较简单的，大家只要了解一下JDWP的核心原理，就可以理解上述过程了！ 时间有限，如有不妥，欢迎指正！","link":"/2017/02/06/gradle-debug-tips/"},{"title":"Aspect-Oriented Programming in Android","text":"What is AOP?​In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut“ specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. The Microsoft Transaction Server is considered to be the first major application of AOP followed by Enterprise JavaBeans.​ Similar concepts: Proxy pattern Interceptors &amp; Filters Basic terminology: ConcernsAdvice, Pointcut and Join Point compose an Aspect:​ Primary concerns Secondary and Cross-cutting concerns Joint point Advice Pointcut Described by expressions: AspectJ Pointcut expressions Described by annotations Aspect Weaving AOP processor i.e. the Weaver Weaving timing: At run-time At load-time At compile-time Why do we need AOP?In a word, AOP is an evolution and supplement of OOP General Benefits: Increase modularity and logic clarity and concentration Less tangled code Shorter code Easier application maintenance and evolution Applications that are easier to debug, refactor and modify Code is more reusable in a shape of aspect An idea of resolving complicated process Application of the implementation: help to hook and inject third-party SDKs (So as to block malicious method calls or to monitor or study crucial process, like network communication) Mastering AspectJ: Aspect-Oriented Programming in Java, Joseph Gradecki, Nicholas. WILEY Practice Areas: Logging Permission check Performance Profiling Data check Thread status check How to adopt it? AOP Core Implementation Basic Techniques Weaving time Dynamic Proxy Pattern Java Proxy API Run-time DexMaker DexClassLoader API Load-time AspectJ Java Bytecode Manipulation Compile-time AspectJ: AOP standard extension, the open-source projects Maintained by Eclipse Foundation https://git.eclipse.org/c/aspectj/org.aspectj.git/ Dark side: True Magic or Fancy Stuff?“AOP considered harmful”: Makes control flow obscured: Implicit AOP to Explicit AOPAffect method stack trace: increase its depthRequire additional weaving time “AOP Considered Harmful”. uni-karlsruhe.de. 23 March 2016. Mitigation: prevent invisible code, better use Annotation and combine with DI technique Appropriate use: it’s only a supplement and a way to simplify complicated structure and reuse components, not a software design principle. More about AspectJPointcut expression: 1execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?) https://docs.spring.io/spring/docs/2.0.x/reference/aop.html https://howtodoinjava.com/spring-aop/aspectj-pointcut-expressions/ As the return value is ignored, the method must be declared as void return. Pointcut described by annotation: Annotated Joint Point: the primary concern. Check log outputs: Other Possible Scenarios: @ProfilerTracker(BuildConfig.DEBUG) @CallFrequencyLimit @CheckPermission(“”), @RequirePermission(“”) How does it work? Technique Anatomy:​​​​​​​​​​​​​​Weaving in Build-time: Next session: Java Bytecode manipulation. Other implementations: Based on the idea of AOP and DI (Dependency Injection), lots of Android opensource frameworks are created to help improve the code structure and modularity. AndroidAnnotations Hugo OTHER REFERENCEShttps://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/","link":"/2018/12/27/aop-in-android/"},{"title":"Java字节码修改神器HiBeaver：黑掉你的SDK","text":"前言有时候我们在Java开发过程中可能有这样的需求：需要研究或者修改工程依赖的Jar包中的一些逻辑，查看代码运行中Jar包代码内部的取值情况（比如了解SDK与其服务器通信的请求报文加密前的情况）。 这个需求类似于Hook。 但是往往这些依赖的Jar包中的代码已经被混淆过，删去了本地变量表和代码行号等debug信息，所以无法直接断点调试，其内部逻辑和运行情况也几乎无法触及，研究更难以下手。这时候，一般的办法有二： 将Jar反解为Java源码，以module方式引入，便可自由修改调试； 修改字节码或者打包后的smali代码，实现想要的逻辑后再重新打包。 这两种方法中，前者往往十分繁杂，尤其在混淆后逻辑变得极其复杂，几乎不可能完成；后者也很麻烦，工序较多，修改成本也比较高。 插件：HiBeaverGradle编译插件hibeaver结合Java AOP编程中对于大名鼎鼎的ASM.jar的应用，和Android gradle 插件提供的最新的Transform API，在Apk编译环节中、class打包成dex之前，插入了中间环节，依据开发者的配置调用ASM API对项目所依赖的jar进行相应的修改，从而可以比较高效地实现上面的Hook需求。源码地址：https://github.com/hydraxman/hibeaver （现在hiBeaver已经发布了1.2.7版本，支持轻量级AOP框架设计。） 唯一需要注意的是，运用好这个插件需要有一定的Java汇编指令基础，并了解基本的ASM3的使用方法：后者还是很简单的，而前者，关于Java汇编指令基础这块，对于事先不了解的同学，接触起来有一定难度，但是学一学这个其实非常有益处，对于理解Java的运行有很大的帮助。闲话少说，先看看如何快速实践一把！关键看疗效！ 关于汇编指令的资料可以参阅本人的文章：大话+图说：Java汇编指令——只为让你懂 实战演练我们就先来尝试用这个Hook掉小米推送的SDK。 首先，在需要的工程的根项目gradle配置中加入以下内容： 如图所示，该插件上传到了jcenter中，只需引入classpath： classpath 'com.bryansharp:HiBeaver:1.2.7' 这里需要注意的是，目前该插件仅支持Android gradle编译插件2.0及以上的版本。然后，在你的App项目gradle配置底部或任意位置加入如下代码： apply plugin: 'hiBeaver' hiBeaver { //turn this on to make it print help content, default value is true showHelp = true //this flag will decide whether the log of the modifying process be printed or not, default value is false keepQuiet = false //this is a kit feature of the plugin, set it true to see the time consume of this build watchTimeConsume = false //this is the most important part modifyMatchMaps = [:] } 然后，重新编译一下项目，会先去jitpack下载这个插件，开始编译后可以看到Android Studio的右下角的Gradle Console中，多输出了以下内容： 如果你看到了和我一样的内容，那说明初步配置成功。可以看到，使用插件后会输出一段友好的帮助内容，还是中英文的，告诉我们可以直接拷贝作为初始配置，这个帮助输出也是可以关闭的。下面我们正式开始尝试Hook小米推送SDK，首先，找出其业务逻辑中的一个节点。首先，引入小米推送，这个过程不赘述了，blablabla，引入成功！众所周知，使用小米推送需要先在代码中调用如下： MiPushClient.registerPush(this, APP_ID, APP_KEY); 这个代码应该会调起本地长连接的建立、注册服务器等流程。假如我们出于学习的目的，想研究其中的流程，试举一例，先从查看其反编译的代码开始，找一个切入的节点，如下：首先进入查看MiPushClient.registerPush这个方法: 在initialize的方法中，找到一段逻辑如下： 进入a方法，来到了这个类：com.xiaomi.mipush.sdk.u中，发现： 下面如果我们想看看运行时前两个方法传入参数的值，就可以开始Hook了。该如何做呢？这个方法体内打Log输出所有的值吗？那样太麻烦了。我们可以这样做：首先在我们项目的源码里新建一个静态方法，包含两个参数，如下图： 其后，我们只要在a方法中加入一段代码，调用我们的静态方法，并传入我们想查看的两个参数即可。这就有赖于我们的hibeaver插件了，具体如何做呢？我们可以先看看之前的帮助内容： 里面有提到一个the most important par，最重要的部分。没错，这个插件的核心就在于配置这个类型为Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;的传入量。首先我们配置如下： 然后重新编译，发现输出log如下： 这样就输出这个u类的所有方法信息，用于后面进行配置。再来看看刚刚的方法a： 是一个泛型方法，众所周知泛型只存在于编码阶段，编译后是没有泛型的，其实传入的参数的实际类型为org.apache.thrift.a，最终找到其方法描述应该为： (Lorg/apache/thrift/a;Lcom/xiaomi/xmpush/thrift/a;ZLcom/xiaomi/xmpush/thrift/r;)V 进一步配置： 然后重新编译，console输出新增revist部分，如下： 最后，我们增加如下代码，在其中植入我们的代码，调用刚刚的静态方法，并把对应值传递过来：终极配置： 以上代码就不做详细解释了，相信有基础的都能明白，然后编译查看输出: 下面我们debug一下，看看是否可以成功在registerPush的运行流程中调用到我们的方法： 上面可以看到，无论是debug还是log输出都可以抓到想要的参数了。因为小米推送是商业产品，这里不便于探索太多内容，但是通过hibeaver这个插件可以比较方便的进行类似的研究。 总结hibeaver所体现的技术，并没有特别大的价值，仅仅作为工具来讲比较方便易用，有助于学习研究Jar中的逻辑，和学习应用Java汇编码。除此之外，还有几个应用场景：1.修改引用SDK中的一些bug或者提高其效率；2.获得必要的SDK的一些关键调用时机，通过hook建立回调；3.欺骗SDK、关闭或减少SDK中不受控制的网络传输。不一而足，还是很有趣、很有想象空间的。目前存在的问题，如下，这个除了偶尔同步报错之外没有影响，编译正常： 还有，如果仅仅修改了gradle文件，不会触发更新，需要在代码上也进行任意修改方生效。 关于项目hibeaver完全开源，大家可以自行查看其中代码，有大量的中文注释，对于学习gradle插件开发大有裨益。github开源项目地址：https://github.com/BryanSharp/hibeaver","link":"/2017/02/26/java-classcode-edit-toolkit/"},{"title":"代码中的人文故事：从一个Java的“Bug”说起","text":"缘起这几日闲来无事撸代码，无意中发现一桩趣事。原以为是一个Java的bug，没想到经过一系列死磕，挖掘出了一段和中国历史乃至人类文明相关联的人文故事，不禁唏嘘感叹一番。 这件事的缘起很简单，我在实现计算两个日期天数距离逻辑的过程中，发现了一个很诡异的事情，同样的起始日期，用python和Java计算出的结果居然不一样！ 例如，计算一个1990年1月1日到1990年9月4日之间的天数，用python计算如图： 得出天数为246。可以看到，python的API设计简单。 用Java计算则不同了，众所周知Java推荐的Calendar API不是一般的麻烦，实现函数如下： 按照这个逻辑测试如下： WTF!?得出的天数居然是245天？为什么和Python算出来的不一样？我马上实际数了一下，应该是246天，Python算的结果是对的！ 仔细核对了程序实现，没毛病啊？难道有精读损失？ 狐疑（懵逼）进而加入如下输出： 什么鬼？这0.0416666667天跑哪里去了？需知： 也就是说，Java计算的时间和实际正好差了一个小时！ 无独有偶，各种百度后，居然发现了和我有类似疑问的兄弟：https://ask.csdn.net/questions/241889然而这个提问下并没有靠谱的答案！ 这样看，似乎很像时区上出了问题，然而并不是，前后Calendar对象的时区完全一致！都是Asia/Shanghai！ 由此难免要想，难道Java代码有Bug？把这一个小时给吃了？好吃吗？啥味道？ 然而，用同样的函数，计算990年1月1日到1990年12月4日之间的天数，有一切正常了！ 心中万马奔腾啊！ 经过一番探索，我又写了如下代码： 惊奇地发现： 进而又发现： 由此我灵机一动，又写了一段代码，找到从1900年至今所有当天长度非24小时的日期！ 此中必有蹊跷！ 豁然然而这对于没文化的我来说，实在是一件不可理喻的事情。只能从源码入手了！ 找源码的过程就不再赘述了，总之，时间的偏移来自于一个zoneOffsets的数组，而这个数组中除了因为时区而产生的偏移外，还有一个神秘的DST_OFFSET！ 找到这里，这个谜团即将揭晓了！ 啥是DST_OFFSET呢？ 没错，daylight saving offset，也就是夏令时！ 也就是说，中国的1990年4月15日这天里，人为地将时间拨快了一个小时，1990年9月16日这天再拨慢回来。进一步说，中国的1990年4月15日这天确实是23个小时，1990年9月16日这天也确实是25小时，Java没搞错！ 也就是说之前找到的所有非24小时的日期，都是中国政府（或国民政府）施行夏令时调整的日期，这段历史断断续续地持续了半个多世纪！而Java的Calendar API将其忠实地记录了下来。 关于夏令时详情见百度百科。哈哈哈，真相揭晓，好感慨好激动。所以说，这并不是Java的bug，而正是Java严谨的体现！Calendar API确实设计的很烂很不友好，但并不代表其中有bug，相反地，这也正体现了其中的工程师精神。 这就引出了一段已经被淡忘的历史，很多90年出生的朋友可以问问父母，90年和91年是我国至今为止实行夏令时的最后两年，我国曾经也想向美国等西欧国家学习，充分利用太阳下的时光！年轻的小朋友问问你们的父母，一定能勾起他们的一段回忆！ 这就是隐藏在Java代码中的一段历史，一段已经被遗忘的人文故事！ 想了解这段历史的同学可戳： 还记得大明湖畔的夏令时吗？ 只要刨根问底，一定有意想不到的收获！感觉解决了个大谜团！","link":"/2018/07/13/java-calendar-story/"},{"title":"白话Java字节码指令","text":"前言随着Java开发技术不断被推到新的高度，对于Java程序员来讲越来越需要具备对更深入的基础性技术的理解，比如Java字节码指令。不然，可能很难深入理解一些时下的新框架、新技术，盲目一味追新也会越来越感乏力。 本文既不求照本宣科，亦不求炫技或著文立说，仅力图以最简明、最形象生动的方式，结合例子与实战，让小白也能搞懂这门看似复杂的技术概念。 单刀直入闲言碎语不要讲，先表一表，什么是Java字节码指令？简而言之，Java字节码指令就是Java虚拟机能够听得懂、可执行的指令，可以说是Jvm层面的汇编语言，或者说是Java代码的最小执行单元。有点Java基础的人一定都知道，javac命令会将Java源文件编译成字节码文件，即.class文件，其中就包含了大量的字节码指令。因此可以将javac命令理解为一个翻译命令，将源文件翻译成Jvm可以执行的指令。那么最直观的探究方法莫过于直接对比翻译前后的内容。具体如何对比呢？就不得不用到Java为我们一直默默提供的一项利器，javap命令，它可以解析字节码，将字节码内部逻辑以可读的方式呈现出来。为了紧贴实战，我们直接在新建的Java工程里，写这样一个UserServiceImpl类，里面包含几个由简单到复杂的方法，以及一个名为serviceType的属性： 如图，以上方法，复杂度由低到高依次为：getServiceType&lt;setServiceType&lt;genToken&lt;login（以及一个实例代码块），后面我也会按照这个顺序解读其字节码指令的执行逻辑。下面我们编译工程，然后在下图所示的目录(gradle编译工程)找到该类的字节码文件： cd到这个路径下，运行javap命令： 1javap -v -p UserServiceImpl 就可以观看到翻译版的Java字节码的胴体了！这里的-v意思是啰嗦模式，会输出全面的字节码信息，而-p是指涵盖所有成员。原字节码信息输出内容较多，基于本文的目标，取其一方法的内容，整理如下图：方法1，getServiceType()： 这个getServiceType的方法应该是再简单不过的Java代码，翻译成字节码后也变成了三行，我们先来简单推理一下：第一句，aload_0不知所云，索性略过；第二行，getfield应该可以读懂，后面这个#8似乎是他的参数（实际上是对常量池的引用），//后面注释的内容是javap给我们加上的，意思应该是#2的指向是”Field serviceType:Ljava/lang/String;”这个内容。所以getfield这一行就是取出serviceType这个字段喽，so easy。areturn肯定就是return的意思，a的含义也先略过不表。总之就是取出serviceType字段然后return喽。 那么现在的问题就是aload_0是什么意思了，看似多余，但仔细思考一下，似乎之前给getfield指令传入了“Field serviceType:Ljava/lang/String;”这样一个并不完整的参数，其后半部分的“Ljava/lang/String;”仅仅表示这个serviceType字段的类型是String，也就是说，整个参数里没有说是取的谁的serviceType字段啊！究竟是get谁的feild呢？ 由此可以想到：aload操作一定是在为getfield指令准备了一个主体。 实际上，再结合下面的局部变量表，aload_0中的0正是局部变量表里的Slot 0的含义。意思是将局部变量表里的Slot 0的东西压入操作数栈，这个Slot 0里的东西name正是this，也就是UserServiceImpl的实例，即getfield的主体。 大戏上演好了，对于小白同学有些陌生的概念来了，啥是操作数栈？啥是局部变量表？其实这两个东西理解好了，关于虚拟机指令就懂了一大半了。那么，不妨删繁就简，由易入难，先讲一个这样的故事，故事起名叫： Java方法之创世纪话说Jvm大帝是神之旨意的履行者（Jvm大帝就是虚拟机，神就是开发者，神之旨意是开发者写好并编译后的字节码…），当Jvm大帝带领Java世界运行进入了一个新的方法后，会为这个方法在栈内存大陆上创造两个重要的领域：局部变量表和操作数栈。 要有栈。要有表。神说。 依照神之旨意，jvm大帝创造的局部变量表里一般会包含this指针（针对实例方法，静态方法当然无此）、方法的所有传入参数和方法中所开辟的本地变量。 那么操作数栈是干嘛用的呢？ 我们再引入另外一个比喻，如果把运行Java方法理解为拍戏，那么局部变量表里的各个局部变量就是这部戏的核心主角，或者说领衔主演，而操作数栈正是这部戏的舞台。所谓操作数栈搭台，局部变量唱戏，是也。那么aload_0就是告诉Jvm导演（大帝已沦落为导演），请0号演员this同志登台（压栈），演后边的本子。当然了，这个比喻并不完全恰当，因为操作数栈并不是“舞台”的结构，而是栈的结构。但是这个比喻可以很好地说明局部变量表和操作数栈之间的关系，以及aload_0的作用。 下面我们用一张图来演示一下getServiceType这个小剧本桥段所导演的故事： 好吧这部剧虽然短的可怜，但已经基本把指令、操作数栈和局部变量表三者的关系演绎了出来。值得注意的是，getfield这条指令对操作数栈进行了复合操作，其流程可以示意如下图： 后面我们将要接触到的许多指令都如此，指令内部执行了弹出—&gt;处理—&gt;压回的流程。下面我们就来分析一个相对复杂一点的方法，setServiceType(String)，如下图： 这里我们看到，变化主要有，指令多了一行，多进行了一次aload，getfield变成了putfield，areturn变成了return，仅此而已。另外领衔主演也就是局部变量表里多了一位，也就是方法的传入参数serviceType字符串对象了。其情节如下： 这里，putfield只弹出栈内的操作数，而没有向操作数栈压回任何数据，而且执行putfield之前，栈内元素的位置也必须符合“值在上，主体在下”要求。而最后的return仅表示方法结束，而不会像areturn一样返回栈顶元素。这也印证了setServiceType(String)方法没有返回参数。 融会贯通相信有了以上的讲解，大家对指令、操作数栈、局部变量表三者的运作关系有了一定认识，为了后边能够分析更复杂的方法，这里必须概括性地讲解一下更多的Java字节码指令。虽然Java字节码指令非常多，但其实常用的不外乎几个类别，先从这几个常用类别入手理解，便可渐入佳境。关于字节码指令的分类，可以从两个维度进行：一是指令的功能，二是指令操作的数据类型。我们先从功能说起，指令主要可以分为如下几类： 存储和加载类指令：主要包括load系列指令、store系列指令和ldc、push系列指令，主要用于在局部变量表、操作数栈和常量池三者之间进行数据调度；（关于常量池前面没有特别讲解，这个也很简单，顾名思义，就是这个池子里放着各种常量，好比片场的道具库） 对象操作指令（创建与读写访问）：比如我们刚刚的putfield和getfield就属于读写访问的指令，此外还有putstatic/getstatic，还有new系列指令，以及instanceof等指令。 操作数栈管理指令：如pop和dup，他们只对操作数栈进行操作。 类型转换指令和运算指令：如add/div/l2i等系列指令，实际上这类指令一般也只对操作数栈进行操作。 控制跳转指令：这类里包含常用的if系列指令以及goto类指令。 方法调用和返回指令：主要包括invoke系列指令和return系列指令。这类指令也意味这一个方法空间的开辟和结束，即invoke会唤醒一个新的java方法小宇宙（新的栈和局部变量表），而return则意味着这个宇宙的结束回收。 如下图，展示了各类指令的作用： 再从另外一个维度，即指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型： a对应对象，表示指令操作对象性数据，比如aload和astore、areturn等等。 i对应整形。也就有iload，istore等i系列指令。 f对应浮点型。 l对应long，b对应byte，d对应double，c对应char。 另外，ia对应int array，aa对应object array，da对应double array。不在一一赘述。 了解了以上内容，我们再去看最后几个方法，应该就会容易理解很多了。下面我们就直捣黄龙genToken这个方法(图中的颜色暗示了指令和方法调用之间的关系)： 这个过程简单解读如下： new一个StringBuilder对象（在堆内存中开辟空间），并将其引用入栈，用于实现加号连接字符串功能（相当于C++中的运算符重载）； dup复制栈顶的刚刚放入的引用，再次压栈，这时栈里有两个重复的内容，深度为2； 调用并弹出栈顶StringBuilder引用对象的方法，栈深度为1； （绿色部分）调用UUID.randomUUID()静态方法，结果压栈后弹出调用String的toString方法，再压栈，栈深度为2； （黄色部分）将”-“和””字符压栈，此时栈深度为4，弹出（栈顶3个元素）调用replace方法，结果压栈，深度为2；6.调用StringBuilder对象的append方法，结果压栈，深度为1； （蓝色部分）将参数user压栈并调用hashCode方法，结果压栈，深度为2； 调用StringBuilder对象的append方法（此处和上面的append调用共同完成了加号功能，在图中为红色部分），结果压栈，深度为1，再调用toString方法后结果压栈，深度为1； areturn返回栈顶对象。 再看这个包含if跳转的方法login： 如上图，图中已经说明的比较全面了，不再赘述。值得一提的是，Java的这种基于栈结构的指令，在设计上有一种非常简洁的美感，指令与指令之间并没有较重的依赖，每条指令仅仅与操作数栈等领域内的数据发生关系，充满着某种平衡与秩序感。因此也必须注意，几乎每条指令的运行都有其前提，比如在invokevirtual或invokespecial指令执行前，必须保证操作数栈内提前按顺序压入好所需的操作数，否则就会发生问题。关于最复杂的onCreate方法，就不再啰嗦解读了，读者可以前往我的github上的对应demo repo，进入tutorial分支，拉取源码和教程资源，或者自己写demo体验这一完整过程。 后话关于实战，一是可以学习使用强大开源工具ASM.jar；二是，可以参考本人的另一篇文章：Java字节码修改神器HiBeaver：黑掉你的SDK以及一次Android字节码插桩实战，利用hibeaver这个助手，开发者可以非常灵活地对字节码进行修改，插入指令，hook代码，甚至建立一些简单的AOP框架，对于Java字节码学习大有裨益。hibeaver完全开源，github项目地址：https://github.com/hydraxman/hibeaver 祝玩的愉快！本文如有不妥之处，欢迎交流指正。 另外，本文为了尽可能地简明生动、直入核心，简化了很多概念和细节，读者须知实际情况的更为复杂。但相信在理解了本文以后，就可以抓住Java字节码指令的核心理念，也就算扣开虚拟机学习的大门并可以开始读书精进了。下面盗图一张（后有出处），可作拓展： 关注最新技术分享和资讯：TechHome，技术人之家！","link":"/2017/03/07/jvm-classcode-tutorial/"},{"title":"一次Java字节码插桩实战","text":"理解本文需要一定的Java字节码指令基础，可以阅读笔者的另一篇文章：大话+图说：Java字节码指令——只为让你懂 利用Android字节码插桩技术可以很方便地帮助我们实现很多手术刀式的代码设计，如无埋点统计上报、轻量级AOP等。下面我们就通过一次实战，把这门技术真正用起来。 奇葩需求假设有这样一个需求，我们需要在本项目工程的所有组件（Activity/Receiver/Service/Provider）的on系列生命周期类方法执行时，调用一个我们写好的方法，传入组件的实例对象，来对组件的相关状态进行监测，如何实现？ 一般的思路有两种： 通过Java继承体系，为我们实现的四大组件分别建立基类，在基类父方法里对监测方法进行调用。 通过Android API Hook技术，即通过动态代理等方法替换关键节点，抓住组件的节点方法并调用我们的监测方法。 上面的第一种方法比较麻烦，而且控制力较弱，也无法顾及我们所依赖的Jar或者aar中的组件，比如小米推送中自带的Service和Receiver，是完全无法触及的。第二种方法则比较强大，但是需要考虑兼容性问题，技术实现上的成本也比较高，毕竟有一些生命周期的节点不好找，难免焦头烂额。 本文对此的实战即通过字节码插桩，在class文件编译成dex之前（同时也是proguard操作之前），遍历所有要编译的class文件并对其中符合条件的方法进行修改，注入我们要调用的监测方法的代码，从而实现这个需求。 HiBeaver 是目前这方面比较完善的字节码插桩Gradle插件，目前最新的1.2.4版本支持通过通配符或正则表达式的方法来匹配目标类和目标方法，进行方法的批量插桩注入和修改，非常灵活易用。对于类似上文提出的需求，实现起来非常方便，唯一前提的仅仅是：知道所有组件的类的全名就可以了。 准备工作好，基于这些，正式开始实战，牛刀小试一下：首先建立一个工程，为便于演示，我们引入小米推送（接入方式不再赘述，详见小米推送文档），然后完善代码到如下状态： MainActivity内容很简单，注册了小米推送，有一个TextView点击后可以跳转到SecondActivity，仅此而已。具体如下： SecondActivity中一切从简： 至于DemoMessageReceiver这个类里完全依照小米推送接入文档中的配置，没有实质改动，不再贴出。注意到还有一个MonitorUtil的类，内容如下： 其中的monitorThis的方法就是我们打算在各个生命周期方法里插入的调用方法。 开始实战下面我们就开始实现开头处提到的需求：通过字节码插桩的方法，本工程里的所有组件的生命周期方法return之前调用我们的monitorThis方法，传入组件实例等信息作为参数。 首先，要引入HiBeaver插件：然后在项目的根build.gradle下面增加classpath如下： classpath 'com.bryansharp:hibeaver:1.2.4' 随后为我们工程的app/build.gradle增加如下配置： apply plugin: 'hiBeaver' import com.bryansharp.gradle.hibeaver.utils.MethodLogAdapter import org.objectweb.asm.ClassVisitor import org.objectweb.asm.MethodVisitor import org.objectweb.asm.Opcodes hiBeaver { modifyMatchMaps = [ //类名称匹配规则，*表示任意长度任意字符，|为分隔符，可以理解为或 '*Activity|*Receiver|*Service|!android*': [ //方法名匹配规则与类名类似，同时也支持正则表达式匹配（需要加r:）；adapter后为一个闭包，进行具体的修改 ['methodName': 'on**', 'methodDesc': null, 'adapter': { //下面这些为闭包传入的参数，可以帮助我们进行方法过滤，以及根据方法参数来调整字节码修改方式 ClassVisitor cv, int access, String name, String desc, String signature, String[] exceptions -&gt; //这里我们有了ClassVisitor实例，其实可以为类添加新的方法。 MethodVisitor methodVisitor = cv.visitMethod(access, name, desc, signature, exceptions); MethodVisitor adapter = new MethodLogAdapter(methodVisitor) { @Override void visitCode() { super.visitCode(); //实例对象入栈 methodVisitor.visitVarInsn(Opcodes.ALOAD, 0); //下面两句我们将方法的名称和描述作为常量入栈 methodVisitor.visitLdcInsn(name); methodVisitor.visitLdcInsn(desc); //调用我们的静态方法 methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, //下面这个MethodLogAdapter.className2Path(String)为 // hibeaver插件提供的方法，可以将类名转为路径名 MethodLogAdapter.className2Path(&quot;bruce.com.testhibeaver.MonitorUtil&quot;), &quot;monitorThis&quot;, &quot;(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V&quot;); } } return adapter; }] ] ] } HiBeaver在类名和方法名的匹配上非常灵活，可以非常方便地实现批量匹配，除了完整匹配外，还支持通配符匹配和正则表达式匹配两种模式。通配符匹配模式中主要可以使用两种符号，即 | 和，表示任意长度（&gt;0）的任意字符，而|表示分隔符，这里可以理解为或。因此，上面的： *Activity|*Receiver|*Service 可以理解为，匹配任意全类名以Activity、Receiver或Service结尾的类。 一般来讲，我们的Android组件在命名上都会遵从这个规范，即组件类名以相应的组件名结尾，对于个别不遵从这个原则的，也可以通过|分隔符来把特殊情况纳入进去。 除此之外，如果存在更复杂的匹配规则，上述通配符已经无法满足，hiBeaver也支持正则表达式进行全类名匹配，只需要在表达式前加上“r:”就可以。比如： r:.*D[a-zA-Z]*Client 表示匹配符合“.*D[a-zA-Z]*Client”这个正则表达式的类名。 更进一步地，HiBeaver 未来 还将支持根据类的继承关系进行匹配，比如： &gt;ext&gt;android.support.v4.app.FragmentActivity 表示匹配所有继承android.support.v4.app.FragmentActivity的类，而： &gt;imp&gt;android.os.Handler.Callback 表示匹配所有实现android.os.Handler.Callback接口的类。不过，目前这两个特性还没有支持，仅提上了其项目的issue中。回到刚刚的配置中，下面的methodName方法的匹配规则与类名匹配用法一样，**和*是一样的效果，on**即表示名字以on开头的方法。好了，编译运行工程，过程中在Gradle Console中可以看到hibeaver进行字节码插桩输出如下（局部）： 程序运行起来，插桩成功，成功调用了monitorThis方法，但赫然发现输出如下： 调用了三个onCreate和若干的onCreateView！这是为什么？我们的MainActivity也没有这个onCreateView的方法啊！ 结合之前Gradle编译日志，在仔细一琢磨，突然明白了： 原来，我们的*Activity规则会匹配所有的Activity结尾的类，包括一些android v4支持包中的类，什么AppCompatActivity、FragmentActivity等继承链上的Activity通通被hook了一遍，难怪会有那么多输出了，可辛苦了我们的monitorThis方法。 既然如此，如何是好？针对于当前的需求，我们当然不想匹配v4包里的组件类。 所幸的是，HiBeaver中还有另一种排除匹配，运用!符号改造如下即可： *Activity|*Receiver|*Service|!android* 这样就表示，匹配前三种之一（或的关系）且不匹配第四个android*的全类名。改好后，再次运行，并点击跳转到SecondActivity： 可以看到log输出一下子少多了，证明没有再注入v4包里的类，同时，小米的组件也被正常注入了，我把网断掉，可以看到小米的Receiver被唤起： 再开启调试，打开网，断点也可以正常进入： 同时，每次HiBeaver进行字节码插桩后还会把修改过、实际使用的字节码保存到build/HiBeaver目录下，以便于查看： 如下图为修改后的MainActivity类： 修改后的小米推送里的某Receiver: 这样，无论是进行节点控制还是研究其运行机制都大大地方便了。 HiBeaver","link":"/2017/03/11/jvm-classcode-practice/"},{"title":"Java bytecode and AOP","text":"What is Java bytecode?Java bytecode is the instruction set of the Java virtual machine (JVM). From Wikipedia: In a word, just like X86 and ARM or MIPS running on each ABI platform, Java bytecode is executed by JVM engine. And as a machine language defined by JVM specification, Java bytecode plays a much more fundamental part in Java ecosystem than Java language itself. The following picture can be the best case to cast light upon it. https://docs.oracle.com/javase/specs/index.html JVM handles the platform independency. A Java programmer does not need to be aware of or understand Java bytecode at all. However, as suggested in the IBM developerWorks journal, “Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer.” An anatomy of the .class fileClass file dissemble Use this java source code as an example: Java method data structure: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html Stack-Based Architecture?All the instructions is centered by the Stack-Based Architecture and methodology of JVM. This largely simplifies the instruction set of JVM and therefore make it possible that the opcode size could be limited to 8 bit. In JVM for each thread, a last-in-first-out (LIFO) stack, also known as its JVM stack, is allocated where Java frames are stored. Here is an illustration showing stacks for 3 threads. A new Java frame is created each time a method is invoked and is destroyed when its method invocation completes. It is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions. Operand StacksAs opposed to a register-based architecture, stack based one will use stack data structure as its instruction executing and computing playground and notepad, which means each instruction execution will be companied with stack operations like pop and push. The operand stack is empty when the frame that contains it is created, and will normally be empty when the invokation of the corresponding method is completed. Local Variables tableIt is a bit reckless to jump to conclusion that JVM is stack-based as JVM also use local variable table during it bytecode execution, which make JVM a bit more register-based. Each frame contains an table of variables known as its local variables table. The length of the local variable array of a frame is determined at compile-time. So based on this understanding, let’s take a look at a more complicated method, setServiceType(String): Each frame for a method call has an “operand stack” and an array of “local variables”. Instruction typesThe byte-long and 256 possible opcode instructions fall into a number of broad groups: Load and store (e.g. aload_0, istore) Arithmetic andc (e.g logi. ladd, fcmpl) Type conversion (e.g. i2b, d2i) Object creation and manipulation (new, putfield) Operand stack management (e.g. swap, dup2) Control transfer (e.g. ifeq, goto) Method invocation and return (e.g. invokespecial, areturn) Prefix/suffix Operand type i integer l long s short b byte c character f float d double a reference https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html Bytecode manipulationThe most powerful and widely used manipulation tool: ASM Site: https://asm.ow2.io/ Used in: OpenJDK Groovy and Kotlin compiler CGLIB AspectJ Gradle …… It is the fundament of compile-time AOP, basically by applying ASM API we can analyze and modify class file method call after source code compile.","link":"/2018/12/31/more-about-java-bytecode-and-aop/"},{"title":"编程的本质","text":"编程的本质是什么，或者说代码的本质是什么？ 编程可以指挥机器帮助人做事，程序把人类的思想和逻辑固化下来，把流程和规则。通过代码体现出来。","link":"/2022/11/01/the-nature-of-code/"},{"title":"15分钟入门23种设计模式：图解，范例和对比","text":"本文力图在15分钟内，通过UML图解、范例和类比，让你对面向对象的23种设计模式形成提纲挈领的认识，从而让我们在面临代码设计问题时更加成竹在胸。本文源代码： UML, Sample Code。 开门见山我们直奔主题，分类呈现23种设计模式的庐山真面目： 创建型 (5)Creational 结构型 (7)Structural 行为型 (11)Behavioral 工厂方法 Factory method抽象工厂 Abstract factory建造者 Builder原型 Prototype单例 SingleTon 适配器 Adapter桥接 Bridge组合 Composite装饰 Decorator外观 Facade享元 Flyweight代理 Proxy 责任链 Chain of responsibility命令 Command解释器 Interpreter迭代器 Iterator中介 Mediator备忘录 Memento观察者 Observer状态 State策略 Strategy模板方法 Template method访问者 Visitor 这23种设计模式源于GoF所著的”Design Patterns - Elements of Reusable Object-Oriented Software” 一书（也有将该书直接简称为GoF），译著为 “设计模式：可复用面向对象软件的基础”。原书将这23种设计模式分为三类： 创建型包含5种模式，涉及对象/对象组合的创建构建。 结构性包含7种模式，涉及对象/类之间的关系。 行为型包含11种模式，涉及对象/类的行为、状态、流程。 从该书的标题我们可以了解到，设计模式是一个面向对象开发方法下的概念，是解决代码设计/软件架构问题的可复用的元素，同时是基本元素（elements）。引用原书的例子，我们大家所熟识的MVC模式，Model-View-Controller，就可以解构为几种设计模式的组合演变，比如可以在View和Model的关系中看到观察者模式 Observer、组合模式 Composite、装饰模式 Decorator，在Controller中发现策略模式的影子。通过对23种基础模式的有机利用和结合，可以进一步演化出更复杂的软件架构。限于篇幅，本文不会讲解每种设计模式的定义和背景，读者可以参考设计模式简介来学习定义。 设计模式的UML、类比和范例这个部分，我们逐步从尝鲜到类比，深入理解一些比较常见有趣的设计模式的UML及其经典实例。GoF原书中也推荐学习者从“模式怎样相互关联”以及“研究目的相似的模式“出发来学习和选择设计模式。首先看看最简单常见的策略模式和另一个同属行为型模式的状态模式： 策略模式 Strategy 状态模式 State UML 范例 - Comparator#compare() 和 Collections#sort()- Spring Security: PasswordEncoder - 标准范例: javax.faces.lifecycle.LifeCycle#execute()- 形似样例：Java Thread State, ExoPlayer 概述 让外部对算法的相互替换无感 允许一个对象根据内部状态改变行为 关键字 Strategy, rule State, switch, phase, lifecycle 核心角色 Strategy State 策略模式和状态模式在UML图形上非常相像，他们之间的主要区别如下： 状态对象可以持有上下文对象（调用方），但策略模式一般存在这种依赖。 状态模式可以在彼此之间进行跳转替换，比如调用了播放器的play方法，那么状态可能从stop-&gt;playing，这个操作可以用状态对象完成。 一个策略和调用方的关系（依赖）可能弱于状态和上下文对象的关系（持有、属性）。 策略的不同可能只影响一个行为，但是状态的不同影响状态持有对象行为的方方面面。 整体上策略模式要比状态模式更加简明易懂，应用场景更广，在大型项目中的应用也随处可见。而状态模式虽然也是对常见概念的抽象，其应用却相对有限，其原因可能是，在更多的情况下，把行为的差异定义在不同的状态中，可能并非符合直觉的操作：与其把状态也定义为对象承载行为，不如把状态定义为一个标记，直接用if或switch判断来的直接。或者换言之，大多数情况下，问题还没有复杂到要用状态模式的程度。 借助这种对比的视角，我们来学习更多模式。先看看以下三种结构型设计模式： 适配器 桥接模式 外观 UML 范例 RecyclerView.Adapter 范例比较少：- Collections#newSetFromMap()- (ADB?)，如Spring中Service和Repository的关系 常见，如：Facades, FacesContext, ExternalContext, DataSource#getConnection() 概述 将一个类的接口转换成满足另一个要求的接口 将抽象部分与它的实现部分分离 为子系统中的一组接口提供一个一致易用的界面 关键字 Adatper Wrapper Context 核心角色 Adpter, Adaptee Bridge Facade 适配器模式、桥接模式和外观模式同属结构型设计模式，他们三者概念上很相像，都是通过建立接口来为类的方法建立或重构关系，比如，似乎我们用外观的视角去解释适配器，也能解释的通，Adapter就是在帮助Adaptee建立统一界面，或者建立桥梁。 设计模式就是这样，非要较真，所有的设计模式都大同小异（至少在一个类型之内），这是学习设计模式的一个误区。回到上面的三个设计模式上，他们的核心区别更多体现在时机和出发点上：适配器Adapter强调兼容性，桥接Bridge强调抽象与实现的分离，而外观Facade强调简化复杂性。我们分辨这些模式也应该从意图出发来看。 Spring的三层结构也融合体现了Facade和Bridge的设计，Service和Repository之间偏重体现Bridge模式理念，而Controller和Service之间更像Facade模式：Controller整合Service，对外提供API: 下面我们再看几种常见的行为型模式的类比分析： 代理 装饰 中介 UML 范例 - Java Reflect API: Proxy - Java EJB: Enterprise JavaBean, JavaX Inject, JavaX PersistenceContext- ActivityManager 和 ActivityManagerService- PerformanceInspectionService 和 PerformanceTestManagementService - Java IO: GZIPOutputStream and OutputStream, Reader and BufferedReader- java.util.Collections, checkedXXX(), synchronizedXXX() 和 unmodifiableXXX() 系列方法，拓展集合 - HttpServletRequestWrapper and HttpServletResponseWrapper- JScrollPane - Java Message Service, JMS by Oracle - java.util.Timer (all scheduleXXX() methods), java.util.concurrent.ExecutorService (the invokeXXX() and submit() methods) 概述 通过代理来控制对一个对象的访问 动态地给一个对象添加功能 封装对象之间的交互（传话筒） 关键字 Delegate Wrapper MessageQueue, Dispatcher 核心角色 Proxy Decorator Mediator 这里，从类之间关系上看，代理和装饰更为相似，而中介则不同，它只是名字上和代理相近。关于代理(访问和控制)和装饰（增强和扩展）的区分，同样可以从目的和意图的角度区分。以代理来为例，它的首要作用是建立访问通道，比如安卓中，应用和系统之间用Binder来进行IPC，而在应用进程和系统进程间，为了这种IPC调用，大量应用了代理模式，名为Proxy的对象随处可见。而在设计Hydra Lab的过程中，为了让测试用户能方便的在测试实例中通过SDK访问一些Hydra Lab Test Agent的服务方法，我们也应用了一个简明的静态代理来实现这种不同环境下的访问。 在代理模式下，有了访问通道，自然就可以做到对通信的控制，比如基于权限的、或是基于格式验证的。而装饰模式着眼于增强、扩展，比如BufferedRead对于Reader的增强。从这个角度讲，一个类如果叫AuthWrapper就会比较奇怪，AuthProxy则更常见一些，因为授权这种操作明显更强调控制。当然这取决于具体情境。 中介其实是很宽泛的概念，解耦通信的双方或多方，比较火热的各类MQ框架其实是这个模式的一个衍生。 观察者 访问者 UML 范例 - java.util.Observer, Observable- java.util.EventListener- ReactiveX Interface Observer - AnnotationValueVisitor- ElementVisitor- TypeVisitor- SimpleFileVisitor- VisitCallback- ClassVisitor (ASM 9.4) 概述 对个观察者监听一个主题对象 表示一种对某对象中各元素的只读操作 关键字 Observable, Observer, Subject,Subscription Visitor 核心角色 Observer, Subject Visitor, Element 这两个模式之间在实现上其实并没有太多联系。但二者都是想去“读”，不会直接改变被读对象的状态。观察者通过订阅监听的方式被动地读，而访问者是主动视角，以一种独特的方式读。和观察者很相近的“Listener”，是更常见的概念，更轻量，因而也更广泛。 责任链 备忘录 UML 范例 - OkHttp Interceptors- java.util.logging.Logger- javax.servlet.Filter - Activity#onSaveInstanceState(…) - Java Serializable 概述 建立处理链条传递请求 捕获对象状态并保存，以备状态恢复 关键字 Chain, Interceptor, Filter, proceed, Response State, Lifecycle, Context 核心角色 Handler Memonto, Originator, Caretaker 责任链和备忘录模式虽然意图和设计上都不相同，但二者都有非常浓厚的IoC控制反转的味道，和生命周期的设计联系紧密。玩游戏的同学对备忘录模式最容易建立理解，一个存档就是一个持久化的State，游戏本身的存读档服务作为caretaker，帮你保证你肝的进度不会白费。所以备忘录模式其实非常的常见，软件世界里俯拾皆是。 命令 解释器 UML 范例 - IShellOutputReceiver- Java Runnable - java.util.Pattern- java.text.Normalizer- java.text.Format- javax.el.ELResolver 概述 将请求封装为对象，从而方便参数化和请求队列管理 定义文法和表示方式 关键字 Executor Expression 核心角色 Command, Receiver, Invoker(Executor) Interpretor, Expression 上面两者也无法直接类比，但是当二者合体，命令的解释和执行一气呵成，一个脚本语言的c执行器雏形就诞生了。这里的命令模式其实比“命令”本身在设计上有更周全的考虑，它还包括了对执行结果的接收接口的预留。 抽象工厂 工厂方法 UML 范例 - DocumentBuilderFactory(JavaX) - TransformerFactory(JavaX)- XPathFactory(JavaX)- BeanFactory#getBeanProvider(Spring) java.util.Calendar#getInstance() 概述 将一个类的接口转换成满足另一个要求的接口 由工厂的子类决定创建的实例对象 关键字 Factory, new…, create… Factory, newInstance, Creator 核心角色 AbstractFactory Creator 其他模式还包括：建筑者模式，原型模式，享元（类似多例），单例；组合；模板方法，迭代器。这些模式或是不常用，或是过于常用常见，且都比较简单，限于篇幅本文不再一一详述。 通过这个类比学习的过程，我们可能会逐步感受到，设计模式的重点并不在于类之间关系的严格定义、罗列和排布，无意义的争辩、论证会陷入“把设计模式当作一个严格的学术理论”的误区。更多的，我们应该从问题的意图出发，发散思考解决方案中可能包含的设计元素，然后根据实际情况精简到合理的规模。 所以我们不必纠结于相近的两种模式的严格界定和区分，比如，无需辩驳一种实现究竟是用的代理还是装饰，而是理解这两种模式的看问题的角度和意图，融会贯通，灵活组合运用：如果你强调的角度是功能拓展，那设计方案就是装饰；如果你强调的是访问控制，那就是代理。很多初学者觉得很多模式很相似，感到多余，这是很正常的感受和学习阶段；随着更多应用和实战，你会成长和洞察更多模式的意义；后来你已经成为设计大师，灵活运用设计模式、AOP、函数式、算法乃至ML解决各类问题，讲述和推动方案的实现，设计模式的探讨和辩论只不过是茶余饭后的谈资。这一点，在原书“怎样选择设计模式”章节中，也有提及。 总结来讲，初学设计模式，关注点可以放在： 这个设计模式解决什么类型的问题，意图是什么，以及它如何对概念进行抽象（关键角色）和解决（接口、关系）的。 用设计模式作为大家沟通软件设计的语言，掌握这些术语，减少沟通成本。 如何学习和使用设计模式本部分内容源自GoF原书中1.8章的内容“怎样使用设计模式”，精简了原书的7步为6步，并去除了翻译腔： 浏览一遍该模式，掌握关键要素这个模式的名字是什么，意图是什么，里面的关键角色是什么，常见的关键词？ 回头去研究结构部分、参与者部分和协作部分进一步了解角色的职责和关系，有哪些接口，以及模式的适用性：这个模式更适合解决什么类型的问题？ 看看示例代码例子能让我们了解模式解决的实际问题，成为我们实现的参考。 参考模式中的命名方法比如，在Strategy模式中，你可以直接给算法命名末尾加上Strategy来体现这个模式；再比如，可以用create作为方法的开头前缀来凸显工厂方法。 定义类和接口选定好模式、完成命名后，下一步可以建立好类与接口之间的继承/实现关系，定义代表数据和对象引用的实例变量。 实现模式开始依据模式实现解决方案。 设计模式的引入是带有一定成本的，学习成本和复杂性的增加就是其中之一，也可能会有性能上的损耗（虽然可以忽略），但它为架构带来了灵活性，使其更加清晰可维护。接下来，作为拓展阅读，我们可以探讨一下设计模式的意义，获得更深的理解。 设计模式的意义和批判谈及为什么需要设计模式时，首先要回答什么设计是好的设计。软件是对现实问题复杂性的抽象和管理，Uncle bob说：“软件应该是可变的”，正如现实世界“唯一不变的就是不断地变化”，软件应该能灵活地应对现实世界的需求。所以我们会讨论软件架构的可扩展性、可维护性、高可用、可重用、可移植性等。如果你只是在编写一个又一个的脚本、一次性工具或者编程练习题，当然不用把问题复杂化。但如果你希望你的软件有更强的生命力和更广阔的前景，那就要严肃对待软件设计，防止代码腐化。 此外，一个人的力量是有限的，如果希望借助协作来扩大软件的服务范围、影响力，那么可读性也就重要起来。“Good code is like well-written prose”，好代码应该像优美的散文；至少是自解释的。引述GoF的原文，“所有结构良好的面向对象软件体系结构中都包含了许多模式…内行的设计者知道：不是解决任何问题都要从头做起…这些模式解决特定的设计问题，使面向对象设计更灵活、优雅，最终复用性更好。”所以这里的两层意思就一方面强调了模式对软件设计本身的好处，一方面说明了这些模式建立了大家在面向对象设计上的共识和交流基础。此外，大师们还总结了一些设计原则来框定好的设计。 SOLID设计原则尽管很多教程将设计原则和设计模式放在一起讨论，暗示设计模式是遵从了设计原则，实际上他们并非同出一家。而且设计原则有很多种说法，这里我们分享Uncle Bob提出的最容易记忆的版本，SOLID 原则： Single responsibility, 单一职责原则 SRP：就一个类而言，应该仅有一个引起它变化的原因。 Open-close, 开闭原则 OCP：软件实体应该对于扩展是开放的，对于修改是封闭的。 Liskov substitution, 里氏代换原则 LSP。子类型必须能够替换掉它们的父类型。把父类实例替换成子类实例，程序行为不应该有变化。 Interface segregation, 接口隔离原则 ISP。 一个类对另外一个类的依赖性应当是建立在最小的接口上的。 客户端程序不应该依赖它不需要的接口方法（功能）。 Dependency inverse, 依赖倒转原则 DIP： 高层模块不应该依赖低层模块。两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 我们可以认为这些设计模式是解决设计问题思考的准绳，也可以认为他们只是一种理念。正如Uncle bob 所说：”The SOLID principles are not rules. They are not laws. They are not perfect truths… This is a good principle, it is good advice…”。总之，了解这些可以帮助我们把握思考方向，但不能帮我们解决问题。换言之，对于初学者而言，设计原则可能没有设计模式那样强的实战意义。 批判之声关于设计模式的批判，源自于对其创立所处时代的主流编程语言的局限性的挑战，以及对于面向对象本身的质疑。有人认为设计模式的提出反映了Java和C++自身语言特性的缺失；也有认为如果灵活运用aspect-oriented-programming，就用不着搞出来23种之多啰啰嗦嗦的设计模式了。对此，笔者觉得纯粹的理论上的对错没那么重要，软件开发是科学和艺术的结合地带，而设计模式是一个时代开发者思考的精华沉淀，能给我们带来的不仅是具体方案，更多的是解决问题的思维方式，它们本身就存在于大量的编程实践中，GoF对他们进行了提炼和综述，这本身就是意义巨大的成果了，更何况他们已经成为工程师文化的一部分，成为了术语。例如，我们从Spring中既能看到AOP的应用、函数式编程的应用，也能看到建造者、工厂模式、策略等等的应用。编程大师应该是博学和不拘一格的，代码的艺术正在于灵活和适时的运用，囿于固执信仰而拒绝经典或者新知断不可取。 其他常见疑问FAQQ: 设计模式和后续流行的的Reactive、函数式编程、AOP、IoC以及DI之间的关系是什么？ A: 总体上，这些是不同维度的概念，总结为下表： 概念 释义（译） 范畴 设计模式 Software design pattern 软件设计的解决方案 IoC 控制反转 Inversion of control 软件架构层面的一种设计模式 DI 依赖注入 Dependency injection 一种设计模式 AOP Aspect-oriented programming，面向切面的编程 编程范式（面向对象） 函数式编程 Functional programming 编程范式（声明式） Reactive Reactive programming, 响应式编程 编程范式（声明式） 微服务 Microservices 一种架构模式（面向服务的架构） Q: 是否还有其他设计模式？ A: 有的，随着软件开发实践的演化，有越来越多的设计模式被总结出来，只不过可能还没有一本经典将其整理入册。比如常见的锁的双重检查，也被认为是一种独立于语言的并发型设计模式。DI也是设计模式 Concurrency Patterns，其角色包括注入器Injector，服务Service，客户端Client和接口Interfaces。DI也是一种创建型Creational设计模式，其意图在于优化类之间依赖关系，因而和整个软件或模块的架构的相关性更密切。 References Design Patterns, Elements of Reusable Object-Oriented Software https://en.wikipedia.org/wiki/Software_design_pattern http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod https://en.wikipedia.org/wiki/SOLID https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start https://en.wikipedia.org/wiki/Law_of_Demeter https://www.jianshu.com/p/8cbc4bf897cb https://coderanch.com/t/99717/engineering/Bridge-Facade-Pattern https://stackoverflow.com/questions/3477962/when-do-we-need-decorator-pattern https://stackoverflow.com/questions/6366385/use-cases-and-examples-of-gof-decorator-pattern-for-io https://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries/ 关于我我是风云信步，目前在微软中国担任研发经理。希望在这个空间和大家分享交流技术心得，职业生涯，团队和项目管理，趋势动态。旨在畅谈、分享和记录，不拘小节；但也不排除刨根问底、钻牛角尖。 本人热爱技术和打码，尤其享受用技术解决实际问题的过程和结果；相信创造力是顶级能力，是人价值的放大器。此外，本人专注于软件和代码质量、工程效率和研发能效方面多年，目前在微软和团队一起推动2023年新开源的项目Hydra Lab的完善与发展；欢迎和我在开源世界组队打码，造轮子 or 添砖加瓦。","link":"/2022/10/15/design-patterns-all-in-one/"},{"title":"什么是好代码？","text":"","link":"/2022/09/01/what-is-good-code/"},{"title":"写在三十岁的年尾","text":"2020是对于世界是魔幻的一年，对于整个人类历史也是天翻地覆的一年。甚至有文称之为庚子凶年。 对于我个人来讲，2020也是永生难忘的一年。实话讲，其实这几年都挺永生难忘的。2016年后，我的人生就开始加速，浓缩酸甜苦辣释放出来，来不及回首就轻舟已过。我有点希望这节奏能慢下来。 此时的我在做什么呢？工作、生活（吃喝拉撒睡亲朋好友社交）和带娃，余下的时间，还要娱乐，还要锻炼，投资健康，此外还剩多少时间？ 所以，下面开始谈，现实点，没多少时间留给自我提升了，就这样吧，人到中年，随遇而安，皆是如此。要这样吗？这可不太像我。 自我提升是不变的人生主题，创造价值是始终的追求，这与当下的时间与精力没有太多关联。眼下忙，就忙过了再说。精力不足，就充分休息。一旦回过神，就重操旧业。 得益于微软的工作，业余时间还是比较可观的，只要work smart，就不至于让自己陷入工作量泥潭。生活按部就班，规律作息，合理安排，不会侵占大块时间。带娃上做足准备，资金到位，影响也没那么恐怖。娱乐点到即止。健康定期投入，养成好习惯，融入生活。 但是不管如何优化，中年之后最大的问题是，大块的专注时间变得弥足珍贵，这点无法改变。所以学习深度的东西变得很难。 大部分人在二三十岁上就死去了，因为过了这个年龄，他们只是自己的影子，此后的余生则是在模仿自己中度过，日复一日，更机械，更装腔作势地重复他们在有生之年的所作所为，所思所想，所爱所恨。—— 罗曼罗兰 《约翰·克里斯多夫》 概括的讲，这个问题需要两方面来解决：一是对于艰深的内容，要充分利用宝贵的大块时间来突破和学习；而是要学会化整为零和化零为整，设定目标来管理自己，不忘初心，牢记使命。 深度内容一旦突破，再进行博学，必定会有触类旁通之感。原理既通，无妨大显身手。","link":"/2020/12/31/30-year-old/"},{"title":"当爹记","text":"当爹第十天记我的宝宝降生已经十天。感受里杂糅着对他的无限的爱与对未来的憧憬、忧心，五味杂陈。 我和我的家人距离无欲则刚的状态，肯定是越来越远了。宝贵而幼小的生命的到来，给生活加了一剂甜辣。 昨晚八点多就睡了，一觉睡了很久，醒来觉得略微不可思议。宝妈却很辛苦，断断续续地起来喂奶，她已经很久没有尝过踏实安稳的长觉了。 成长的惊喜是对父母最大的慰藉，新生儿新生的第一个月里，快速成长，每天都能看见些许变化，小手一伸，小腿一蹬，眉目渐开，甚是喜人。老父亲露出了肉麻的笑容。 心中默念，我只能变得更加强大。 宝宝两月记宝宝很可爱，却也很磨人。吃奶拍嗝玩耍换尿布洗屁股，擦脸抚触哄睡练翻身排胀气。 每天都在成长，每天都在变化，乐趣无限又惊喜重重。 宝妈更辛苦，宝宝身体茁成长，体重追赶十三五，入手沉甸甸、肉乎乎，手舞足蹈，眉飞星目。夜半长歌唤奶喝，入梦金浆包屁股。","link":"/2021/02/01/baby-daddy-diary/"},{"title":"减肥：从心开始","text":"减肥难吗，很难。减肥简单吗？控制一个数字而已。 我近期减肥，初见成效，深刻地领悟到一点，减肥需要从心态开始。身体上的肥一定是从心理上的“肥”开始的。 减肥要科学节食，严格控制摄入。然而，包括我在内的很多人都认同：民以食为天，吃是人生一大乐趣。我特别爱吃肉酱豌杂面，每次路过川味小面的招牌的时候都忍不住慢下脚步。这就是心之肥。 总觉得控制饮食是委屈自己，减肥是很难进行的。 一次次半途而废后，我渐渐意识到，我错在把减肥变成了战斗，变成了苦刑。 也许减肥可以只不过是一种生活习惯，是一种暂时人生策略或者行为模式的调整。我的很多同事朋友吃的就是比较少，运动比较多，人也苗条，他们自己没有觉得自己在减肥，可是在我看来，他们就是在减肥了。所以减肥这个词，本身就有冠冕堂皇和商业化的味道。 与其说，减肥是在与饥饿、馋嘴和运动的惰性作斗争，不如轻描淡写一点：人生除了吃之外还有很多有趣的事。想办法降低自己的食欲，从其他方面提高自己的人生获得感。 可以去培养更多的健康的生活习惯，转移注意力；调整饮食结构，减少糖、碳水化合物和脂肪的摄入，增加膳食纤维、蛋白质和必要维生素的摄入；运动方面，可以选择轻松可持续的类型（走路）。 心之肥一旦去除，从心底认同了科学健康的生活习惯，那么身体的减肥也就是时间问题。 针对地讲，一日三餐要规律进行，调整饮食结构，只求营养全面，不饿就好。三餐之外不想食物的问题。要认同营养科学，奉行少糖少油脂少碳水。 对于食欲和馋，适当为自己洗脑：食欲的满足并不重要，和人生幸福无关；从运动中获取满足感和舒适感；让自己适当忙碌，健康作息。 运动可以逐步加量，注意培养对运动的喜爱，放大运动带来的快感。 身心减肥=科学健康生活+缩减食欲+快乐运动 为自己打造正反馈系统和良性循环，开头略有难度，但是一旦坚持一周，看到成果，后面也就水到渠成。三月之后，成效斐然，自然可以稍微关注美食；但彼时食欲已经减弱，胃口也没那么大了，对于美食的摄取由大快朵颐过渡为浅尝品鉴，控制体重和健康也就没有那么难如登天了。 以上理论，我的具体实践大致如此： 不再观看一切美食相关的媒体，眼不见为净； 三餐只有早餐摄入碳水化合物，午餐和晚餐不摄入任何米面细粮，极少量摄入脂肪（一天内小于20g），适当摄入蛋白质（一天小于200g）； 采购鸡胸肉熟食作为代餐，饿了就吃一块（75g）；采购代餐产品作为选项； 周一三五中午设置闹钟去公司健身房运动半小时，以6km/h时速快步走为主（坡度10°），每日上下班走至少1.5公里； 周六日可以吃两餐非减肥餐，吃八分饱（吃到不饿）； 食品采购上，少量优质，绝不能让剩饭成为负担； 每日记录体重，如果与前日持平则适当反思； 忙碌一些，多多为自己预约一些和吃饭无关的社交活动（参加演讲社团），打打游戏，学习人工智能，和儿子媳妇学英语等等。 目前成效：坚持了三周，体重由82.5到77.8。计划是体重达到74kg可以终止。 人生除了吃以外有太多事情可做。相比之下，德国人和美国人对吃没那么在意，所以他们的餐饮主要是快餐，而正经餐厅多是中餐、法餐、意大利餐或者墨西哥餐。这可能也是美德科技发达的原因所在吧！他们好像在说，我负责去追逐星辰大海，你们负责做菜。","link":"/2021/12/26/diet/"},{"title":"AI学习感悟","text":"此文谈谈我在AI学习上遇到过的困难、这个领域学习的特殊性、近期的学习进展和学习方法小结以及学习感悟。 最近在学习人工智能方面的课程，并坚定信念，立志这次一定要攻克这个知识盲区，不可再知难而退，半途而废。 为什么这么说？原因是在几年间我已经多次发起对这一领域的冲击。众所周知，人工智能是当前的时代骄子，宏图无可限量，其含金量和无限生机不必多言。我也很早意识到了这一点，下决心要入门而后吃透。并且我也深信自己的学习能力，并准备好了专业自学攻克三板斧：找视频教程，倍速观看学习，再通过项目实战快速上手加深理解。 起初，我觉得区区人工智能/机器学习，不过是在自己的计算机学习领域里再添一瓦。待我稍作计划，为期一月，定当拿下。 然而一晃几年过去了，我依然在门外转悠。为何如此？简而言之，就是这个领域有着极高的门槛。 人工智能是一个综合性的学科，或者说根本不是一个学科，本就是一个庞大的跨越学术与实践的知识集合，其中涉及的数学，包罗大学本科的微积分概率论线性代数，也涵盖更高层次的凸优化、矩阵分析、信息论、图论等，更涉及到计算机领域的许多高阶算法。这里涉及的每个学科都有大量的晦涩抽象的数学概念。如果不具备扎实的数学功底，听老师讲课很快就会彻底迷失。举例来说，人工智能的入门课程中，老师一般会先介绍一些学习人工智能的意义、历史之类的比较水的知识；渐入主旨后，会突然抛出损失函数的抽象公式，紧接着噩梦开始，概念轰炸全面启动，什么凸集、梯度、Hessian矩阵、对偶问题接踵而至，等谈及基于这些概念之上的理论，比如支持向量机、随即森林、拟牛顿，大脑已经进入无暇应接的死机状态，索性眼一闭不睁开始酝酿睡眠。 既然理论学习不成，先进行实践应用，再反过来理解背后原理，可否？做个项目尝尝甜头，像玩游戏般慢慢摸索，可行？答案是基本行不通。人工智能的项目，或者说机器学习的项目，大多基于大量数据，项目运行起来也很抽象。从项目入参到结果之间的黑箱，如果不理解这其中的原理，可以说是极其复杂甚至深不见底的。 于是只能老老实实的从头学习，把不明所以的概念统统搞定，那么就有漫漫长路要走。问题来了，这个学科需要的知识积累，大都需要投入大量的连续时间。因为难度较大，需要专注和持续，三天打鱼两天晒网，断断续续，一定是不行的，断了不一定能续上。这对于上班族来说，就格外困难：试想这星期好好学了一周，下周突然诸事缠身，那么下下周再学习的时候，发现很多概念又要重新理解。时间推移，心态变化，难免最终放弃。 总而言之，这个领域的学习，靠我之前的三板斧，肯定是行不通了。要重新审视，严肃对待，思索度量。 如今，经过今年新一轮的努力，终于感觉自己有推开门扉，跨入厅堂的感觉，很多脉络逐渐打通，很多概念能够理解领悟。其中的原因总结起来，有如下几点： 一，学习动力：此事最为根本，之前单纯为了学习而学习，望梅止渴，难以持续数月。往往不够坚定，借口搪塞，心有不甘却力有不逮。今年参加了微软的AI School项目，并和领导朋友夸下海口，颇有背水一战的意思。 二，学习材料：借助各种知识和内容分享平台，寻求概念的多方解释，加强理解。有不懂的关键概念，一定先从其他内容平台听讲明白了，再回到主线教程上听讲。人工智能教程的前8节课，视频时长总计16小时，但我却足足学习了上百个小时，为了打好基础，我找来考研数学的教程，如获至宝。考研数学和AI数学基础有很大的重合部分，而考研数学老师很擅长理论结合题目以及实例对概念进行讲解，拨云见日。另外针对考研数学没有涉及的数学概念，我在Bilibili的内容平台上也找到各种老师的讲解。往往针对一个关键概念，会听2到3个老师各讲一遍，从而加深理解，突破重点。 三，时间安排：利用好宝贵的大块时间、高价值时间。比如，早上起床后的2小时，可谓是学习的黄金时间。低价值时间，如晚上下班后和比较零碎的时间，可以用来处理琐事和娱乐，不必拘泥全情投入。 四，学习方法：由整体到细节：先从整体上推进，然后带着问题对疑难点各个击破。形式上重拾笔纸，适当做些练习题加强巩固。另外和编程相结合，比如可以写一些矩阵计算、梯度下降的代码，加深对过程和概念的理解。适当读书作为参考，相互印证，加深印象。 不一而足，综合以上措施，这次的学习进展明显更加乐观了，而且形成了良性循环的正反馈系统，有了新的学习方法和综合方案，渐入佳境。 最后谈一谈学习的感悟和收获。经过对这个深入的综合学科的学习，我更加具象地了解到数学的现实意义。众多学科，万法归宗，数学是宗，源远流长。线性代数和矩阵代表了数学对现实世界的描述方式，看似抽象，实际很具体。而回归和优化问题代表了总结、判断和问题解决的数学解读，相互贯通。这些生涩的概念领域反而让数学与现实世界更加贴近。 这方面的学习经历也让我格外体会到，大学和研究生阶段学习的课程其实有非常重要的意义，人生也需要专门的时间进行更具深度的学习。中国大学教育和高等教育的失败和乱象完全不能说明高等教育学科知识的无意义。绝对不能盲从社会上极具迷惑性的反智思潮，要相信科学，相信学术，坚信知识的力量，立志做博学并学有所长（成）的人。 学海无涯，云帆初悬，长乐未央，且行且悟。 后记近来机器学习的持续进展，感觉这次真的可以有所突破了。这件事还是很值得努力的。 说起来，这个领域的门槛真的挺高，想想自己最近学的都是什么？什么泰勒、拉格朗日、凸优化、广义线性回归、共轭和对偶什么的，年近三十突然搞起这些，皓首穷经，反而年轻。 学习对我有非凡的意义，尤其是针对自己这种有点不可思议的跨界生涯。 而学习这种实践，也不完全不是一件多么崇高的事情，不要把他看的太严重了。 留心处处皆学问。重要的是，不要原地踏步，要积累和检验自己的学习成果，太随意肯定也不行。 善于学习之人，肯定不会脱离实际学成书呆子，也不会嘴尖皮厚腹中空，无所精进。 学而时习，学有所成。","link":"/2019/02/06/ai-learning/"},{"title":"所谓艺术","text":"艺术的内涵和外延并无定论。没人说得清艺术到底是什么。 艺术的形式非常多，诗歌文章可以是艺术，摄影绘画也是艺术。视觉艺术的三个经典分支是绘画、雕塑和建筑，戏剧、舞蹈和其他表演艺术，以及文学、音乐、电影和其他媒体。 现在电子游戏也被认为是一种艺术表现形式。 下面这幅图所示的是1917年法国艺术家马塞尔杜尚的作品《泉》。 那是一个下午 ，杜尚和他的朋友走进了专事生产卫浴设施的J. L. 莫特铁工坊，他们憋着笑在里面寻找着什么，最终买下了一个普通的白底白瓷小便器——周到的店员还告诉他们这件方便工具产自英国贝德福德郡。 杜尚把它带回工作室，从原本正常的使用位置重新翻转了90度，使它看起来像倒置在那里的。然后在水管接头方向的右侧用黑漆属上“R. Mutt 1917”的笔名，为这件作品起了“泉”这个名字。 这东西真的掀起了一阵风浪。 理事会对于“Mutt先生”提交的这件作品是否是艺术品展开了长时间的讨论。 最终，这件大家并不知道是杜尚故意提交的、被视为玩笑的作品被放置在展览会场展墙后方，并没有正式展出。 杜尚为抗议独立艺术家协会理事会主张不一致，认为其无法公正的审视《泉》而决定退出理事会。 此刻，我们也凝视着《泉》，无数艺术爱好者也在美术馆里伸长脖子对它看了又看。可是，我们再怎么看——它真的只是一个爆款小便池。 你是否会心生疑惑： “什么是艺术？” 《泉》是马塞尔·杜尚“现成物”中最知名的作品。他通常选用常见的日用品，将其转化为艺术品。这个过程中，艺术家的角色便是赋予物品意义。 杜尚的现成理论有三个重点： 1.对象的选择本身也是一种创造性行为； 2.通过取消对象的“有用”功能它就变成了艺术； 3.对象的呈现和添加标题赋予它“新思想”。 2004年12月，500位英国艺术界的艺术家、艺术史学者将杜尚的《泉》票选为20世纪最具影响力的艺术作品。 它直接引发我们思考这些问题：制作技法是否是艺术品必须的？艺术家是制作者还是选择者？艺术品与艺术家的关系是什么样的？甚至——什么是艺术？ 可以看到，现成物对传统理解的“攻击”，不仅是艺术的地位，而且指向了本质。 中国人习惯讲，艺术源于生活，高于生活。那么中间的分界线到底在哪里？如果难有定论，就会争执不休。 但是我觉得留下一个开放的命题，好处在于让创造力有无限的空间。我们不应该过多执着于形式，而应该思考作品能否引发思考，产生社会共鸣和影响力价值。 文字艺术里，华丽的诗篇是艺术，写风土人情的也是艺术。 影视艺术里，拍鸟语花香是艺术，拍残酷战争也是艺术。 如果说艺术是某种恰当的提炼和概况，某种极致的表达，那艺术就是客观的，不需要迎合谁。 没有人不懂艺术，因为艺术在每个人心中。艺术本就是源于人的，但艺术无需讨好人。主观的动机，客观的存在。","link":"/2022/02/26/art-definition/"},{"title":"如何阅读一本书","text":"近来读了不少不同类别的书，清偿了一些读书债；特别地，还翻了翻一本叫”How to read a book”的书，颇有感悟，总结为此文。","link":"/2022/10/31/how-to-read-book/"},{"title":"管理和领导的实践心得","text":"​2021年中我荣幸担任了微软技术经理一职，开启了职业生涯的一个新的篇章。这让我经历了一段时间的职业过渡时期，一度很比较困惑，但也正是这样的过程让我获得了很大成长。我开始重新审视人生的核心能力，认识社交和识人用人的重要性，所谓纸上得来终觉浅，绝知此事要躬行。直到我面临和解决了一些管理上的真实问题，例如人才流失、项目进展缓慢，才能够意识到沟通、情绪等人际环节的重要，以及其中有哪些要点。 搞定人是一个难题。搞定微软的聪明人，是这个问题的一个子问题。了解一个人，了解他的aspiration（愿景、愿望），了解他的价值观，借助他的品质和偏好去与他进行有效的沟通，从而提升整个团队的效率，是一个富有挑战的命题。从个人到组织，如何发掘最大的效用，这里既有一些非常高屋建瓴的理论，也有非常有趣的细节。 我的领导告诉我，人与人相处，岁月流逝，最后沉淀下来的都是点滴片段和整体印象，没有人或细数功过；但是温情或肃杀的瞬间却能够铭刻于心。所以沟通的态度很重要，要尽量留下好的、正面的印象。具体来讲，如何指出对方的不足，但却让对方心领神会，衷心感恩，扭转局面，获得成功，最后皆大欢喜？ 这的确称得上是一门艺术。 不过我觉得，这其中的精髓，或者终极的秘诀，在于要有一颗温暖的心。这并不如此四个字看来这么简单，这意味着无论经历怎样的挫折，都不轻易气馁：几瓢冰水浇上去，这心仍是温暖的，不耀眼，不灼人，却在不断散发着光和热。这是何等的境界。 说到这里，这些文字仿佛上身了一丝文艺和狗血的气息。 言归正传谈管理，回归到技巧层面，管理的实践中肯定是有许多方法论可以应用或说套用的。不同的管理人有不同的风格，我和微软的一些经理谈论，吸取经验，听取他们的故事和思索，发现他们每个人的气场和风格都不太一样。 有一位经理虽身在外企（即微软）混迹十数年，却特别喜欢研究和讨论中国古代官场的故事，比如万历十五年之类的，我问他老外的环境里，中国那些厚黑学之类的看起来乌烟瘴气的东西也适用吗，他说人都是一样的，只是在西方文明里的表现形式不同，老外当然没有中国特色的酒桌文化，但是权力斗争和倾轧道理是一样的。他的箴言是“什么是权力，权力就是搞定事情的能力”。 无独有偶，我最近看Maxwell的领导力21法则，里面也提到，“人们经常对领导力产生误解。如果某人有个很响亮的头衔或者被任命某个领导职位，人们就会想当然地认为那个人就是领导者…真正的领导力来自一个人的影响力，而影响力是无法被委任的…”，“管理者就是领导者，是一种误解。” 还有一位经理，我和他说某某某员工能力太差，打算开掉，他说，其实如果你的团队如果个个都很能干，你会很难做；有一两个一看就不太行的，也许也是好事。有能力差的，一方面团队绩效上好划分，同时也给经理更多存在的价值和故事素材。 我的老爸表示，领导的品行很重要，做事要三思有没有上行下效的风险。要善于培养良性环境，看清团队内外的势与利，防止互相倾轧，拉帮结派。要了解团队人的长短，知人善任，然后借力打力。 东方人的哲学充满了浪漫和艺术气息，讲求各种权衡、中庸。西方人则更讲求逻辑缜密，格物致知，实践出真知。我最近参加微软的经理培训：Situational leadership，情境化领导，就把领导和管理的风格分成几类，然后把情景和被管理的人也分成几类，然后不同情况下采取不同的管理风格和策略，力求可套用，可实践。 比如这个理念把领导分为四个层次：辅导(Directing)，教练(Coaching)，支持(Supporting)，托付(Delegating)。如果被领导者处于D1 层次，也就是这个人还在知识、能力和经验等层面有很多欠缺，那么对应的领导风格就是辅导，需要很多事需要手把手的教授，经常给出反馈。如果这个人能力和知识没问题，属于D2，那就教练，多多问问题，多多启发他/她，不要急于给出正确答案。如果是D3，已经能够独当一面，但是还没有很强的沟通和领导能力，则需要多多支持他/她，帮助他/她讲故事和推销他做的事情。如果是D4，这个人各方面都很成熟，那就多多给他/她表现机会，多给他/她事情做。 当然情景化领导力这个课程还有很多丰富的内容，课上导师会有很多互动和实例沟通帮助大家加深理解，比较有趣。 总归来讲，管理和领导的问题是和解决具体问题截然不同的事情，思考方式有所区别。理性和感性都要兼顾。","link":"/2022/02/16/leadership-practice/"},{"title":"PlantUML指北：用UML设计和规划你的项目","text":"随着ChatGPT爆火，网络上贩卖焦虑的声音此起彼伏，我等工程师、程序员似乎马上要被一锅端起，倒入历史涡流。笔者想说，莫慌，软件开发是一门极其复杂的学问，断然不是写两行代码那么简单。产品百万千万行的代码依然需要人来读懂和维护，架构设计、模式、扩展性依然是核心命题。UML是软件设计的利器，而PlantUML是一个很好的UML创作工具。 PlantUML简介PlantUML是一个开源的UML绘图工具，目前在GitHub上有7.5K Stars，最早于2021年10月发布第一个正式版本，历经二十多个版本迭代，目前已非常成熟。它可用于快速创建UML（统一建模语言，Unified Modeling Language）图表，生成可视模型，帮助开发者将复杂的设计概念表示出来PlantUML 最与众不同的地方在于它提供了一套简单的纯文本语法来定义UML，堪称是UML界的Markdown，起到了桥梁和规范的作用。也就是说，你可以扫描代码来生成PlantUML，也可以解析PlantUML文本来生成代码。 PlantUML开源社区也很繁荣，其结果就是它丰富的插件，可与Visual Studio Code，JetBrains，Eclipse，NetBeans等系列IDE集成，以方便创作和预览。它能生成的视图支持包括SVG，PDF，PNG，EPS和LaTeX等丰富格式，基本上应有尽有。此外，PlantUML甚至还可以支持思维导图、甘特图、JSON、YAML的可视化，把影响力扩大到了UML之外。它已成为越来越多神级工程师、架构师、项目经理的必选工具。我在微软的开发团队出品的开源作品 Hydra Lab 就采用了PlantUML进行架构设计和协议规范可视化，用起来可谓得心应手。 关于PlantUML的细节用法，官方中文文档已经说得很清楚了，本文将不再赘述，而着重将篇幅放在具体使用经验的分享上。 小试牛刀PlantUML是一个基于Java的工具，需要Java运行环境。本文将基于其当前最新版本1.2023.1进行实战讲解。不过，最快捷的试用PlantUML语言的方法莫过于直接使用官网的服务，各位可以尝试把一下内容粘贴进输入框看效果： 以下代码呈现了类之间关系的表达，学习UML时候最容易搞混的就是各种箭头之间的区别和联系： 1234567891011121314@startuml class-relations-1Postman -- Postbox : associate，（关联）Driver -- Car : drives（关联） &gt;Car *-- Wheel : have 4 （包含，组合） &gt; Car -- Person : &lt; owns（关联）Folder *-- 字母F : starts with (composition，组合) &gt;Folder o-- File : contains (aggregation，聚合) &gt;Department o-- Employee : contains &gt;@enduml 下面的代码展现了或者扩展、实现、依赖的类间关系： 1234567891011121314151617@startuml class-relations-2Cat -up-|&gt; Animal : extends &gt;Dog -up-|&gt; Animal : extends &gt;class Cat { -meow()}class Dog { +bark()}iPhone ..|&gt; SmartPhone : realize （实现） &gt;DBReader ..&gt; DB : depends on （依赖） &gt;@enduml PlantUML会自动处理图表的外观和布局，开发人员可以不用在意细节，同时他也支持一定程度的自定义。他的语法中使用@startuml和@enduml作为开头和结尾的声明，此外还有@startjson和@startyaml支持JSON\\YAML数据结构的可视化，@startgantt用于画甘特图，@startmindmap用于绘制思维导图，@startmath（AsciiMath）或@startlatex（JLaTeXMath）用于绘制数学公式，功能可谓十分强大。这里仅展示一些示例，不再一一赘述，官方PDF写的很清楚了。下面是一段Spring Boot配置文件的可视化： 1234567891011121314@startyamlserver: port: 9886 compression: enabled: true min-response-size: 102400spring: cache: type: ehcache application: name: 'my-app' datasource: driver-class-name: org.sqlite.JDBC@endyaml 以下是一个活动图（activity diagram）示例： 12345678910@startumlstartif (Graphviz installed?) then (yes):process all\\ndiagrams;else (no):process only__sequence__ and __activity__ diagrams;endifstop@enduml 更多示例可以看这里：REAL WORLD PlantUML。 实际应用在实际的开发场景中，我们可以运用PlantUML语法规范在代码库中进行撰写设计，以文本的形式输出内容到.puml文件中，然后调用PlantUML来生成可视化的图表，从而方便用来在Markdown技术文档当中引用，支持技术评审。那么，我们是否可以自动化这一流程，形成闭环？答案当然是可以的，PlantUML提供了Java依赖库，可以在代码中直接调用。这里演示一个小小的实例，利用Gradle创建构建任务，实现UML图片生成。 首先我们在项目中添加PlantUML依赖: 1implementation 'net.sourceforge.plantuml:plantuml:1.2023.1' 接着，我们在Gradle中创建一个任务，扫描特定目录下的所有puml文件，将他们交给生成逻辑（UMLImageGenerator#generateUMLImageFromFile）进行处理： 12345678910111213task generateUMLImage(group: 'documentation') { doFirst { def scanningDirList = ['agent/doc/UML'] def outputDir = new File(projectDir, 'docs/images/UML') def generator = new UMLImageGenerator() scanningDirList.each { fileTree(new File(projectDir, it)).filter { it.name.endsWith(&quot;.puml&quot;) }.files.each { generator.generateUMLImageFromFile(it.absoluteFile, outputDir) } } }} 具体的从文件生成图片的逻辑如下，这里调用的核心类就是PlantUML提供的SourceFileReader API： 12345678910111213141516171819202122232425import net.sourceforge.plantuml.FileFormat;import net.sourceforge.plantuml.FileFormatOption;import net.sourceforge.plantuml.GeneratedImage;import net.sourceforge.plantuml.SourceFileReader;import java.io.File;import java.io.IOException;import java.util.List;public class UMLImageGenerator { public void generateUMLImageFromFile(File source, File outputDir) throws IOException { generateUMLImageFromFile(source, outputDir, false); } public void generateUMLImageFromFile(File source, File outputDir, boolean svg) throws IOException { if (!source.exists()) throw new RuntimeException(source.getAbsolutePath() + &quot; file doesn't exist&quot;); SourceFileReader reader = svg ? new SourceFileReader(source, outputDir, new FileFormatOption(FileFormat.SVG)) : new SourceFileReader(source, outputDir); List&lt;GeneratedImage&gt; list = reader.getGeneratedImages(); System.out.printf(&quot;Successfully generated %d UML images.\\n&quot;, list.size()); }} 与上逻辑写好之后，我们在Gradle的任务列表documentation组中就可以看到这个新的任务了： 执行这个任务，就可以看到图片图片说出到了预期的目录下。本实战案例详细代码如下： generateUMLImage任务定义 PlantUML依赖声明 UMLImageGenerator.java 进一步探究我们是否有可能根据UML设计来生成代码？那么首先我们需要读取出PlantUML的解析信息，顺着SourceFileReader的API我们可以进一步找到如下调用链: 12345Diagram diagram = reader.getBlocks().get(0).getDiagram();if(diagram instanceof net.sourceforge.plantuml.classdiagram.ClassDiagram){ ClassDiagram classDiagram= (ClassDiagram) diagram; classDiagram.getLeafsvalues().forEach(leaf -&gt; System.out.println(leaf.getCodeGetName()));} 这里的net.sourceforge.plantuml.baraye.ILeaf类型的对象就是解析后的叶子实体了，包含了代码生成所需要的信息，可以利用他来生成一些接口代码，从而进一步实现从代码设计到初始实现的自动化。 雪崩将在山的某一高度爆发。攀登者们在奋力上爬，他们知道雪崩即将发生，但并不知道在什么高度，什么时候到来，他们能做的只有奋力向上爬。","link":"/2022/11/01/plantuml-get-started/"},{"title":"领导力21法则读书笔记","text":"追随这些法则，人们就会追随你。 The 21 irrefutable laws of leadership, follow them and people will follow you. 书评优点:很多观点切中要害，非常实际、实用和恳切。启发性很强。理论和概念的拔升和抽象到了一定的高度，很有水平。 作者对事物有很强的概括和梳理能力。对领导力的思索很深刻。 有很多例子和故事来辅助理解。例子都很贴切，也很有趣。 缺点有些观点对于领导者太卷了，容易把人吓跑。21条，数量太多了，容易让人抓不住重点。有些观点不够与时俱进，笔者似乎对于科技的进步不够重视。有些说法比较绝对。 书籍脉络 盖子 Lid 个人和组织的办事效力与领导力成正比 人际交往能力 规划能力和战略思维 远见 业绩 麦当劳例子 接管和改善一个组织：培训所有员工，解雇原来的领导者 影响力 Influence 如果没有影响力，你永远不可能领导别人 特蕾莎例子：真正的领导者发言时人们会洗耳恭听 关于领导力的五大误解 管理者就是领导者 企业家就是领导者 知识渊博的人就是领导者 引领潮流的人就是领导者 位高权重的人就是领导者 衡量领导力的尺度只能是影响力 知识 直觉 经验 过去的成就 能力 过程 Process 领导力的提升需要日积月累，而非一日之功 领导者都是善于学习之人 不知道你不知道 知道自己需要知道 知道自己不知道 我知道，我成长，我发现 因为我知道 阶段五：你拥有高度的直觉 实干家罗斯福：做了673场演讲，全国各地旅行20000英里 导航 Navigation 任何人都可以掌舵，唯有领导者才能设定航线 看得比别人多，看得比别人远，在别人看到之前看到 过去的经验 做承诺前或考察各种情况 多听从他人意见 PLAN AHEAD Predetermine a course of action Lay out your goals Adjust your priorities Notify key personnel Allow time for acceptance Head into action Explore problems Always point to the success Daily review your plan 一个成功方案的最大阻碍 对改革的恐惧、未知 对未来的不确定 想象力的缺乏 增值 Addition 提升价值，增加利润 辛内加尔领导Costco的例子 如果想独领风骚，那你就得不到员工的忠心 如果不能把功能让给别人（把失败的责任留给自己），那你就无法激励别人，最终只能自毁前程 拥有正确的领导动机 领导者要服务他人，提升他人的价值 你让你的追随者改善生活了吗？ 根基 Solid Ground 信任是领导力的根基所在 品格 彰显一贯性、潜力和赢得尊重 尊重 Respect 人们愿意追随比自己强的领导者 一个人的领导力越强，就能越快发现别人的领导力潜质，或者发现别人领导力的不足 获得尊敬的条件 领导能力 对他人的尊重 勇气 过去的佳绩 忠诚度 为他人增加价值 直觉 Intuition 每个人都在自己擅长的领域富有直觉 妻子玛格丽特对着装的直觉 吸引力 Magnetism 你只能吸引和你相似的人 你所吸引的人不是由你的愿望决定的，而是由你的为人决定的 如果你觉得你所吸引的人应该更优秀，那就到了你应该提高自己能力的时候了 亲和力 Connection 得人心者得天下 与人交往方面，感情要先于理智 我们都希望演讲者的讲话更有人情味 与个人亲善 展现真我 我的个性是什么：优点和缺点？ 能力？最大资本和不足？ 坦率真诚 了解对象 身体力行 身临其境 关注他们，而不是你自己 信任他人 指明方向，带来希望 在着手工作之前，先联络感情： 优秀的领导都是人际关系大师 核心圈 Inner Circle 一个领导者的潜力，由最接近他的人决定 将谁划入核心圈 是否对其他人有很大的影响力 是否能给团队带来互补性的才能 在团队里是否担任要职 能否增加我团队的价值 给核心圈的其他成员带来积极的影响 鉴别 - 培养 - 吸收 不断提高你的核心圈素质 当你的直属人数超过7个人，不是每个人都能直接领导的时候，应该建立核心圈 授权 Empowerment 有安全感的领导者才会授权予人（例子：亨利福特，反例，不授权，坚持T型车，导致持续亏损，直至亨利二世接管） 谁才是老板？授权的障碍： 渴望工作上的安全感 抗拒改变 缺乏自我肯定 找到有能力的领导者并授权给他们 镜像 Picture 看到别人怎么做，大家也会怎么做（兄弟连电视剧对美国军队的影响） 领导者必须要成为梦想家，你的领导水平越高，你的工作就越多是关于预见未来可多事情 一定要实际：对愿景的有效示范是把镜像变成现实 领导者愿景的典范 下属总是在观察你的所作所为 教正确的事总比坐正确的事容易 领导者能给下属的最宝贵的东西就是一个好的榜样 接纳 Buy-In 人们先接纳领导者，然后接纳他描绘的愿景 领导者先于愿景：你就是信息 领导者和愿景：并非两者之中择一 当追随者不喜欢领导者及其愿景时，他会去找另一个领导者 当追随者喜欢领导者，却不喜欢其愿景时，他们愿意改变愿景 当追随者同时欣赏领导者及其目标时，他们会全力以赴 成功是以你是否有能力带领下属达到他们认同的目标来衡量的 制胜 Victory 领导者为他的团队找出一条制胜之路 丘吉尔绝不接受任何妥协 我们的目标是什么？用一句话回答，赢得胜利！不惜任何代价，不管面对多少恐怖，我们就是要打胜仗。不管这条路有多长、多难。不能获胜，就只有灭亡。 胜利的要素 统一的目标 多样化的技能 一位愿为胜利而献身、致力于发挥队员潜能的领导者 制胜是领导者的本分 动势 Big Mo 动势是领导者最好的朋友 皮克斯和玩具总动员，对比同时间迪士尼 当对方连续得分、动势越趋强大的时候，优秀的教练会立刻叫暂停。 一旦产生了动势，你就不会担心小问题。 如果没有了动势，就连最简单的任务也会变成登天难题。 动势是放大器 动势可以美化领导者 动势帮助下属们表现得更好 掌握动势的方向要比创造动势容易 动势是带动改变最有力的因素 创造动势是领导者的责任 动势从领导者自身产生 激励是创造动势的关键要素。 优先次序 Priorites 忙碌不一定等于成效 三R法则 Requirement 什么是你必须做的分内之事？ Return 什么能带来最大的收益？ Reward 什么能带来最大的回报？ 在所有活动中，只要集中注意最重要的那20%，你就能获得你付出努力80%的回报。 领导 Leadership 沟通 Communicating 创作 Creating 联络 Networking 杰克韦尔奇 快刀斩乱麻，集中力量：保留能占领世界第一或第二的生产线 舍得 Sacrifice 领导必须先舍后得 牺牲是领导力的精髓：成功的领导者懂得牺牲次要的东西 地位越高，舍弃越多 牺牲是一个持续的过程 时机 Timing 掌握时机与善用策略同样重要 时机决定一切 在错误的时机采取错误的行动，结果是酿成灾难 在错误的时机采取正确的行动，结果是抵制 认识：对局势有清楚的认识 成熟 信心：人们往往追随心里有谱的领导者 果断 经验 直觉 准备 在正确的时机采取错误的行动，结果是犯错 在正确的时机采取正确的形成，结果是成功 行动的目标？谁负责？市场、行业如何 爆炸性倍增 Explosive Growth 培养追随者，得到相加的效果；培养领导者，得到倍增的效果。 帮助别人领导 培养追随者的领导者： 发展最下层的20%； 专注于人的弱点； 一视同仁； 在一般人身上花费时间； 以加法方式成长 只影响到身边接触到的人。 培养领导者的领导者： 发展最优秀的20%。 专注于人的长处； 因人而异； 在人才上投资时间； 以乘法方式成长。 影响力扩及甚远。 培养领导者的挑战：领导者难觅、难聚、难留 如果你一直为你手下的领导者提升价值，他们就会愿意一直追随你。 阶段：提高自己》发展团队》培养领导者 传承 Legacy 一个领导者的长久价值由其继承者决定 发展你的领导遗产 清楚自己希望留下的遗产 实现自己希望留下的遗产 挑选你事业的继承人 确保顺利传递交接棒 21 irrefutable laws of leadership - John Maxwell’s 21 leadership laws explained with examples - unremot.com","link":"/2022/09/18/21-leadership-laws/"},{"title":"Ah king&#39;s fight - the APPLY method","text":"OpeningGood evening everyone, today the topic is Ah king’s fight. Does anyone know what’s the possible meaning of it? Let me explain more. In every toastmaster session, the one who used the most filler words, like ah, um, er, so, will be granted with this crown of the ah king. And although I claim to be the only stand up comedian on this stage, I had the luck to win this ah king title for quite a number of times. Lately I realize the ah king is a much safer role, compared to the stand up comedian role, at least you won’t get a big slap on the face by Will Smith, right? And Ah king is still a king, although we are not sure whether there will be a queen. But it’s still a king of the Ah kingdom with the Ah citizens, and the Ah counter. There is no timer king, no grammar king, but there is always an ah king for sure. Let’s stop the joking around. Seriously, cutting out the filler word is a truly challenging task. The filler words are like something rooted in your brain and unconsciously come out your mouth. It’s not something destructive, but it will distract your audience and makes your point pointless. So I start this fight against it, calling on everybody here to be tough on me for this and let whoever else to take take the throne. I have dived into some of the specialist’s guides/blogs on how to overcome it and summed up a methodology. I call it the APPLY methodology. APPLY, all capitalized and each letter is the initial of a key word. APPLYA stands for Awareness.Awareness: Filler Word AwarenessYou cannot correct a problem unless you know you have one. Filler words are invisible to the speaker, but not to the listener. As a speaker you need to acknowledge the issue and confront the verbal tics you have. We should leverage the power of our ah counter, who provides the free service of tracking down the overuse of it. And trust me, once you admit it and want a change, the change is underway. The second letter P represents Pause.Pause: Use Deliberate Pause (Embrace the Pause)Means to use deliberate pause as a replacement of the filler word.Most beginning speakers are afraid of pauses. Well, don’t be, try to embrace it. How about we embrace it now, as an experiment. A 10 seconds pause is absolutely better than 10 second errrrr. A pause is actually more impressive than a filler word. The silence can create suspense, demonstrate your confidence. It can be dramatic and even magical. The other P here stands for Preparation and Practice.Preparation: Get Prepared (Know Your Point)If you know your topic thoroughly and have rehearsed your speech, delivery in front of an audience will go more smoothly and you will be more confiden. To cut out filler words, it would be super helpful if you believe in the importance of what you are saying. Filler words generally come in when you don’t view the presentation as a conversation. So just get prepared and practice, know your point and make the point. And impromptu speech like the table topic sessions are great chances to practice as well. L is for Loud and Clear.Loud and Clear: Slow DownYou can try increase your volume and slow down the pace to make the point clear. This would give your brain the chance to organize the words into points. To insert the deliberate pauses also help with this. These are the effective countermeasures for a fast talker. Y is forYou can do it! Be confident!Have faith in your self, you can get rid of it. Find your positive circle and ramp up step by step. The number of fillers will go down and your confidence will go up. Apply it, develop the awareness, embrace the pause, prepare and practice, be loud and clear, and you can do it. You will find that it’s not something embedded in your genetic settings. All of us can be a great point-maker. That’s it, thank you!","link":"/2022/07/18/ah-king-fight-apply/"},{"title":"未来简史读后感","text":"元旦期间听了罗辑思维的跨年演讲，罗胖在节目中推荐了一本书，叫未来简史，说是刚刚译著的国内独家版本，并把这本书吹说的比较玄乎，说是回答了未来社会走向何方的问题。当时我还以为又是一本预言未来的书籍，并没有特别大的兴趣。仅仅是听了跨年演讲比较兴奋，加上想到听了罗胖两年多的节目，一分钱没掏过，索性就扫码拍了。这难道就是传说中的社群经济？我终于还是掏了腰包。 收到书已经是临近春节期间了，读完书的序章，饶有兴趣，就趁着春节得闲一口气读完了，从而完成了2017书单的一小部分，达成了零的突破。 读完全书，应该说是很有收获的，简单谈谈感想。 这本书并不是大放厥词的愚蠢的预测类书籍。相反地，本书更多地在谈历史和现实，只是很多观点非常新颖前卫。我读完第一章，最深刻的印象是，作者的角度和立场都比较冷静客观，能够非常中立纯粹地看待问题，所以他的分析也就给人以不偏不倚、劈头盖脸的感觉，独立且毫不迎合，有着层层递进的严谨逻辑。比如作者谈人类与动物的区别时，并不赖于任何现成的理论，而是完全跳脱的角度，把相关的学说和实验例子摆出来看，没有任何对人类崇拜或是鄙夷、对动物悲悯或冷酷的无聊情怀：谈论国家福利、战争和恐怖主义，完全从现实利益出发，往往略带黑色幽默的味道，比如说到911，作者将其比作“苍蝇钻到大象的耳朵里，力图把世界拉回’丛林法则’状态”的行动；谈及幸福快乐与伟大神圣的爱情，毁三观地说那些只不过是生物化学、脑中的电信号刺激而已；又提出生物就是算法，个体的人也不过是数据的处理单元。这很合我的胃口：脑洞足够大且没有絮絮叨叨的抒情说教。 书中最令我印象深刻的、同时也贯穿全书的一条逻辑脉络谈到，人类与动物最大的不同，不是工具的使用或者语言的发明，而是人类整体善于运用想象力为世界赋予意义，并基于这个共同的虚构意义框架下开展大规模组织合作，比如国家、货币和宗教的神；这些虚构的共同的想象“实体”，让我们能够开展大范围的人类活动，比如国际贸易、跨国公司和十字军东征；并且作者认为，宗教，作为评判标准和人类意义的源头，和科学一起都在推动人类向前；人类过去的意义源头，曾经是多神宗教、单一神宗教的有神论，而今天的世界主流宗教其实是人文主义，即强调自由意志和人本思想的价值体系；而随着近年来科学的快速发展，作者提出人文主义马上会站不住脚，因为科学发现，其实人的自我意识是分裂的（包括体验自我和叙事自我），而意志和感觉也不过是可以生产的产品，所以人本之心作为世界核心的观点会渐渐地站不住脚；人类需要一个新的宗教，关于未来的信仰，作者提出了两种可能，技术人文主义和数据主义。作者正是通过这条脉络，从历史一直探讨到未来。 据我目测，这本书有四分之三的章节都在谈过去的历史和当今的现实，也就是说作者充分考察了人类历史后，才试图对未来简作描述，这些描述也就相对务虚和靠谱一些，真实具体的未来当然是无法预测的。 书的结尾，作者阐述的数据主义的观点可作为全书的点睛之笔，这也是我看到的全书最大的脑洞。这种数据主义思想认为，在我们的世界中，人和神都不重要，宇宙的核心其实是数据，数据的“天性”是分享和传播，数据为了实现这个目的，借助人这个“工具”，数据把人当做处理单元和传播节点，让自己传播出去，整个世界的运作不过是为了实现万物互联的高效数据处理系统…这观点脑洞够大！但是仔细一想，这个数据主义还真没准是未来最靠谱的宗教。实际上，这个宗教现在已经开始快速蔓延了。作者还提出，美国黑客艾伦施瓦茨已经是这个宗教的第一个殉道者了（可自行百度此人）。至少在互联网行业里，分享、共享、记录和传播数据，让算法结合大数据分析人的需求，并不断的把人的行为数据化，基于这些理念诞生了大量的公司和商业盈利模式。如果说这就是未来新的宗教或者价值体系的话，可并不是说这是某种新的可有可无的想法思潮，而是说，不具备、不接受这种思想认识的人，将在未来被时代淘汰掉。 总之，这本书还是比较刷新三观的，书中还有许多论证和探讨以及金句，无法一一分享，推荐大家自己去读读。 这本书对我的比较重要的启发是：其一，想象力很重要，讲故事的能力很重要，谈吐和忽悠很重要，人类太需要意义和故事了，最高层次的营销是信仰和思想的营销，可参见电影盗梦空间（Inception）；其二，人工智能很快会洗刷各行各业，要努力形成不可替代的优势；其三，不要太在意隐私，分享和传播是数据时代的大方向，赶紧参与到分享信息和知识的互联网中来，占个坑位吧，并力图放大自己的节点价值。","link":"/2016/11/18/brief-history-of-future/"},{"title":"大学时代写的未完结的小说 - 重生劫","text":"之前发的那个都说不给力，最近看了些营销学的东西，决定还是同样的故事，换个视角、时序，推翻了重写。写的更加直白一些，更刺激一点儿。 这就开始。 某年某月某日，烈日当空，赫然是旷野孤城的秦城监狱的高墙外，风猎猎的吹，黄沙漫漫的卷，渺无人烟。除此之外，一切还是静的让人窒息。 忽然监狱厚厚的大铁门无声无息的打开，同时，监狱内部轰鸣作响，先是一架武装直升机嗒嗒的飞升脱出监狱高墙，紧接着四辆装甲运输车，隆隆的开出监狱大门，呈一字队形，由直升机低空护送前行。 在装甲车内部，运送的是24名已经宣判死刑的重刑犯人，其中有17名男犯人，7名女犯人。 此时，他们作为国家最具重量级的囚犯，正在被押往行刑的路上。 在他们之中，有的曾是是职业杀手，有的是黑社会组织或邪教的头目，有的是巨额诈骗犯、贪污犯，或是众多刑事案件的幕后指使、策划。在这个单纯的国家，这曾是一股首先出现的高智商犯罪力量。为了逮捕他们，国家煞费心思，或是不得不出动大量武装力量，或是不得不修改法律、定罪莫须有，或是不得不从国际上花重金聘请高级刑侦人员、犯罪行为心理学家，甚至不惜牵动国际关系、请求国际支援。说他们个个凶神恶煞，杀人如麻，倒不一定，但说他们曾是罪魁祸首，心机狠辣，称其一时之罪恶之源，倒不夸张。 此时，他们中的大部分被注射了镇定剂，分开关押在装甲车舱室的隔离间内。装甲车上的特种兵包括司机都全副武装，为突发情况时刻待命。 如此戒备，或显夸张。如果这次只是一个重要犯人被处决，大可不必如此。在这个绝对不容许平民配枪的和谐国度，断不必担心有中国古装片里的大张旗鼓的劫法场的情况出现。但是同时运送24个皆可能在法外还存在巨大残余势力的犯人赴刑，就不得不顾虑这些势力的联合行动。明智稳妥与震慑起见，宁可夸张一点。 既然如此，当局为什么要秘而不宣地对24名重要犯人集中进行处决呢？ 这个问题先留着。 说着，装甲车已由旷野开进山林。执行死刑的场所并不固定，大多在人迹罕至的荒山谷中，行刑过程是绝对禁止平民观瞻的。根据国家法律规定，执行死刑一般采用枪决、注射两种方法，以减轻犯人痛苦的人道主义为原则，尽可能实现“安乐死”。这次，装甲车上预备了注射药物，军医随行，要对这24位魔头采用注射行刑。 既然是注射死刑，为什么还要将犯人带到野外行刑呢？这个问题车上的大部分士兵也无法回答，他们只是受到上级指令执行任务。当然，在领队的装甲车乘上有一位执行长官。 车队停在一处谷地中，林风阴凉，直升机继续在附近盘旋。 “报告长官，方圆一公里内无异常情况。”直升机飞行员用对讲机报告。 “收到。”长官同时下令道：“开始行刑！” 特种兵迅速行动，犯人每六个一组开始行刑。我国注射行刑过程主要分三次，第一次药剂注射起到麻醉大脑的作用，第二次注射药剂让全身肌肉放松，最后一次注射才让心脏停止跳动而致命。 这时，四位身着白大褂的军医从车舱内躬身走出，戴着口罩医帽。特种兵的迷彩队伍中，医生的白衣显得很乍眼。他们各提一个金属医药箱，准备进行最后一剂药物注射。 很快医生熟练地完成配药，开始平静地对一个个软瘫的身体进行静脉注射。 凉飕飕的林风拂动了白衣的衣摆，不知这些盈满罪孽的灵魂是否也乘风而去了。 行刑完毕几分钟后，两辆殡仪车缓缓驶来，负责护送的特种兵例行汇报完成任务，执行长官批准撤离后，直升机装甲车队就浩浩荡荡开离刑场。不大的空地上一下子少了许多人，只剩下几位军医、殡仪人员，还有这位长官。 这位长官一身戎装，身形高大，腰背笔挺，不动声色的站了一会儿，大概是估摸时间够了，命令殡仪人员开始向车上搬运犯人“遗体”。 搬运过程中，一位犯人的“遗体”腿部突然抽搐了一下，搬运的人并不为动容，仿佛在意料之中一样。 这位长官脸上也并无异色，却转而问站在身旁的军医。 “医生，他们的身体状况如何？” “报告长官，目前这24个人的身体状况一切正常。” “长官，刚才为犯人最后注射的是降低心率的苯妥胺，现在须进行心率恢复。”这名军医又说。 这位长官看“遗体”已经尽数抬上车，答道：“恩，你们现在去吧，让司机开车” 两辆殡仪车缓缓地驶出了山谷，车上原本挂着的黑色挽花、黄白花环已经全部卸下，现在俨然是一辆朴素的客运巴士，正向着市区行去。车内部，监护仪、麻醉机、呼吸机等医疗器械一应俱全，各自滴滴答答地做响着。穿白大褂的、穿黑色殡仪礼服的俱在车内熟练地忙碌着，24个本已应逝去的邪灵的呼吸声、心跳声一下比一下加强着，随着心电图上的波动由微弱到逐渐强劲，这些声音，带着重生一般的力量，似乎要盖过汽车运行的隆隆声，在旷野上发出了轰鸣。","link":"/2012/02/18/novel-without-ends/"},{"title":"成长的边界：读书心得","text":"概览全书要点： 鼓励“不一致性”：美国挑战者号的例子。 过早专业化不一定100%可行。在人工智能的时代，人的核心价值是否在于高度的专业化？ 保持开放的心态。例：凡高生涯。 对于育儿：培养复合能力。（从上一个辅导班变成上3个辅导班？） 什么是现代化的文明：建立共识。智商：共识的加强。 对于软件工程师，提升创新力，只要是有利于自己提升和成长的，都可以保持开放的心态。 对于管理者和领导者，需要思考在团队中扮演什么样的角色。构建多元化和有包容性的团队。 局限性 例证和过度解读嫌疑。 作者何许人？David Epstein： David Epstein (journalist) - WikipediaDavid Epstein is an American journalist. He currently works at ProPublica. He is the author of two books, Range: Why Generalists Triumph in a Specialized World (2019) and The Sports Gene: Inside the Science of Extraordinary Athletic Performance (2013).Prior to ProPublica, Epstein was a senior writer at Sports Illustrated, where he specialized in science issues in sports and investigative reporting.[3] With his colleague Selena Roberts, Epstein broke the story that the Yankees’ Alex Rodriguez tested positive for steroids in 2003. 相关概要信息本书英文名： Range: Why generalists triumph in a specialized world Why specializing early doesn’t always mean career success | David Epstein - YouTube 通才在AI崛起的时代有巨大的意义。 未来社会趋势万变，我们需要把自己锻炼成瑞士军刀，用跨界不断拓展能力范围–成长再无边界，未来无尽可能。 全书结构： 引言：费德勒VS泰格伍兹 天才Tiger Woods 成长。 对一万小时定律的质疑。 晚一步专业化的好处，和过度专业化导致的危机（2008金融危机）。 赢在起跑线的教育狂潮 波尔加姐妹故事：国际象棋大师的记忆力。 这个世界不是打高尔夫球，也不是打网球。这个世界上的大部分都是“火星网球”，虽然你能看见选手们拿着网球和球拍出现在赛场上，但是没有人知道准确的规则。你可以推导规则，但是规则也会悄无声息的改变，当然也不会通知你。Kind learning environment and wicked learning environment。 香农（通过学习哲学）意识到自己可以把电话的路由技术和布尔的逻辑系统结合，任何形式的信息都可以用电子方式进行编码和传输。这一发现正式计算机赖以生存的基础。“这也是碰巧而已，因为没有其他人 同时对这两个领域都熟悉。”香农说。 抽象思维和概念推理 士兵的智力测试 结果的代际进步（James Flynn瑞文标准推理测验 Raven’s Progressive Matrices）。如今的年轻人被要求描述“黄昏”与“黎明”之间的相似之处。 现代化和集体主义。前现代人只见树木不见森林，现代化社会的人只见森林，不见树木。 能够广泛应用知识的能力来自涉猎广泛的训练。 可遇不可毁的创造力 figlie del coro, 唱诗班的女儿们，多种乐器专家。 马友友和虎妈。 爵士乐和五线谱：David Brubeck 天生对视，无法看清五线谱。姜哥烧伤 学习，快与慢 合意难度和间隔期。最好的学习之路“道阻且长”。不仅进度缓慢。而且在眼下也可能表现不佳。艾奥瓦州的测试实验，研究人员给三组人员念了同一组外文单词，第一组被要求马上背诵；第二组有15秒复习；第三组被要求做50秒的数学测试，没有时间复习。听完即刻复述的效果最好。但后面在测试完毕之后实验者被告知临时增加测试，第三组人员效果最好，因为第一次测试帮助他们把短期记忆转变成长期记忆。 广泛性的思考可以帮助我们远迁移，形成长期性的成果（长久而有效的、具备灵活性的知识）。 跳出经验外，思在新境中 开普勒的例子：运用类比的思维，“类比是我最忠实的大师，它熟悉大自然所有的秘密”。气味的散发和动力类比，漩涡和引力。。。 外部视角：投资人对项目评估的时候多多的找具有广义相似性的案例作为参考。 邓巴记录高产实验室的工作方式：坐下来讨论工作和实验中遇到的挑战。邓巴的研究项目中，只有一个实验室没有任何新发现，团队中的每个人都有着相似且高度专业化的背景，而类比几乎从未被使用。“这有点像股票市场，你需要一套综合策略”。 过于坚持，也有问题 凡高三天打鱼两天晒网，各种停滞不前。艺术学校，艺术品销售，教师助理（法语和数学），矿区布道，书店店员。 Match quality：一个人工作和其自身的匹配程度。野兽军营和多臂老虎机。 恒毅力和短期规划 发掘自身更多的可能。 赫塞尔本：女童子军的领队到三百万会员的女童子军组织首席执行官。赫塞尔本连大学都没毕业，但是她办公室里挂满了23个荣誉博士文凭，还有西点军校授予她的一把亮闪闪的军刀，还有总统自由勋章。 历史终结错觉：我们对于工作和生活的偏好不会一直不变。我们意识到自己的欲望和动机在过去的日子里有了大幅度的变化，但是我们又相信，这些欲望和动机在未来不会有太大变化。 局外人的优势 专家们创造的专业信息越多，好奇的涉猎者能 做出的贡献就越多，他们把广泛存在但是迥然不同的信息整合在一起，这就是那些未被发现的公共知识。人类知识的图书馆越庞大，越容易进入，好奇的读者就越有更多的机会在前沿建立联系。 用过时的技术横向思考 横井军平 （Gunpei Yokoi）：是否可以开发一个体积足够小的游戏机，这样上班族就可以在通勤时轻松打发时间？夏普和卡西欧的计算器大战。从技术角度看，即使在1989，Game Boy的技术都是非常可笑的。屏幕只有四阶灰度可选。人物快速移动式，屏幕显示就会有些模糊。英国女王看见自己的孙子在用Wii打保龄球，她决定亲自上阵。Nintendo switch 集大成，任天堂历代产品的DNA：体感、手柄设计、便携。连续性创新者：Π型人，横向思考的整合者。 被专家愚弄 人口爆炸。离谱的专家预测。 学着放下熟悉的工具 赛车决策：引擎可能存在问题，有失败风险。挑战者号O型圈被侵蚀。哥伦比亚号。 野外消防员不愿意放下背包。 同心圆管理，组织的结构不应该是阶梯式，而应该是由多个圆心组成。等级森严的组织 刻意的初学者 星期六早上的实验：Oliver Smithies, 研究胰岛素和胰岛素分子的分离；别把你的技术应用在老的地方。带上你的技术去解决新的问题，或者带着你的问题去学习全新的技术。 三无教授屠呦呦：没有中国科学院的院士资格，没有海外研究经历，也没有研究生的学历。 生物交叉学科的诺贝尔得主，Max Delbruck 的原则：有限马虎原则。要注意不能太小心了，不然你会不自觉的限制自己的探索。 创新的生态系统应保持广度和低效率。 结语：拓展你的广度学习 像米开朗基罗对待大理石的态度一样对待你自己的旅程和项目吧：愿意学习和改变，如果有需要的话，甚至可以放弃此前的目标，彻底的改变方向。 专业化本身没有任何错误。只不过专业化的程度和内容有所不同。 这是一次实验，因为所有的生命都是一次实验。最高法，奥利弗温德尔霍姆斯。","link":"/2022/02/17/range-reading/"}],"tags":[{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"面向切面","slug":"面向切面","link":"/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"夏令时","slug":"夏令时","link":"/tags/%E5%A4%8F%E4%BB%A4%E6%97%B6/"},{"name":"历史","slug":"历史","link":"/tags/%E5%8E%86%E5%8F%B2/"},{"name":"字节码","slug":"字节码","link":"/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"},{"name":"bytecode","slug":"bytecode","link":"/tags/bytecode/"},{"name":"Code design","slug":"Code-design","link":"/tags/Code-design/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/tags/Design-Patterns/"},{"name":"GoF","slug":"GoF","link":"/tags/GoF/"},{"name":"15分钟","slug":"15分钟","link":"/tags/15%E5%88%86%E9%92%9F/"},{"name":"自我管理","slug":"自我管理","link":"/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"},{"name":"育儿","slug":"育儿","link":"/tags/%E8%82%B2%E5%84%BF/"},{"name":"减肥","slug":"减肥","link":"/tags/%E5%87%8F%E8%82%A5/"},{"name":"艺术","slug":"艺术","link":"/tags/%E8%89%BA%E6%9C%AF/"},{"name":"领导力","slug":"领导力","link":"/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"开发工具","slug":"开发工具","link":"/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"方法论","slug":"方法论","link":"/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"悬疑","slug":"悬疑","link":"/tags/%E6%82%AC%E7%96%91/"}],"categories":[{"name":"打码要义","slug":"打码要义","link":"/categories/%E6%89%93%E7%A0%81%E8%A6%81%E4%B9%89/"},{"name":"刨码问底","slug":"刨码问底","link":"/categories/%E5%88%A8%E7%A0%81%E9%97%AE%E5%BA%95/"},{"name":"健康","slug":"健康","link":"/categories/%E5%81%A5%E5%BA%B7/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"人生杂谈","slug":"人生杂谈","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/"},{"name":"演讲技巧","slug":"演讲技巧","link":"/categories/%E6%BC%94%E8%AE%B2%E6%8A%80%E5%B7%A7/"},{"name":"管理","slug":"管理","link":"/categories/%E7%AE%A1%E7%90%86/"},{"name":"小说","slug":"小说","link":"/categories/%E5%B0%8F%E8%AF%B4/"}],"pages":[{"title":"关于我","text":"大家好，我是内森(GitHub: Nathan Bu)，欢迎来到我的水水水文输出阵地。我2013年毕业于南开大学，目前在微软中国担任研发经理。希望在这个空间和大家分享交流技术心得，职业生涯，团队和项目管理，趋势动态，生活日常。旨在畅谈分享，不拘小节；但也不排除会刨根问底、钻牛角尖。 本人热爱技术和打码，尤其享受用技术解决实际问题的过程；相信创造力是顶级能力，是人价值的放大器。此外，本人专注于软件和代码质量、工程效率和研发能效方面多年，目前在微软和团队一起推动2023年新开源的项目Hydra Lab的完善与发展；欢迎和我在开源世界组队打码，造新轮子，添砖加瓦。 其他爱好有打篮球，翻书，叨逼叨。 自称是个全栈，涉猎的技术：Java, Python, Android, React, Node.JS, Gradle, Docker, C/C++, Spring。 搞过的技术领域： 移动互联网广告、强化学习、工程系统、自动化测试、DevOps、Azure。 能够胡吹的话题： 自动化测试、研发能效、产品质量控制、大型项目管理、人工智能、广告变现、团队管理、高效沟通、企业财务、国民经济。","link":"/about/index.html"},{"title":"","text":"1234567891011121314151617181920212223@startuml strategyclass SolutionContext { IStrategy strategy void solveProblem()}interface IStrategy { int compute()}class StrategyA { int compute()}class StrategyB { int compute()}class StrategyC { int compute()}SolutionContext o--&gt; IStrategyIStrategy &lt;|-- StrategyAIStrategy &lt;|-- StrategyBIStrategy &lt;|-- StrategyC@enduml 1234567891011121314151617181920212223@startuml stateclass TCPConnectionContext { TCPState state void request()}interface TCPState { handle()}class TCPEstablished { handle()}class TCPListen { handle()}class TCPClosed { handle()}TCPConnectionContext o--&gt; TCPStateTCPState &lt;|-- TCPEstablishedTCPState &lt;|-- TCPListenTCPState &lt;|-- TCPClosed@enduml 123456789101112131415161718192021222324252627282930313233343536373839@startuml abstract-factoryclass Clientabstract class AbstractFactory { createProductA() createProductB()}class Factory1 { createProductA() createProductB()}class Factory2 { createProductA() createProductB()}abstract class AbstractProductAabstract class AbstractProductBclass ProductA1class ProductB1class ProductA2class ProductB2ProductA1 -u-|&gt; AbstractProductAProductA2 -u-|&gt; AbstractProductAProductB1 -u-|&gt; AbstractProductBProductB2 -u-|&gt; AbstractProductBFactory1 -u-|&gt; AbstractFactoryFactory2 -u-|&gt; AbstractFactoryFactory1 ...&gt; ProductA1Factory1 ...&gt; ProductB1Factory2 ...&gt; ProductA2Factory2 ...&gt; ProductB2Client --&gt; AbstractProductA : createsClient --&gt; AbstractProductB : createsClient --&gt; AbstractFactory : holds@enduml :memento12345678910111213141516171819@startuml mementoclass Originator{ State state setMemento(Memento m) createMemento()}class Memento { State state}class Caretaker { Memento memento}Originator ..&gt; MementoCaretaker o--&gt; Memento@enduml :observer1234567891011121314151617181920212223242526@startuml observerclass Observer { update()}class ConcreteObserver { observerState update()}class Subject { attach(Observer) detach(Observer) notify()}class ConcreteSubject { subjectState getState() setState()}ConcreteObserver --|&gt; ObserverConcreteSubject --|&gt; SubjectSubject o-- ObserverConcreteSubject --o ConcreteObserver@enduml : adapter123456789101112131415161718@startuml adapterclass Contextclass Target { request()}class Adapter { request()}class Adaptee { specificRequest()}Context --&gt; TargetAdapter --|&gt; TargetAdapter --&gt; Adaptee@enduml : bridge123456789101112@startuml bridgePhone o-- PhoneFunctioniPhone --|&gt; PhoneAndroidPhone --|&gt; PhoneNonsmartPhone --|&gt; PhoneCall --|&gt; PhoneFunctionInstallApp --|&gt; PhoneFunction@enduml : command123456789@startuml commandClient ..&gt; InvokerClient ..&gt; ReceiverInvoker o-- CommandConcreteCommand --|&gt; CommandConcreteCommand *-- Receiver@enduml : chain-of-responsibility1234567891011121314151617@startuml chain-of-responsibilitytogether { class Client class Handler}together { class ConcreteHandler1 class ConcreteHandler2}Client --&gt; HandlerConcreteHandler1 --|&gt; HandlerConcreteHandler2 --|&gt; HandlerConcreteHandler2 o--&gt; Handler@enduml : mediator1234567891011@startuml mediatorMediator &lt;--o ColleagueConcreteColleague1 --|&gt; ColleagueConcreteColleague2 --|&gt; ColleagueConcreteMediator --|&gt; MediatorConcreteMediator --&gt; ConcreteColleague1ConcreteMediator --&gt; ConcreteColleague2@enduml : visitor1234567891011121314151617@startuml visitorclass Visitor { +visitElementA(ElementA elementA) +visitElementB(ElementB elementB)}note top of Visitor : Visitor design enables us to redefine the action/operation on a object without a change to its values.class Element { + accept(Visitor visitor)}ElementA --|&gt; ElementElementB --|&gt; Element@enduml : facade12345678910@startuml facadeClient --&gt; Facadepackage SubSystem{ Facade --&gt; SubSystemA Facade --&gt; SubSystemB Facade --&gt; SubSystemC Facade --&gt; SubSystemD}@enduml : proxy123456789101112@startuml proxyclass Subject { request()}Proxy --|&gt; SubjectRealSubject --|&gt; SubjectProxy --&gt; RealSubject@enduml : decorator123456789101112131415161718192021@startuml decoratorclass Subject { operate()}Decorator --|&gt; SubjectRealSubject --|&gt; SubjectDecorator o--&gt; SubjectConcreteDecoratorA --|&gt; DecoratorConcreteDecoratorB --|&gt; Decoratorclass ConcreteDecoratorA { -addedState}class ConcreteDecoratorA { -addedBehavior}@enduml : interpreter12345678910111213@startuml interpreterabstract Expression { +interpret(Context context)}Client --&gt; ContextClient --&gt; ExpressionTerminalExpression --|&gt; ExpressionNonterminalExpression --|&gt; ExpressionNonterminalExpression o--&gt; Expression@enduml","link":"/images/UML/design-patterns.html"}]}