{"posts":[{"title":"漫谈技术人的35岁危机","text":"未雨绸缪，人无远虑必有近忧。 从经济学和行业的角度看。 从产业链的角度看。软件也是商品。这个商品的上下游供应链是怎么样的？ 互联网的商业模式和产业链？ 为什么有的行业没有35岁危机？或者说什么样的行业可以没有35岁危机？ 是否在软件行业、互联网行业真的存在35岁危机？搜一下相关的论文，行业调研。 是媒体炒作的结果。 核心是不可替代价值。你的职场中的核心竞争力是什么？ 为微观视角出发，这个问题可能会比较焦虑。 思考这一点对我们的职业发展大有裨益。 添砖加瓦，创造价值。站在巨人的肩膀上，然后成为别人的巨人。“来吧，站在我的肩膀上，你可以一览众山” 雪崩将在山的某一高度爆发。攀登者们在奋力上爬，他们知道雪崩即将发生，但并不知道在什么高度，什么时候到来，他们能做的只有奋力向上爬。","link":"/2023/02/26/life/35-crisis-analysis/"},{"title":"写在三十岁的年尾","text":"2020是对于世界是魔幻的一年，对于整个人类历史也是天翻地覆的一年。甚至有文称之为庚子凶年。 对于我个人来讲，2020也是永生难忘的一年。实话讲，其实这几年都挺永生难忘的。2016年后，我的人生就开始加速，浓缩酸甜苦辣释放出来，来不及回首就轻舟已过。我有点希望这节奏能慢下来。 此时的我在做什么呢？工作、生活（吃喝拉撒睡亲朋好友社交）和带娃，余下的时间，还要娱乐，还要锻炼，投资健康，此外还剩多少时间？ 所以，下面开始谈，现实点，没多少时间留给自我提升了，就这样吧，人到中年，随遇而安，皆是如此。要这样吗？这可不太像我。 自我提升是不变的人生主题，创造价值是始终的追求，这与当下的时间与精力没有太多关联。眼下忙，就忙过了再说。精力不足，就充分休息。一旦回过神，就重操旧业。 得益于微软的工作，业余时间还是比较可观的，只要work smart，就不至于让自己陷入工作量泥潭。生活按部就班，规律作息，合理安排，不会侵占大块时间。带娃上做足准备，资金到位，影响也没那么恐怖。娱乐点到即止。健康定期投入，养成好习惯，融入生活。 但是不管如何优化，中年之后最大的问题是，大块的专注时间变得弥足珍贵，这点无法改变。所以学习深度的东西变得很难。 大部分人在二三十岁上就死去了，因为过了这个年龄，他们只是自己的影子，此后的余生则是在模仿自己中度过，日复一日，更机械，更装腔作势地重复他们在有生之年的所作所为，所思所想，所爱所恨。—— 罗曼罗兰 《约翰·克里斯多夫》 概括的讲，这个问题需要两方面来解决：一是对于艰深的内容，要充分利用宝贵的大块时间来突破和学习；而是要学会化整为零和化零为整，设定目标来管理自己，不忘初心，牢记使命。 深度内容一旦突破，再进行博学，必定会有触类旁通之感。原理既通，无妨大显身手。","link":"/2020/12/31/life/30-year-old/"},{"title":"管理和领导的实践心得","text":"​2021年中我荣幸担任了微软技术经理一职，开启了职业生涯的一个新的篇章。这让我经历了一段时间的职业过渡时期，一度很比较困惑，但也正是这样的过程让我获得了很大成长。我开始重新审视人生的核心能力，认识社交和识人用人的重要性，所谓纸上得来终觉浅，绝知此事要躬行。直到我面临和解决了一些管理上的真实问题，例如人才流失、项目进展缓慢，才能够意识到沟通、情绪等人际环节的重要，以及其中有哪些要点。 搞定人是一个难题。搞定微软的聪明人，是这个问题的一个子问题。了解一个人，了解他的aspiration（愿景、愿望），了解他的价值观，借助他的品质和偏好去与他进行有效的沟通，从而提升整个团队的效率，是一个富有挑战的命题。从个人到组织，如何发掘最大的效用，这里既有一些非常高屋建瓴的理论，也有非常有趣的细节。 我的领导告诉我，人与人相处，岁月流逝，最后沉淀下来的都是点滴片段和整体印象，没有人或细数功过；但是温情或肃杀的瞬间却能够铭刻于心。所以沟通的态度很重要，要尽量留下好的、正面的印象。具体来讲，如何指出对方的不足，但却让对方心领神会，衷心感恩，扭转局面，获得成功，最后皆大欢喜？ 这的确称得上是一门艺术。 不过我觉得，这其中的精髓，或者终极的秘诀，在于要有一颗温暖的心。这并不如此四个字看来这么简单，这意味着无论经历怎样的挫折，都不轻易气馁：几瓢冰水浇上去，这心仍是温暖的，不耀眼，不灼人，却在不断散发着光和热。这是何等的境界。 说到这里，这些文字仿佛上身了一丝文艺和狗血的气息。 言归正传谈管理，回归到技巧层面，管理的实践中肯定是有许多方法论可以应用或说套用的。不同的管理人有不同的风格，我和微软的一些经理谈论，吸取经验，听取他们的故事和思索，发现他们每个人的气场和风格都不太一样。 有一位经理虽身在外企（即微软）混迹十数年，却特别喜欢研究和讨论中国古代官场的故事，比如万历十五年之类的，我问他老外的环境里，中国那些厚黑学之类的看起来乌烟瘴气的东西也适用吗，他说人都是一样的，只是在西方文明里的表现形式不同，老外当然没有中国特色的酒桌文化，但是权力斗争和倾轧道理是一样的。他的箴言是“什么是权力，权力就是搞定事情的能力”。 无独有偶，我最近看Maxwell的领导力21法则，里面也提到，“人们经常对领导力产生误解。如果某人有个很响亮的头衔或者被任命某个领导职位，人们就会想当然地认为那个人就是领导者…真正的领导力来自一个人的影响力，而影响力是无法被委任的…”，“管理者就是领导者，是一种误解。” 还有一位经理，我和他说某某某员工能力太差，打算开掉，他说，其实如果你的团队如果个个都很能干，你会很难做；有一两个一看就不太行的，也许也是好事。有能力差的，一方面团队绩效上好划分，同时也给经理更多存在的价值和故事素材。 我的老爸表示，领导的品行很重要，做事要三思有没有上行下效的风险。要善于培养良性环境，看清团队内外的势与利，防止互相倾轧，拉帮结派。要了解团队人的长短，知人善任，然后借力打力。 东方人的哲学充满了浪漫和艺术气息，讲求各种权衡、中庸。西方人则更讲求逻辑缜密，格物致知，实践出真知。我最近参加微软的经理培训：Situational leadership，情境化领导，就把领导和管理的风格分成几类，然后把情景和被管理的人也分成几类，然后不同情况下采取不同的管理风格和策略，力求可套用，可实践。 比如这个理念把领导分为四个层次：辅导(Directing)，教练(Coaching)，支持(Supporting)，托付(Delegating)。如果被领导者处于D1 层次，也就是这个人还在知识、能力和经验等层面有很多欠缺，那么对应的领导风格就是辅导，需要很多事需要手把手的教授，经常给出反馈。如果这个人能力和知识没问题，属于D2，那就教练，多多问问题，多多启发他/她，不要急于给出正确答案。如果是D3，已经能够独当一面，但是还没有很强的沟通和领导能力，则需要多多支持他/她，帮助他/她讲故事和推销他做的事情。如果是D4，这个人各方面都很成熟，那就多多给他/她表现机会，多给他/她事情做。 当然情景化领导力这个课程还有很多丰富的内容，课上导师会有很多互动和实例沟通帮助大家加深理解，比较有趣。 总归来讲，管理和领导的问题是和解决具体问题截然不同的事情，思考方式有所区别。理性和感性都要兼顾。","link":"/2022/02/16/leadership/leadership-practice/"},{"title":"所谓艺术","text":"艺术的内涵和外延并无定论。没人说得清艺术到底是什么。 艺术的形式非常多，诗歌文章可以是艺术，摄影绘画也是艺术。视觉艺术的三个经典分支是绘画、雕塑和建筑，戏剧、舞蹈和其他表演艺术，以及文学、音乐、电影和其他媒体。 现在电子游戏也被认为是一种艺术表现形式。 下面这幅图所示的是1917年法国艺术家马塞尔杜尚的作品《泉》。 那是一个下午 ，杜尚和他的朋友走进了专事生产卫浴设施的J. L. 莫特铁工坊，他们憋着笑在里面寻找着什么，最终买下了一个普通的白底白瓷小便器——周到的店员还告诉他们这件方便工具产自英国贝德福德郡。 杜尚把它带回工作室，从原本正常的使用位置重新翻转了90度，使它看起来像倒置在那里的。然后在水管接头方向的右侧用黑漆属上“R. Mutt 1917”的笔名，为这件作品起了“泉”这个名字。 这东西真的掀起了一阵风浪。 理事会对于“Mutt先生”提交的这件作品是否是艺术品展开了长时间的讨论。 最终，这件大家并不知道是杜尚故意提交的、被视为玩笑的作品被放置在展览会场展墙后方，并没有正式展出。 杜尚为抗议独立艺术家协会理事会主张不一致，认为其无法公正的审视《泉》而决定退出理事会。 此刻，我们也凝视着《泉》，无数艺术爱好者也在美术馆里伸长脖子对它看了又看。可是，我们再怎么看——它真的只是一个爆款小便池。 你是否会心生疑惑： “什么是艺术？” 《泉》是马塞尔·杜尚“现成物”中最知名的作品。他通常选用常见的日用品，将其转化为艺术品。这个过程中，艺术家的角色便是赋予物品意义。 杜尚的现成理论有三个重点： 1.对象的选择本身也是一种创造性行为； 2.通过取消对象的“有用”功能它就变成了艺术； 3.对象的呈现和添加标题赋予它“新思想”。 2004年12月，500位英国艺术界的艺术家、艺术史学者将杜尚的《泉》票选为20世纪最具影响力的艺术作品。 它直接引发我们思考这些问题：制作技法是否是艺术品必须的？艺术家是制作者还是选择者？艺术品与艺术家的关系是什么样的？甚至——什么是艺术？ 可以看到，现成物对传统理解的“攻击”，不仅是艺术的地位，而且指向了本质。 中国人习惯讲，艺术源于生活，高于生活。那么中间的分界线到底在哪里？如果难有定论，就会争执不休。 但是我觉得留下一个开放的命题，好处在于让创造力有无限的空间。我们不应该过多执着于形式，而应该思考作品能否引发思考，产生社会共鸣和影响力价值。 文字艺术里，华丽的诗篇是艺术，写风土人情的也是艺术。 影视艺术里，拍鸟语花香是艺术，拍残酷战争也是艺术。 如果说艺术是某种恰当的提炼和概况，某种极致的表达，那艺术就是客观的，不需要迎合谁。 没有人不懂艺术，因为艺术在每个人心中。艺术本就是源于人的，但艺术无需讨好人。主观的动机，客观的存在。","link":"/2022/02/26/life/art-definition/"},{"title":"当爹记","text":"当爹第十天记我的宝宝降生已经十天。感受里杂糅着对他的无限的爱与对未来的憧憬、忧心，五味杂陈。 我和我的家人距离无欲则刚的状态，肯定是越来越远了。宝贵而幼小的生命的到来，给生活加了一剂甜辣。 昨晚八点多就睡了，一觉睡了很久，醒来觉得略微不可思议。宝妈却很辛苦，断断续续地起来喂奶，她已经很久没有尝过踏实安稳的长觉了。 成长的惊喜是对父母最大的慰藉，新生儿新生的第一个月里，快速成长，每天都能看见些许变化，小手一伸，小腿一蹬，眉目渐开，甚是喜人。老父亲露出了肉麻的笑容。 心中默念，我只能变得更加强大。 宝宝两月记宝宝很可爱，却也很磨人。吃奶拍嗝玩耍换尿布洗屁股，擦脸抚触哄睡练翻身排胀气。 每天都在成长，每天都在变化，乐趣无限又惊喜重重。 宝妈更辛苦，宝宝身体茁成长，体重追赶十三五，入手沉甸甸、肉乎乎，手舞足蹈，眉飞星目。夜半长歌唤奶喝，入梦金浆包屁股。","link":"/2021/02/01/life/baby-daddy-diary/"},{"title":"北京的一年四季12个月份的气温和景观","text":"每年北京冬天时候，总是期盼着春天快点到来。北京的春天很难盼，从历史和往年经验上看，北京的春天在春节之后还需要翻越三座大山，才能变得舒适宜人：长达一个月以上的料峭春寒、三月底四月初的沙尘暴、四月中旬开始的杨柳絮纷飞。本文仅此记录北京一年四季的自然和城市景观，希望帮助了解北京各个月份的气候和植被概况。 各月份均温和天气统计数据 1月 景观 植被 穿衣 冰天雪地 枯树 羽绒服 北国风光，千里冰封，万里雪飘。 2月 景观 植被 穿衣 数九将尽 枯树 羽绒服 3月 景观 植被 穿衣 春寒料峭 吐翠 羽绒服 4月 景观 植被 穿衣 芳菲乍现 花枝招展 棉衣、风衣 5月 景观 植被 穿衣 开始露营 绿树繁花 长袖短袖 6月 景观 植被 穿衣 万物繁荣 草长莺飞 短袖 7月 景观 植被 穿衣 炎炎夏日 枝繁叶茂 短袖短裤 8月 景观 植被 穿衣 盛夏时节 莲叶田田 恨不得裸奔 9月 景观 植被 穿衣 天高云淡 绿意依旧 短袖长裤 10月 景观 植被 穿衣 冰天雪地 金秋意浓 长袖长裤 11月 景观 植被 穿衣 冰天雪地 焜黄华叶层层多彩 棉服厚裤 12月 景观 植被 穿衣 天寒地冻 枯树 羽绒服 背景音乐：京城四季。","link":"/2023/02/22/life/beijing-4-seasons/"},{"title":"减肥：从心开始","text":"减肥难吗，很难。减肥简单吗？控制一个数字而已。 我近期减肥，初见成效，深刻地领悟到一点，减肥需要从心态开始。身体上的肥一定是从心理上的“肥”开始的。 减肥要科学节食，严格控制摄入。然而，包括我在内的很多人都认同：民以食为天，吃是人生一大乐趣。我特别爱吃肉酱豌杂面，每次路过川味小面的招牌的时候都忍不住慢下脚步。这就是心之肥。 总觉得控制饮食是委屈自己，减肥是很难进行的。 一次次半途而废后，我渐渐意识到，我错在把减肥变成了战斗，变成了苦刑。 也许减肥可以只不过是一种生活习惯，是一种暂时人生策略或者行为模式的调整。我的很多同事朋友吃的就是比较少，运动比较多，人也苗条，他们自己没有觉得自己在减肥，可是在我看来，他们就是在减肥了。所以减肥这个词，本身就有冠冕堂皇和商业化的味道。 与其说，减肥是在与饥饿、馋嘴和运动的惰性作斗争，不如轻描淡写一点：人生除了吃之外还有很多有趣的事。想办法降低自己的食欲，从其他方面提高自己的人生获得感。 可以去培养更多的健康的生活习惯，转移注意力；调整饮食结构，减少糖、碳水化合物和脂肪的摄入，增加膳食纤维、蛋白质和必要维生素的摄入；运动方面，可以选择轻松可持续的类型（走路）。 心之肥一旦去除，从心底认同了科学健康的生活习惯，那么身体的减肥也就是时间问题。 针对地讲，一日三餐要规律进行，调整饮食结构，只求营养全面，不饿就好。三餐之外不想食物的问题。要认同营养科学，奉行少糖少油脂少碳水。 对于食欲和馋，适当为自己洗脑：食欲的满足并不重要，和人生幸福无关；从运动中获取满足感和舒适感；让自己适当忙碌，健康作息。 运动可以逐步加量，注意培养对运动的喜爱，放大运动带来的快感。 身心减肥=科学健康生活+缩减食欲+快乐运动 为自己打造正反馈系统和良性循环，开头略有难度，但是一旦坚持一周，看到成果，后面也就水到渠成。三月之后，成效斐然，自然可以稍微关注美食；但彼时食欲已经减弱，胃口也没那么大了，对于美食的摄取由大快朵颐过渡为浅尝品鉴，控制体重和健康也就没有那么难如登天了。 以上理论，我的具体实践大致如此： 不再观看一切美食相关的媒体，眼不见为净； 三餐只有早餐摄入碳水化合物，午餐和晚餐不摄入任何米面细粮，极少量摄入脂肪（一天内小于20g），适当摄入蛋白质（一天小于200g）； 采购鸡胸肉熟食作为代餐，饿了就吃一块（75g）；采购代餐产品作为选项； 周一三五中午设置闹钟去公司健身房运动半小时，以6km/h时速快步走为主（坡度10°），每日上下班走至少1.5公里； 周六日可以吃两餐非减肥餐，吃八分饱（吃到不饿）； 食品采购上，少量优质，绝不能让剩饭成为负担； 每日记录体重，如果与前日持平则适当反思； 忙碌一些，多多为自己预约一些和吃饭无关的社交活动（参加演讲社团），打打游戏，学习人工智能，和儿子媳妇学英语等等。 目前成效：坚持了三周，体重由82.5到77.8。计划是体重达到74kg可以终止。 人生除了吃以外有太多事情可做。相比之下，德国人和美国人对吃没那么在意，所以他们的餐饮主要是快餐，而正经餐厅多是中餐、法餐、意大利餐或者墨西哥餐。这可能也是美德科技发达的原因所在吧！他们好像在说，我负责去追逐星辰大海，你们负责做菜。","link":"/2021/12/26/life/diet/"},{"title":"未来简史读后感","text":"总评：干货满满槽点多多不絮叨不抒情 元旦期间听了罗辑思维的跨年演讲，罗胖在节目中推荐了一本书，叫未来简史，说是刚刚译著的国内独家版本，并把这本书吹说的比较玄乎，说是回答了未来社会走向何方的问题。当时我还以为又是一本预言未来的书籍，并没有特别大的兴趣。仅仅是听了跨年演讲比较兴奋，加上想到听了罗胖两年多的节目，一分钱没掏过，索性就扫码拍了。这难道就是传说中的社群经济？我终于还是掏了腰包。 收到书已经是临近春节期间了，读完书的序章，饶有兴趣，就趁着春节得闲一口气读完了，从而完成了2017书单的一小部分，达成了零的突破。 读完全书，应该说是很有收获的，简单谈谈感想。 这本书并不是大放厥词的愚蠢的预测类书籍。相反地，本书更多地在谈历史和现实，只是很多观点非常新颖前卫。我读完第一章，最深刻的印象是，作者的角度和立场都比较冷静客观，能够非常中立纯粹地看待问题，所以他的分析也就给人以不偏不倚、劈头盖脸的感觉，独立且毫不迎合，有着层层递进的严谨逻辑。比如作者谈人类与动物的区别时，并不赖于任何现成的理论，而是完全跳脱的角度，把相关的学说和实验例子摆出来看，没有任何对人类崇拜或是鄙夷、对动物悲悯或冷酷的无聊情怀：谈论国家福利、战争和恐怖主义，完全从现实利益出发，往往略带黑色幽默的味道，比如说到911，作者将其比作“苍蝇钻到大象的耳朵里，力图把世界拉回’丛林法则’状态”的行动；谈及幸福快乐与伟大神圣的爱情，毁三观地说那些只不过是生物化学、脑中的电信号刺激而已；又提出生物就是算法，个体的人也不过是数据的处理单元。这很合我的胃口：脑洞足够大且没有絮絮叨叨的抒情说教。 书中最令我印象深刻的、同时也贯穿全书的一条逻辑脉络谈到，人类与动物最大的不同，不是工具的使用或者语言的发明，而是人类整体善于运用想象力为世界赋予意义，并基于这个共同的虚构意义框架下开展大规模组织合作，比如国家、货币和宗教的神；这些虚构的共同的想象“实体”，让我们能够开展大范围的人类活动，比如国际贸易、跨国公司和十字军东征；并且作者认为，宗教，作为评判标准和人类意义的源头，和科学一起都在推动人类向前；人类过去的意义源头，曾经是多神宗教、单一神宗教的有神论，而今天的世界主流宗教其实是人文主义，即强调自由意志和人本思想的价值体系；而随着近年来科学的快速发展，作者提出人文主义马上会站不住脚，因为科学发现，其实人的自我意识是分裂的（包括体验自我和叙事自我），而意志和感觉也不过是可以生产的产品，所以人本之心作为世界核心的观点会渐渐地站不住脚；人类需要一个新的宗教，关于未来的信仰，作者提出了两种可能，技术人文主义和数据主义。作者正是通过这条脉络，从历史一直探讨到未来。 据我目测，这本书有四分之三的章节都在谈过去的历史和当今的现实，也就是说作者充分考察了人类历史后，才试图对未来简作描述，这些描述也就相对务虚和靠谱一些，真实具体的未来当然是无法预测的。 书的结尾，作者阐述的数据主义的观点可作为全书的点睛之笔，这也是我看到的全书最大的脑洞。这种数据主义思想认为，在我们的世界中，人和神都不重要，宇宙的核心其实是数据，数据的“天性”是分享和传播，数据为了实现这个目的，借助人这个“工具”，数据把人当做处理单元和传播节点，让自己传播出去，整个世界的运作不过是为了实现万物互联的高效数据处理系统…这观点脑洞够大！但是仔细一想，这个数据主义还真没准是未来最靠谱的宗教。实际上，这个宗教现在已经开始快速蔓延了。作者还提出，美国黑客艾伦施瓦茨已经是这个宗教的第一个殉道者了（可自行百度此人）。至少在互联网行业里，分享、共享、记录和传播数据，让算法结合大数据分析人的需求，并不断的把人的行为数据化，基于这些理念诞生了大量的公司和商业盈利模式。如果说这就是未来新的宗教或者价值体系的话，可并不是说这是某种新的可有可无的想法思潮，而是说，不具备、不接受这种思想认识的人，将在未来被时代淘汰掉。 总之，这本书还是比较刷新三观的，书中还有许多论证和探讨以及金句，无法一一分享，推荐大家自己去读读。 这本书对我的比较重要的启发是：其一，想象力很重要，讲故事的能力很重要，谈吐和忽悠很重要，人类太需要意义和故事了，最高层次的营销是信仰和思想的营销，可参见电影盗梦空间（Inception）；其二，人工智能很快会洗刷各行各业，要努力形成不可替代的优势；其三，不要太在意隐私，分享和传播是数据时代的大方向，赶紧参与到分享信息和知识的互联网中来，占个坑位吧，并力图放大自己的节点价值。","link":"/2016/11/18/read/brief-history-of-future/"},{"title":"领导力21法则读书笔记","text":"追随这些法则，人们就会追随你。 The 21 irrefutable laws of leadership, follow them and people will follow you. 书评优点:很多观点切中要害，非常实际、实用和恳切。启发性很强。理论和概念的拔升和抽象到了一定的高度，很有水平。 作者对事物有很强的概括和梳理能力。对领导力的思索很深刻。 有很多例子和故事来辅助理解。例子都很贴切，也很有趣。 缺点有些观点对于领导者太卷了，容易把人吓跑。21条，数量太多了，容易让人抓不住重点。有些观点不够与时俱进，笔者似乎对于科技的进步不够重视。有些说法比较绝对。 书籍脉络 盖子 Lid 个人和组织的办事效力与领导力成正比 人际交往能力 规划能力和战略思维 远见 业绩 麦当劳例子 接管和改善一个组织：培训所有员工，解雇原来的领导者 影响力 Influence 如果没有影响力，你永远不可能领导别人 特蕾莎例子：真正的领导者发言时人们会洗耳恭听 关于领导力的五大误解 管理者就是领导者 企业家就是领导者 知识渊博的人就是领导者 引领潮流的人就是领导者 位高权重的人就是领导者 衡量领导力的尺度只能是影响力 知识 直觉 经验 过去的成就 能力 过程 Process 领导力的提升需要日积月累，而非一日之功 领导者都是善于学习之人 不知道你不知道 知道自己需要知道 知道自己不知道 我知道，我成长，我发现 因为我知道 阶段五：你拥有高度的直觉 实干家罗斯福：做了673场演讲，全国各地旅行20000英里 导航 Navigation 任何人都可以掌舵，唯有领导者才能设定航线 看得比别人多，看得比别人远，在别人看到之前看到 过去的经验 做承诺前或考察各种情况 多听从他人意见 PLAN AHEAD Predetermine a course of action Lay out your goals Adjust your priorities Notify key personnel Allow time for acceptance Head into action Explore problems Always point to the success Daily review your plan 一个成功方案的最大阻碍 对改革的恐惧、未知 对未来的不确定 想象力的缺乏 增值 Addition 提升价值，增加利润 辛内加尔领导Costco的例子 如果想独领风骚，那你就得不到员工的忠心 如果不能把功能让给别人（把失败的责任留给自己），那你就无法激励别人，最终只能自毁前程 拥有正确的领导动机 领导者要服务他人，提升他人的价值 你让你的追随者改善生活了吗？ 根基 Solid Ground 信任是领导力的根基所在 品格 彰显一贯性、潜力和赢得尊重 尊重 Respect 人们愿意追随比自己强的领导者 一个人的领导力越强，就能越快发现别人的领导力潜质，或者发现别人领导力的不足 获得尊敬的条件 领导能力 对他人的尊重 勇气 过去的佳绩 忠诚度 为他人增加价值 直觉 Intuition 每个人都在自己擅长的领域富有直觉 妻子玛格丽特对着装的直觉 吸引力 Magnetism 你只能吸引和你相似的人 你所吸引的人不是由你的愿望决定的，而是由你的为人决定的 如果你觉得你所吸引的人应该更优秀，那就到了你应该提高自己能力的时候了 亲和力 Connection 得人心者得天下 与人交往方面，感情要先于理智 我们都希望演讲者的讲话更有人情味 与个人亲善 展现真我 我的个性是什么：优点和缺点？ 能力？最大资本和不足？ 坦率真诚 了解对象 身体力行 身临其境 关注他们，而不是你自己 信任他人 指明方向，带来希望 在着手工作之前，先联络感情： 优秀的领导都是人际关系大师 核心圈 Inner Circle 一个领导者的潜力，由最接近他的人决定 将谁划入核心圈 是否对其他人有很大的影响力 是否能给团队带来互补性的才能 在团队里是否担任要职 能否增加我团队的价值 给核心圈的其他成员带来积极的影响 鉴别 - 培养 - 吸收 不断提高你的核心圈素质 当你的直属人数超过7个人，不是每个人都能直接领导的时候，应该建立核心圈 授权 Empowerment 有安全感的领导者才会授权予人（例子：亨利福特，反例，不授权，坚持T型车，导致持续亏损，直至亨利二世接管） 谁才是老板？授权的障碍： 渴望工作上的安全感 抗拒改变 缺乏自我肯定 找到有能力的领导者并授权给他们 镜像 Picture 看到别人怎么做，大家也会怎么做（兄弟连电视剧对美国军队的影响） 领导者必须要成为梦想家，你的领导水平越高，你的工作就越多是关于预见未来可多事情 一定要实际：对愿景的有效示范是把镜像变成现实 领导者愿景的典范 下属总是在观察你的所作所为 教正确的事总比坐正确的事容易 领导者能给下属的最宝贵的东西就是一个好的榜样 接纳 Buy-In 人们先接纳领导者，然后接纳他描绘的愿景 领导者先于愿景：你就是信息 领导者和愿景：并非两者之中择一 当追随者不喜欢领导者及其愿景时，他会去找另一个领导者 当追随者喜欢领导者，却不喜欢其愿景时，他们愿意改变愿景 当追随者同时欣赏领导者及其目标时，他们会全力以赴 成功是以你是否有能力带领下属达到他们认同的目标来衡量的 制胜 Victory 领导者为他的团队找出一条制胜之路 丘吉尔绝不接受任何妥协 我们的目标是什么？用一句话回答，赢得胜利！不惜任何代价，不管面对多少恐怖，我们就是要打胜仗。不管这条路有多长、多难。不能获胜，就只有灭亡。 胜利的要素 统一的目标 多样化的技能 一位愿为胜利而献身、致力于发挥队员潜能的领导者 制胜是领导者的本分 动势 Big Mo 动势是领导者最好的朋友 皮克斯和玩具总动员，对比同时间迪士尼 当对方连续得分、动势越趋强大的时候，优秀的教练会立刻叫暂停。 一旦产生了动势，你就不会担心小问题。 如果没有了动势，就连最简单的任务也会变成登天难题。 动势是放大器 动势可以美化领导者 动势帮助下属们表现得更好 掌握动势的方向要比创造动势容易 动势是带动改变最有力的因素 创造动势是领导者的责任 动势从领导者自身产生 激励是创造动势的关键要素。 优先次序 Priorites 忙碌不一定等于成效 三R法则 Requirement 什么是你必须做的分内之事？ Return 什么能带来最大的收益？ Reward 什么能带来最大的回报？ 在所有活动中，只要集中注意最重要的那20%，你就能获得你付出努力80%的回报。 领导 Leadership 沟通 Communicating 创作 Creating 联络 Networking 杰克韦尔奇 快刀斩乱麻，集中力量：保留能占领世界第一或第二的生产线 舍得 Sacrifice 领导必须先舍后得 牺牲是领导力的精髓：成功的领导者懂得牺牲次要的东西 地位越高，舍弃越多 牺牲是一个持续的过程 时机 Timing 掌握时机与善用策略同样重要 时机决定一切 在错误的时机采取错误的行动，结果是酿成灾难 在错误的时机采取正确的行动，结果是抵制 认识：对局势有清楚的认识 成熟 信心：人们往往追随心里有谱的领导者 果断 经验 直觉 准备 在正确的时机采取错误的行动，结果是犯错 在正确的时机采取正确的形成，结果是成功 行动的目标？谁负责？市场、行业如何 爆炸性倍增 Explosive Growth 培养追随者，得到相加的效果；培养领导者，得到倍增的效果。 帮助别人领导 培养追随者的领导者： 发展最下层的20%； 专注于人的弱点； 一视同仁； 在一般人身上花费时间； 以加法方式成长 只影响到身边接触到的人。 培养领导者的领导者： 发展最优秀的20%。 专注于人的长处； 因人而异； 在人才上投资时间； 以乘法方式成长。 影响力扩及甚远。 培养领导者的挑战：领导者难觅、难聚、难留 如果你一直为你手下的领导者提升价值，他们就会愿意一直追随你。 阶段：提高自己》发展团队》培养领导者 传承 Legacy 一个领导者的长久价值由其继承者决定 发展你的领导遗产 清楚自己希望留下的遗产 实现自己希望留下的遗产 挑选你事业的继承人 确保顺利传递交接棒 21 irrefutable laws of leadership - John Maxwell’s 21 leadership laws explained with examples - unremot.com","link":"/2022/09/18/read/21-leadership-laws/"},{"title":"AI学习感悟","text":"此文谈谈我在AI学习上遇到过的困难、这个领域学习的特殊性、近期的学习进展和学习方法小结以及学习感悟。 最近在学习人工智能方面的课程，并坚定信念，立志这次一定要攻克这个知识盲区，不可再知难而退，半途而废。 为什么这么说？原因是在几年间我已经多次发起对这一领域的冲击。众所周知，人工智能是当前的时代骄子，宏图无可限量，其含金量和无限生机不必多言。我也很早意识到了这一点，下决心要入门而后吃透。并且我也深信自己的学习能力，并准备好了专业自学攻克三板斧：找视频教程，倍速观看学习，再通过项目实战快速上手加深理解。 起初，我觉得区区人工智能/机器学习，不过是在自己的计算机学习领域里再添一瓦。待我稍作计划，为期一月，定当拿下。 然而一晃几年过去了，我依然在门外转悠。为何如此？简而言之，就是这个领域有着极高的门槛。 人工智能是一个综合性的学科，或者说根本不是一个学科，本就是一个庞大的跨越学术与实践的知识集合，其中涉及的数学，包罗大学本科的微积分概率论线性代数，也涵盖更高层次的凸优化、矩阵分析、信息论、图论等，更涉及到计算机领域的许多高阶算法。这里涉及的每个学科都有大量的晦涩抽象的数学概念。如果不具备扎实的数学功底，听老师讲课很快就会彻底迷失。举例来说，人工智能的入门课程中，老师一般会先介绍一些学习人工智能的意义、历史之类的比较水的知识；渐入主旨后，会突然抛出损失函数的抽象公式，紧接着噩梦开始，概念轰炸全面启动，什么凸集、梯度、Hessian矩阵、对偶问题接踵而至，等谈及基于这些概念之上的理论，比如支持向量机、随即森林、拟牛顿，大脑已经进入无暇应接的死机状态，索性眼一闭不睁开始酝酿睡眠。 既然理论学习不成，先进行实践应用，再反过来理解背后原理，可否？做个项目尝尝甜头，像玩游戏般慢慢摸索，可行？答案是基本行不通。人工智能的项目，或者说机器学习的项目，大多基于大量数据，项目运行起来也很抽象。从项目入参到结果之间的黑箱，如果不理解这其中的原理，可以说是极其复杂甚至深不见底的。 于是只能老老实实的从头学习，把不明所以的概念统统搞定，那么就有漫漫长路要走。问题来了，这个学科需要的知识积累，大都需要投入大量的连续时间。因为难度较大，需要专注和持续，三天打鱼两天晒网，断断续续，一定是不行的，断了不一定能续上。这对于上班族来说，就格外困难：试想这星期好好学了一周，下周突然诸事缠身，那么下下周再学习的时候，发现很多概念又要重新理解。时间推移，心态变化，难免最终放弃。 总而言之，这个领域的学习，靠我之前的三板斧，肯定是行不通了。要重新审视，严肃对待，思索度量。 如今，经过今年新一轮的努力，终于感觉自己有推开门扉，跨入厅堂的感觉，很多脉络逐渐打通，很多概念能够理解领悟。其中的原因总结起来，有如下几点： 一，学习动力：此事最为根本，之前单纯为了学习而学习，望梅止渴，难以持续数月。往往不够坚定，借口搪塞，心有不甘却力有不逮。今年参加了微软的AI School项目，并和领导朋友夸下海口，颇有背水一战的意思。 二，学习材料：借助各种知识和内容分享平台，寻求概念的多方解释，加强理解。有不懂的关键概念，一定先从其他内容平台听讲明白了，再回到主线教程上听讲。人工智能教程的前8节课，视频时长总计16小时，但我却足足学习了上百个小时，为了打好基础，我找来考研数学的教程，如获至宝。考研数学和AI数学基础有很大的重合部分，而考研数学老师很擅长理论结合题目以及实例对概念进行讲解，拨云见日。另外针对考研数学没有涉及的数学概念，我在Bilibili的内容平台上也找到各种老师的讲解。往往针对一个关键概念，会听2到3个老师各讲一遍，从而加深理解，突破重点。 三，时间安排：利用好宝贵的大块时间、高价值时间。比如，早上起床后的2小时，可谓是学习的黄金时间。低价值时间，如晚上下班后和比较零碎的时间，可以用来处理琐事和娱乐，不必拘泥全情投入。 四，学习方法：由整体到细节：先从整体上推进，然后带着问题对疑难点各个击破。形式上重拾笔纸，适当做些练习题加强巩固。另外和编程相结合，比如可以写一些矩阵计算、梯度下降的代码，加深对过程和概念的理解。适当读书作为参考，相互印证，加深印象。 不一而足，综合以上措施，这次的学习进展明显更加乐观了，而且形成了良性循环的正反馈系统，有了新的学习方法和综合方案，渐入佳境。 最后谈一谈学习的感悟和收获。经过对这个深入的综合学科的学习，我更加具象地了解到数学的现实意义。众多学科，万法归宗，数学是宗，源远流长。线性代数和矩阵代表了数学对现实世界的描述方式，看似抽象，实际很具体。而回归和优化问题代表了总结、判断和问题解决的数学解读，相互贯通。这些生涩的概念领域反而让数学与现实世界更加贴近。 这方面的学习经历也让我格外体会到，大学和研究生阶段学习的课程其实有非常重要的意义，人生也需要专门的时间进行更具深度的学习。中国大学教育和高等教育的失败和乱象完全不能说明高等教育学科知识的无意义。绝对不能盲从社会上极具迷惑性的反智思潮，要相信科学，相信学术，坚信知识的力量，立志做博学并学有所长（成）的人。 学海无涯，云帆初悬，长乐未央，且行且悟。 后记近来机器学习的持续进展，感觉这次真的可以有所突破了。这件事还是很值得努力的。 说起来，这个领域的门槛真的挺高，想想自己最近学的都是什么？什么泰勒、拉格朗日、凸优化、广义线性回归、共轭和对偶什么的，年近三十突然搞起这些，皓首穷经，反而年轻。 学习对我有非凡的意义，尤其是针对自己这种有点不可思议的跨界生涯。 而学习这种实践，也不完全不是一件多么崇高的事情，不要把他看的太严重了。 留心处处皆学问。重要的是，不要原地踏步，要积累和检验自己的学习成果，太随意肯定也不行。 善于学习之人，肯定不会脱离实际学成书呆子，也不会嘴尖皮厚腹中空，无所精进。 学而时习，学有所成。","link":"/2019/02/06/read/ai-learning/"},{"title":"大学时代写的未完结的小说 - 重生劫","text":"之前发的那个都说不给力，最近看了些营销学的东西，决定还是同样的故事，换个视角、时序，推翻了重写。写的更加直白一些，更刺激一点儿。 这就开始。 某年某月某日，烈日当空，赫然是旷野孤城的秦城监狱的高墙外，风猎猎的吹，黄沙漫漫的卷，渺无人烟。除此之外，一切还是静的让人窒息。 忽然监狱厚厚的大铁门无声无息的打开，同时，监狱内部轰鸣作响，先是一架武装直升机嗒嗒的飞升脱出监狱高墙，紧接着四辆装甲运输车，隆隆的开出监狱大门，呈一字队形，由直升机低空护送前行。 在装甲车内部，运送的是24名已经宣判死刑的重刑犯人，其中有17名男犯人，7名女犯人。 此时，他们作为国家最具重量级的囚犯，正在被押往行刑的路上。 在他们之中，有的曾是是职业杀手，有的是黑社会组织或邪教的头目，有的是巨额诈骗犯、贪污犯，或是众多刑事案件的幕后指使、策划。在这个单纯的国家，这曾是一股首先出现的高智商犯罪力量。为了逮捕他们，国家煞费心思，或是不得不出动大量武装力量，或是不得不修改法律、定罪莫须有，或是不得不从国际上花重金聘请高级刑侦人员、犯罪行为心理学家，甚至不惜牵动国际关系、请求国际支援。说他们个个凶神恶煞，杀人如麻，倒不一定，但说他们曾是罪魁祸首，心机狠辣，称其一时之罪恶之源，倒不夸张。 此时，他们中的大部分被注射了镇定剂，分开关押在装甲车舱室的隔离间内。装甲车上的特种兵包括司机都全副武装，为突发情况时刻待命。 如此戒备，或显夸张。如果这次只是一个重要犯人被处决，大可不必如此。在这个绝对不容许平民配枪的和谐国度，断不必担心有中国古装片里的大张旗鼓的劫法场的情况出现。但是同时运送24个皆可能在法外还存在巨大残余势力的犯人赴刑，就不得不顾虑这些势力的联合行动。明智稳妥与震慑起见，宁可夸张一点。 既然如此，当局为什么要秘而不宣地对24名重要犯人集中进行处决呢？ 这个问题先留着。 说着，装甲车已由旷野开进山林。执行死刑的场所并不固定，大多在人迹罕至的荒山谷中，行刑过程是绝对禁止平民观瞻的。根据国家法律规定，执行死刑一般采用枪决、注射两种方法，以减轻犯人痛苦的人道主义为原则，尽可能实现“安乐死”。这次，装甲车上预备了注射药物，军医随行，要对这24位魔头采用注射行刑。 既然是注射死刑，为什么还要将犯人带到野外行刑呢？这个问题车上的大部分士兵也无法回答，他们只是受到上级指令执行任务。当然，在领队的装甲车乘上有一位执行长官。 车队停在一处谷地中，林风阴凉，直升机继续在附近盘旋。 “报告长官，方圆一公里内无异常情况。”直升机飞行员用对讲机报告。 “收到。”长官同时下令道：“开始行刑！” 特种兵迅速行动，犯人每六个一组开始行刑。我国注射行刑过程主要分三次，第一次药剂注射起到麻醉大脑的作用，第二次注射药剂让全身肌肉放松，最后一次注射才让心脏停止跳动而致命。 这时，四位身着白大褂的军医从车舱内躬身走出，戴着口罩医帽。特种兵的迷彩队伍中，医生的白衣显得很乍眼。他们各提一个金属医药箱，准备进行最后一剂药物注射。 很快医生熟练地完成配药，开始平静地对一个个软瘫的身体进行静脉注射。 凉飕飕的林风拂动了白衣的衣摆，不知这些盈满罪孽的灵魂是否也乘风而去了。 行刑完毕几分钟后，两辆殡仪车缓缓驶来，负责护送的特种兵例行汇报完成任务，执行长官批准撤离后，直升机装甲车队就浩浩荡荡开离刑场。不大的空地上一下子少了许多人，只剩下几位军医、殡仪人员，还有这位长官。 这位长官一身戎装，身形高大，腰背笔挺，不动声色的站了一会儿，大概是估摸时间够了，命令殡仪人员开始向车上搬运犯人“遗体”。 搬运过程中，一位犯人的“遗体”腿部突然抽搐了一下，搬运的人并不为动容，仿佛在意料之中一样。 这位长官脸上也并无异色，却转而问站在身旁的军医。 “医生，他们的身体状况如何？” “报告长官，目前这24个人的身体状况一切正常。” “长官，刚才为犯人最后注射的是降低心率的苯妥胺，现在须进行心率恢复。”这名军医又说。 这位长官看“遗体”已经尽数抬上车，答道：“恩，你们现在去吧，让司机开车” 两辆殡仪车缓缓地驶出了山谷，车上原本挂着的黑色挽花、黄白花环已经全部卸下，现在俨然是一辆朴素的客运巴士，正向着市区行去。车内部，监护仪、麻醉机、呼吸机等医疗器械一应俱全，各自滴滴答答地做响着。穿白大褂的、穿黑色殡仪礼服的俱在车内熟练地忙碌着，24个本已应逝去的邪灵的呼吸声、心跳声一下比一下加强着，随着心电图上的波动由微弱到逐渐强劲，这些声音，带着重生一般的力量，似乎要盖过汽车运行的隆隆声，在旷野上发出了轰鸣。","link":"/2012/02/18/read/novel-without-ends/"},{"title":"如何阅读一本书","text":"近来读了不少不同类别的书，清偿了一些读书债；特别地，还翻了翻一本叫”How to read a book”的书，颇有感悟，总结为此文。 探讨如何读书之前，我们可能先需要回答，为什么要读书。一位中美洲的哲人说过：“HOW is never as important as WHY.” : ) 为什么要读书？时代发展到今天，我们有了丰富的媒介，可以接触到知识，我们通过图像可以学习，通过有声读物、视频也可以学到知识。我们可以阅读手机自媒体的文章，可以观看b站up主梳理好的视频教程，所谓世事洞明皆学问，人情练达即文章。显然，读书已不再是获取知识的唯一手段，我们还需要读书吗？ 起码有一点是非常清楚的，现在这个太平包容的时代，文盲也可以活得很好，读书不再是走向人生巅峰的必经之路。 高尔基说，书籍是人类进步的阶梯。那么既然谈到了阶梯，其中就暗含了一个概念，就是要向上。那么就又回到了刚才的问题，社会是多元的，多维度的，在这个纷繁复杂的世界当中，哪里是“上”？ 我们的世界和社会是由人组成的，这一点不会随着科技的发展时代的进步而发生巨大的变化，至少在可见的未来内，人依然是我们这个世界和社会的主体。而马克思说，人是社会关系的总和。所以人和社会之间存在着彼此依赖的关系。那么在这个由人组成的社会当中，哪里是“上”？ 也许我们可以这样说，群体的大多数就是“上”，时代和社会的主流就是“上”。而书籍就是群体智慧的结晶，书中反映了一个群体，或者一个社会在一个时代背景下的共识。当一个人决定用文字语言说清楚一件事，并能够形成一本书，而这本书在他的群体里又可以得到流传和认同，这本书就会成为这个社群的凝结核，帮助这个社群找到他们可以沟通的共同语言、术语和思考方式。 大到一个国家需要书，来实现国家作为想象的共同体的思想基础；小到一个技术论坛、圈子，需要书来写明他们的技术要点、实践操作指南、技术术语。 所以当我们身处一个群体的时候，我们需要书来帮助我们达成如下的层层递进的境界： 加入群体中的大多数，说话在“调”上； 跟随和预见未来群体的演进和发展，行动上“不跑调”； 成为先知领导这个群体，“定调”。 时代在不断变化，我们向上走，面对和拥抱不确定性，为未来做出准备。读书让我们理解社会、自然和社群，获得智慧结晶，掌握话语，进而掌握话语权。 居高声自远，非是藉秋风。何以居高？站在巨人的肩膀上发声。毛泽东同志常说：“我一生最大的爱好是读书。”“饭可以一日不吃，觉可以一日不睡，书不可以一日不读。”他认为，“有了学问，好比站在山上，可以看到很远很多东西。没有学问，如在暗沟里走路，摸索不着，那会苦煞人。” 如何读书？接上回，关于如何读书，毛主席也有评论：“读书，一要读，二要怀疑，三是提出不同的意见。不读不行，不读你不知道呀，凡是人都是学而知之，谁也不是生而知之啊。但光读不行，读了书而不敢怀疑，不敢提出不同看法，这本书算是白读了”。简而言之，读书要带着问题读，开卷时最好有一定的目的性。 我最近去了一趟国家图书馆，人类的书籍真可谓汗牛充栋，浩如烟海；读书真是学海无涯苦作舟。中国国家图书馆藏书包括各种文字的书籍报刊、历史文献、学术论文、金石拓片、音像制品、数字出版物等。截至2005年底达25,049,236册（件）；截至2007年底，馆藏文献达2631万册(件)；并以每年60－70万册的数目迅速增长。截至2015年底，馆藏文献已达3518.15万册(件)；藏书量居世界第五位。 这是一个知识和图书爆炸的时代。“都炸了”。更何况，人类的记忆容量有限，今天学明天忘，可能也是常有的。 我们需要探索新时代的读书法。但却不一定从新时代里得出结论，资治通鉴，孙权劝学： 权曰：“孤岂欲卿治经为博士邪？但当涉猎，见往事耳。卿言多务，孰若孤？孤常读书，自以为大有所益。”蒙乃始就学。 如果书太多，就先涉猎，翻翻过紧，快刀乱麻，达成目的就行。“How to read a book”一书中把读书分为几个层次： Elementary reading Inspectional reading Analytical reading Syntopical reading 书中还提到：“X-raying a book”，X光式的扫描一般的读书。所以，也许可以读读序言，读读目录，提纲挈领，翻看涉猎，能回答清楚和书相关的几个基本问题就算大功告成。爱因斯坦说：“If you can’t explain it simply, you don’t understand it well enough.” 总之，读书切忌拖拖拉拉，还不如快速翻翻书，涉猎一下，多读几本，然后试着去教学相长，这样读书也会很有成就感。当你这样读完后，行动起来却发现自己其实是一知半解，心中对书里的内容疑惑、好奇陡然升起，再去精读一点不迟。 毛泽东也谦虚的说：“我也如此，读书少，后来养成读书习惯，一拿就是历史、小说、笔记，这些较柔和。……要养成读书习惯，各种书都读，包括文学、历史、法学、心理学、李森科、摩尔根。”所以开卷有益，先开始读书，形成兴趣和成就，再谈持之以恒。 最后，祝大家读书愉快，从读书中收获人生的意义和成就感。","link":"/2022/10/31/read/how-to-read-book/"},{"title":"成长的边界：读书心得","text":"概览全书要点： 鼓励“不一致性”：美国挑战者号的例子。 过早专业化不一定100%可行。在人工智能的时代，人的核心价值是否在于高度的专业化？ 保持开放的心态。例：凡高生涯。 对于育儿：培养复合能力。（从上一个辅导班变成上3个辅导班？） 什么是现代化的文明：建立共识。智商：共识的加强。 对于软件工程师，提升创新力，只要是有利于自己提升和成长的，都可以保持开放的心态。 对于管理者和领导者，需要思考在团队中扮演什么样的角色。构建多元化和有包容性的团队。 局限性 例证和过度解读嫌疑。 作者何许人？David Epstein： David Epstein (journalist) - WikipediaDavid Epstein is an American journalist. He currently works at ProPublica. He is the author of two books, Range: Why Generalists Triumph in a Specialized World (2019) and The Sports Gene: Inside the Science of Extraordinary Athletic Performance (2013).Prior to ProPublica, Epstein was a senior writer at Sports Illustrated, where he specialized in science issues in sports and investigative reporting.[3] With his colleague Selena Roberts, Epstein broke the story that the Yankees’ Alex Rodriguez tested positive for steroids in 2003. 相关概要信息本书英文名： Range: Why generalists triumph in a specialized world Why specializing early doesn’t always mean career success | David Epstein - YouTube 通才在AI崛起的时代有巨大的意义。 未来社会趋势万变，我们需要把自己锻炼成瑞士军刀，用跨界不断拓展能力范围–成长再无边界，未来无尽可能。 全书结构： 引言：费德勒VS泰格伍兹 天才Tiger Woods 成长。 对一万小时定律的质疑。 晚一步专业化的好处，和过度专业化导致的危机（2008金融危机）。 赢在起跑线的教育狂潮 波尔加姐妹故事：国际象棋大师的记忆力。 这个世界不是打高尔夫球，也不是打网球。这个世界上的大部分都是“火星网球”，虽然你能看见选手们拿着网球和球拍出现在赛场上，但是没有人知道准确的规则。你可以推导规则，但是规则也会悄无声息的改变，当然也不会通知你。Kind learning environment and wicked learning environment。 香农（通过学习哲学）意识到自己可以把电话的路由技术和布尔的逻辑系统结合，任何形式的信息都可以用电子方式进行编码和传输。这一发现正式计算机赖以生存的基础。“这也是碰巧而已，因为没有其他人 同时对这两个领域都熟悉。”香农说。 抽象思维和概念推理 士兵的智力测试 结果的代际进步（James Flynn瑞文标准推理测验 Raven’s Progressive Matrices）。如今的年轻人被要求描述“黄昏”与“黎明”之间的相似之处。 现代化和集体主义。前现代人只见树木不见森林，现代化社会的人只见森林，不见树木。 能够广泛应用知识的能力来自涉猎广泛的训练。 可遇不可毁的创造力 figlie del coro, 唱诗班的女儿们，多种乐器专家。 马友友和虎妈。 爵士乐和五线谱：David Brubeck 天生对视，无法看清五线谱。姜哥烧伤 学习，快与慢 合意难度和间隔期。最好的学习之路“道阻且长”。不仅进度缓慢。而且在眼下也可能表现不佳。艾奥瓦州的测试实验，研究人员给三组人员念了同一组外文单词，第一组被要求马上背诵；第二组有15秒复习；第三组被要求做50秒的数学测试，没有时间复习。听完即刻复述的效果最好。但后面在测试完毕之后实验者被告知临时增加测试，第三组人员效果最好，因为第一次测试帮助他们把短期记忆转变成长期记忆。 广泛性的思考可以帮助我们远迁移，形成长期性的成果（长久而有效的、具备灵活性的知识）。 跳出经验外，思在新境中 开普勒的例子：运用类比的思维，“类比是我最忠实的大师，它熟悉大自然所有的秘密”。气味的散发和动力类比，漩涡和引力。。。 外部视角：投资人对项目评估的时候多多的找具有广义相似性的案例作为参考。 邓巴记录高产实验室的工作方式：坐下来讨论工作和实验中遇到的挑战。邓巴的研究项目中，只有一个实验室没有任何新发现，团队中的每个人都有着相似且高度专业化的背景，而类比几乎从未被使用。“这有点像股票市场，你需要一套综合策略”。 过于坚持，也有问题 凡高三天打鱼两天晒网，各种停滞不前。艺术学校，艺术品销售，教师助理（法语和数学），矿区布道，书店店员。 Match quality：一个人工作和其自身的匹配程度。野兽军营和多臂老虎机。 恒毅力和短期规划 发掘自身更多的可能。 赫塞尔本：女童子军的领队到三百万会员的女童子军组织首席执行官。赫塞尔本连大学都没毕业，但是她办公室里挂满了23个荣誉博士文凭，还有西点军校授予她的一把亮闪闪的军刀，还有总统自由勋章。 历史终结错觉：我们对于工作和生活的偏好不会一直不变。我们意识到自己的欲望和动机在过去的日子里有了大幅度的变化，但是我们又相信，这些欲望和动机在未来不会有太大变化。 局外人的优势 专家们创造的专业信息越多，好奇的涉猎者能 做出的贡献就越多，他们把广泛存在但是迥然不同的信息整合在一起，这就是那些未被发现的公共知识。人类知识的图书馆越庞大，越容易进入，好奇的读者就越有更多的机会在前沿建立联系。 用过时的技术横向思考 横井军平 （Gunpei Yokoi）：是否可以开发一个体积足够小的游戏机，这样上班族就可以在通勤时轻松打发时间？夏普和卡西欧的计算器大战。从技术角度看，即使在1989，Game Boy的技术都是非常可笑的。屏幕只有四阶灰度可选。人物快速移动式，屏幕显示就会有些模糊。英国女王看见自己的孙子在用Wii打保龄球，她决定亲自上阵。Nintendo switch 集大成，任天堂历代产品的DNA：体感、手柄设计、便携。连续性创新者：Π型人，横向思考的整合者。 被专家愚弄 人口爆炸。离谱的专家预测。 学着放下熟悉的工具 赛车决策：引擎可能存在问题，有失败风险。挑战者号O型圈被侵蚀。哥伦比亚号。 野外消防员不愿意放下背包。 同心圆管理，组织的结构不应该是阶梯式，而应该是由多个圆心组成。等级森严的组织 刻意的初学者 星期六早上的实验：Oliver Smithies, 研究胰岛素和胰岛素分子的分离；别把你的技术应用在老的地方。带上你的技术去解决新的问题，或者带着你的问题去学习全新的技术。 三无教授屠呦呦：没有中国科学院的院士资格，没有海外研究经历，也没有研究生的学历。 生物交叉学科的诺贝尔得主，Max Delbruck 的原则：有限马虎原则。要注意不能太小心了，不然你会不自觉的限制自己的探索。 创新的生态系统应保持广度和低效率。 结语：拓展你的广度学习 像米开朗基罗对待大理石的态度一样对待你自己的旅程和项目吧：愿意学习和改变，如果有需要的话，甚至可以放弃此前的目标，彻底的改变方向。 专业化本身没有任何错误。只不过专业化的程度和内容有所不同。 这是一次实验，因为所有的生命都是一次实验。最高法，奥利弗温德尔霍姆斯。","link":"/2022/02/17/read/range-reading/"},{"title":"Ah king&#39;s fight - the APPLY method","text":"OpeningGood day everyone, today the topic is Ah king’s fight. Does anyone know what’s the possible meaning of it? Let me explain more. In every toastmaster session, the one who used the most filler words, like ah, um, er, so, will be granted with this crown of the ah king. And although I claim to be the only stand up comedian on this stage, I had the luck to win this ah king title for quite a number of times. Lately I realize the ah king is a much safer role, compared to the stand up comedian role, at least you won’t get a big slap on the face by Will Smith, right? And Ah king is still a king, although we are not sure whether there will be a queen. But it’s still a king of the Ah kingdom with the Ah citizens, and the Ah counter. There is no timer king, no grammar king, but there is always an ah king for sure. Let’s stop the joking around. Seriously, cutting out the filler word is a truly challenging task. The filler words are like something rooted in your brain and unconsciously come out your mouth. It’s not something destructive, but it will distract your audience and makes your point pointless. So I start this fight against it, calling on everybody here to be tough on me for this and let whoever else to take take the throne. I have dived into some of the specialist’s guides/blogs on how to overcome it and summed up a methodology. I call it the APPLY methodology. APPLY, all capitalized and each letter is the initial of a key word. APPLYA stands for Awareness.Awareness: Filler Word AwarenessYou cannot correct a problem unless you know you have one. Filler words are invisible to the speaker, but not to the listener. As a speaker you need to acknowledge the issue and confront the verbal tics you have. We should leverage the power of our ah counter, who provides the free service of tracking down the overuse of it. And trust me, once you admit it and want a change, the change is underway. The second letter P represents Pause.Pause: Use Deliberate Pause (Embrace the Pause)Means to use deliberate pause as a replacement of the filler word.Most beginning speakers are afraid of pauses. Well, don’t be, try to embrace it. How about we embrace it now, as an experiment. A 10 seconds pause is absolutely better than 10 second errrrr. A pause is actually more impressive than a filler word. The silence can create suspense, demonstrate your confidence. It can be dramatic and even magical. The other P here stands for Preparation and Practice.Preparation: Get Prepared (Know Your Point)If you know your topic thoroughly and have rehearsed your speech, delivery in front of an audience will go more smoothly and you will be more confiden. To cut out filler words, it would be super helpful if you believe in the importance of what you are saying. Filler words generally come in when you don’t view the presentation as a conversation. So just get prepared and practice, know your point and make the point. And impromptu speech like the table topic sessions are great chances to practice as well. L is for Loud and Clear.Loud and Clear: Slow DownYou can try increase your volume and slow down the pace to make the point clear. This would give your brain the chance to organize the words into points. To insert the deliberate pauses also help with this. These are the effective countermeasures for a fast talker. Y is forYou can do it! Be confident!Have faith in your self, you can get rid of it. Find your positive circle and ramp up step by step. The number of fillers will go down and your confidence will go up. Apply it, develop the awareness, embrace the pause, prepare and practice, be loud and clear, and you can do it. You will find that it’s not something embedded in your genetic settings. All of us can be a great point-maker. That’s it, thank you!","link":"/2022/07/18/speech/ah-king-fight-apply/"},{"title":"15分钟入门23种设计模式：图解，范例和对比","text":"本文力图在15分钟内，通过UML图解、范例和类比，让你对面向对象的23种设计模式形成提纲挈领的认识，从而让我们在面临代码设计问题时更加成竹在胸。本文源代码： UML, Sample Code。 开门见山我们直奔主题，分类呈现23种设计模式的庐山真面目： 创建型 (5)Creational 结构型 (7)Structural 行为型 (11)Behavioral 工厂方法 Factory method抽象工厂 Abstract factory建造者 Builder原型 Prototype单例 SingleTon 适配器 Adapter桥接 Bridge组合 Composite装饰 Decorator外观 Facade享元 Flyweight代理 Proxy 责任链 Chain of responsibility命令 Command解释器 Interpreter迭代器 Iterator中介 Mediator备忘录 Memento观察者 Observer状态 State策略 Strategy模板方法 Template method访问者 Visitor 这23种设计模式源于GoF所著的”Design Patterns - Elements of Reusable Object-Oriented Software” 一书（也有将该书直接简称为GoF），译著为 “设计模式：可复用面向对象软件的基础”。原书将这23种设计模式分为三类： 创建型包含5种模式，涉及对象/对象组合的创建构建。 结构性包含7种模式，涉及对象/类之间的关系。 行为型包含11种模式，涉及对象/类的行为、状态、流程。 从该书的标题我们可以了解到，设计模式是一个面向对象开发方法下的概念，是解决代码设计/软件架构问题的可复用的元素，同时是基本元素（elements）。引用原书的例子，我们大家所熟识的MVC模式，Model-View-Controller，就可以解构为几种设计模式的组合演变，比如可以在View和Model的关系中看到观察者模式 Observer、组合模式 Composite、装饰模式 Decorator，在Controller中发现策略模式的影子。通过对23种基础模式的有机利用和结合，可以进一步演化出更复杂的软件架构。限于篇幅，本文不会讲解每种设计模式的定义和背景，读者可以参考设计模式简介来学习定义。 设计模式的UML、类比和范例这个部分，我们逐步从尝鲜到类比，深入理解一些比较常见有趣的设计模式的UML及其经典实例。GoF原书中也推荐学习者从“模式怎样相互关联”以及“研究目的相似的模式“出发来学习和选择设计模式。首先看看最简单常见的策略模式和另一个同属行为型模式的状态模式： 策略模式 Strategy 状态模式 State UML 范例 - Comparator#compare() 和 Collections#sort()- Spring Security: PasswordEncoder - 标准范例: javax.faces.lifecycle.LifeCycle#execute()- 形似样例：Java Thread State, ExoPlayer 概述 让外部对算法的相互替换无感 允许一个对象根据内部状态改变行为 关键字 Strategy, rule State, switch, phase, lifecycle 核心角色 Strategy State 策略模式和状态模式在UML图形上非常相像，他们之间的主要区别如下： 状态对象可以持有上下文对象（调用方），但策略模式一般存在这种依赖。 状态模式可以在彼此之间进行跳转替换，比如调用了播放器的play方法，那么状态可能从stop-&gt;playing，这个操作可以用状态对象完成。 一个策略和调用方的关系（依赖）可能弱于状态和上下文对象的关系（持有、属性）。 策略的不同可能只影响一个行为，但是状态的不同影响状态持有对象行为的方方面面。 整体上策略模式要比状态模式更加简明易懂，应用场景更广，在大型项目中的应用也随处可见。而状态模式虽然也是对常见概念的抽象，其应用却相对有限，其原因可能是，在更多的情况下，把行为的差异定义在不同的状态中，可能并非符合直觉的操作：与其把状态也定义为对象承载行为，不如把状态定义为一个标记，直接用if或switch判断来的直接。或者换言之，大多数情况下，问题还没有复杂到要用状态模式的程度。 借助这种对比的视角，我们来学习更多模式。先看看以下三种结构型设计模式： 适配器 桥接模式 外观 UML 范例 RecyclerView.Adapter 范例比较少：- Collections#newSetFromMap()- (ADB?)，如Spring中Service和Repository的关系 常见，如：Facades, FacesContext, ExternalContext, DataSource#getConnection() 概述 将一个类的接口转换成满足另一个要求的接口 将抽象部分与它的实现部分分离 为子系统中的一组接口提供一个一致易用的界面 关键字 Adatper Wrapper Context 核心角色 Adpter, Adaptee Bridge Facade 适配器模式、桥接模式和外观模式同属结构型设计模式，他们三者概念上很相像，都是通过建立接口来为类的方法建立或重构关系，比如，似乎我们用外观的视角去解释适配器，也能解释的通，Adapter就是在帮助Adaptee建立统一界面，或者建立桥梁。 设计模式就是这样，非要较真，所有的设计模式都大同小异（至少在一个类型之内），这是学习设计模式的一个误区。回到上面的三个设计模式上，他们的核心区别更多体现在时机和出发点上：适配器Adapter强调兼容性，桥接Bridge强调抽象与实现的分离，而外观Facade强调简化复杂性。我们分辨这些模式也应该从意图出发来看。 Spring的三层结构也融合体现了Facade和Bridge的设计，Service和Repository之间偏重体现Bridge模式理念，而Controller和Service之间更像Facade模式：Controller整合Service，对外提供API: 下面我们再看几种常见的行为型模式的类比分析： 代理 装饰 中介 UML 范例 - Java Reflect API: Proxy - Java EJB: Enterprise JavaBean, JavaX Inject, JavaX PersistenceContext- ActivityManager 和 ActivityManagerService- PerformanceInspectionService 和 PerformanceTestManagementService - Java IO: GZIPOutputStream and OutputStream, Reader and BufferedReader- java.util.Collections, checkedXXX(), synchronizedXXX() 和 unmodifiableXXX() 系列方法，拓展集合 - HttpServletRequestWrapper and HttpServletResponseWrapper- JScrollPane - Java Message Service, JMS by Oracle - java.util.Timer (all scheduleXXX() methods), java.util.concurrent.ExecutorService (the invokeXXX() and submit() methods) 概述 通过代理来控制对一个对象的访问 动态地给一个对象添加功能 封装对象之间的交互（传话筒） 关键字 Delegate Wrapper MessageQueue, Dispatcher 核心角色 Proxy Decorator Mediator 这里，从类之间关系上看，代理和装饰更为相似，而中介则不同，它只是名字上和代理相近。关于代理(访问和控制)和装饰（增强和扩展）的区分，同样可以从目的和意图的角度区分。以代理来为例，它的首要作用是建立访问通道，比如安卓中，应用和系统之间用Binder来进行IPC，而在应用进程和系统进程间，为了这种IPC调用，大量应用了代理模式，名为Proxy的对象随处可见。而在设计Hydra Lab的过程中，为了让测试用户能方便的在测试实例中通过SDK访问一些Hydra Lab Test Agent的服务方法，我们也应用了一个简明的静态代理来实现这种不同环境下的访问。 在代理模式下，有了访问通道，自然就可以做到对通信的控制，比如基于权限的、或是基于格式验证的。而装饰模式着眼于增强、扩展，比如BufferedRead对于Reader的增强。从这个角度讲，一个类如果叫AuthWrapper就会比较奇怪，AuthProxy则更常见一些，因为授权这种操作明显更强调控制。当然这取决于具体情境。 中介其实是很宽泛的概念，解耦通信的双方或多方，比较火热的各类MQ框架其实是这个模式的一个衍生。 观察者 访问者 UML 范例 - java.util.Observer, Observable- java.util.EventListener- ReactiveX Interface Observer - AnnotationValueVisitor- ElementVisitor- TypeVisitor- SimpleFileVisitor- VisitCallback- ClassVisitor (ASM 9.4) 概述 对个观察者监听一个主题对象 表示一种对某对象中各元素的只读操作 关键字 Observable, Observer, Subject,Subscription Visitor 核心角色 Observer, Subject Visitor, Element 这两个模式之间在实现上其实并没有太多联系。但二者都是想去“读”，不会直接改变被读对象的状态。观察者通过订阅监听的方式被动地读，而访问者是主动视角，以一种独特的方式读。和观察者很相近的“Listener”，是更常见的概念，更轻量，因而也更广泛。 责任链 备忘录 UML 范例 - OkHttp Interceptors- java.util.logging.Logger- javax.servlet.Filter - Activity#onSaveInstanceState(…) - Java Serializable 概述 建立处理链条传递请求 捕获对象状态并保存，以备状态恢复 关键字 Chain, Interceptor, Filter, proceed, Response State, Lifecycle, Context 核心角色 Handler Memonto, Originator, Caretaker 责任链和备忘录模式虽然意图和设计上都不相同，但二者都有非常浓厚的IoC控制反转的味道，和生命周期的设计联系紧密。玩游戏的同学对备忘录模式最容易建立理解，一个存档就是一个持久化的State，游戏本身的存读档服务作为caretaker，帮你保证你肝的进度不会白费。所以备忘录模式其实非常的常见，软件世界里俯拾皆是。 命令 解释器 UML 范例 - IShellOutputReceiver- Java Runnable - java.util.Pattern- java.text.Normalizer- java.text.Format- javax.el.ELResolver 概述 将请求封装为对象，从而方便参数化和请求队列管理 定义文法和表示方式 关键字 Executor Expression 核心角色 Command, Receiver, Invoker(Executor) Interpretor, Expression 上面两者也无法直接类比，但是当二者合体，命令的解释和执行一气呵成，一个脚本语言的c执行器雏形就诞生了。这里的命令模式其实比“命令”本身在设计上有更周全的考虑，它还包括了对执行结果的接收接口的预留。 抽象工厂 工厂方法 UML 范例 - DocumentBuilderFactory(JavaX) - TransformerFactory(JavaX)- XPathFactory(JavaX)- BeanFactory#getBeanProvider(Spring) java.util.Calendar#getInstance() 概述 将一个类的接口转换成满足另一个要求的接口 由工厂的子类决定创建的实例对象 关键字 Factory, new…, create… Factory, newInstance, Creator 核心角色 AbstractFactory Creator 其他模式还包括：建筑者模式，原型模式，享元（类似多例），单例；组合；模板方法，迭代器。这些模式或是不常用，或是过于常用常见，且都比较简单，限于篇幅本文不再一一详述。 通过这个类比学习的过程，我们可能会逐步感受到，设计模式的重点并不在于类之间关系的严格定义、罗列和排布，无意义的争辩、论证会陷入“把设计模式当作一个严格的学术理论”的误区。更多的，我们应该从问题的意图出发，发散思考解决方案中可能包含的设计元素，然后根据实际情况精简到合理的规模。 所以我们不必纠结于相近的两种模式的严格界定和区分，比如，无需辩驳一种实现究竟是用的代理还是装饰，而是理解这两种模式的看问题的角度和意图，融会贯通，灵活组合运用：如果你强调的角度是功能拓展，那设计方案就是装饰；如果你强调的是访问控制，那就是代理。很多初学者觉得很多模式很相似，感到多余，这是很正常的感受和学习阶段；随着更多应用和实战，你会成长和洞察更多模式的意义；后来你已经成为设计大师，灵活运用设计模式、AOP、函数式、算法乃至ML解决各类问题，讲述和推动方案的实现，设计模式的探讨和辩论只不过是茶余饭后的谈资。这一点，在原书“怎样选择设计模式”章节中，也有提及。 总结来讲，初学设计模式，关注点可以放在： 这个设计模式解决什么类型的问题，意图是什么，以及它如何对概念进行抽象（关键角色）和解决（接口、关系）的。 用设计模式作为大家沟通软件设计的语言，掌握这些术语，减少沟通成本。 如何学习和使用设计模式本部分内容源自GoF原书中1.8章的内容“怎样使用设计模式”，精简了原书的7步为6步，并去除了翻译腔： 浏览一遍该模式，掌握关键要素这个模式的名字是什么，意图是什么，里面的关键角色是什么，常见的关键词？ 回头去研究结构部分、参与者部分和协作部分进一步了解角色的职责和关系，有哪些接口，以及模式的适用性：这个模式更适合解决什么类型的问题？ 看看示例代码例子能让我们了解模式解决的实际问题，成为我们实现的参考。 参考模式中的命名方法比如，在Strategy模式中，你可以直接给算法命名末尾加上Strategy来体现这个模式；再比如，可以用create作为方法的开头前缀来凸显工厂方法。 定义类和接口选定好模式、完成命名后，下一步可以建立好类与接口之间的继承/实现关系，定义代表数据和对象引用的实例变量。 实现模式开始依据模式实现解决方案。 设计模式的引入是带有一定成本的，学习成本和复杂性的增加就是其中之一，也可能会有性能上的损耗（虽然可以忽略），但它为架构带来了灵活性，使其更加清晰可维护。接下来，作为拓展阅读，我们可以探讨一下设计模式的意义，获得更深的理解。 设计模式的意义和批判谈及为什么需要设计模式时，首先要回答什么设计是好的设计。软件是对现实问题复杂性的抽象和管理，Uncle bob说：“软件应该是可变的”，正如现实世界“唯一不变的就是不断地变化”，软件应该能灵活地应对现实世界的需求。所以我们会讨论软件架构的可扩展性、可维护性、高可用、可重用、可移植性等。如果你只是在编写一个又一个的脚本、一次性工具或者编程练习题，当然不用把问题复杂化。但如果你希望你的软件有更强的生命力和更广阔的前景，那就要严肃对待软件设计，防止代码腐化。 此外，一个人的力量是有限的，如果希望借助协作来扩大软件的服务范围、影响力，那么可读性也就重要起来。“Good code is like well-written prose”，好代码应该像优美的散文；至少是自解释的。引述GoF的原文，“所有结构良好的面向对象软件体系结构中都包含了许多模式…内行的设计者知道：不是解决任何问题都要从头做起…这些模式解决特定的设计问题，使面向对象设计更灵活、优雅，最终复用性更好。”所以这里的两层意思就一方面强调了模式对软件设计本身的好处，一方面说明了这些模式建立了大家在面向对象设计上的共识和交流基础。此外，大师们还总结了一些设计原则来框定好的设计。 SOLID设计原则尽管很多教程将设计原则和设计模式放在一起讨论，暗示设计模式是遵从了设计原则，实际上他们并非同出一家。而且设计原则有很多种说法，这里我们分享Uncle Bob提出的最容易记忆的版本，SOLID 原则： Single responsibility, 单一职责原则 SRP：就一个类而言，应该仅有一个引起它变化的原因。 Open-close, 开闭原则 OCP：软件实体应该对于扩展是开放的，对于修改是封闭的。 Liskov substitution, 里氏代换原则 LSP。子类型必须能够替换掉它们的父类型。把父类实例替换成子类实例，程序行为不应该有变化。 Interface segregation, 接口隔离原则 ISP。 一个类对另外一个类的依赖性应当是建立在最小的接口上的。 客户端程序不应该依赖它不需要的接口方法（功能）。 Dependency inverse, 依赖倒转原则 DIP： 高层模块不应该依赖低层模块。两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 我们可以认为这些设计模式是解决设计问题思考的准绳，也可以认为他们只是一种理念。正如Uncle bob 所说：”The SOLID principles are not rules. They are not laws. They are not perfect truths… This is a good principle, it is good advice…”。总之，了解这些可以帮助我们把握思考方向，但不能帮我们解决问题。换言之，对于初学者而言，设计原则可能没有设计模式那样强的实战意义。 批判之声关于设计模式的批判，源自于对其创立所处时代的主流编程语言的局限性的挑战，以及对于面向对象本身的质疑。有人认为设计模式的提出反映了Java和C++自身语言特性的缺失；也有认为如果灵活运用aspect-oriented-programming，就用不着搞出来23种之多啰啰嗦嗦的设计模式了。对此，笔者觉得纯粹的理论上的对错没那么重要，软件开发是科学和艺术的结合地带，而设计模式是一个时代开发者思考的精华沉淀，能给我们带来的不仅是具体方案，更多的是解决问题的思维方式，它们本身就存在于大量的编程实践中，GoF对他们进行了提炼和综述，这本身就是意义巨大的成果了，更何况他们已经成为工程师文化的一部分，成为了术语。例如，我们从Spring中既能看到AOP的应用、函数式编程的应用，也能看到建造者、工厂模式、策略等等的应用。编程大师应该是博学和不拘一格的，代码的艺术正在于灵活和适时的运用，囿于固执信仰而拒绝经典或者新知断不可取。 其他常见疑问FAQQ: 设计模式和后续流行的的Reactive、函数式编程、AOP、IoC以及DI之间的关系是什么？ A: 总体上，这些是不同维度的概念，总结为下表： 概念 释义（译） 范畴 设计模式 Software design pattern 软件设计的解决方案 IoC 控制反转 Inversion of control 软件架构层面的一种设计模式 DI 依赖注入 Dependency injection 一种设计模式 AOP Aspect-oriented programming，面向切面的编程 编程范式（面向对象） 函数式编程 Functional programming 编程范式（声明式） Reactive Reactive programming, 响应式编程 编程范式（声明式） 微服务 Microservices 一种架构模式（面向服务的架构） Q: 是否还有其他设计模式？ A: 有的，随着软件开发实践的演化，有越来越多的设计模式被总结出来，只不过可能还没有一本经典将其整理入册。比如常见的锁的双重检查，也被认为是一种独立于语言的并发型设计模式。DI也是设计模式 Concurrency Patterns，其角色包括注入器Injector，服务Service，客户端Client和接口Interfaces。DI也是一种创建型Creational设计模式，其意图在于优化类之间依赖关系，因而和整个软件或模块的架构的相关性更密切。 References Design Patterns, Elements of Reusable Object-Oriented Software https://en.wikipedia.org/wiki/Software_design_pattern http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod https://en.wikipedia.org/wiki/SOLID https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start https://en.wikipedia.org/wiki/Law_of_Demeter https://www.jianshu.com/p/8cbc4bf897cb https://coderanch.com/t/99717/engineering/Bridge-Facade-Pattern https://stackoverflow.com/questions/3477962/when-do-we-need-decorator-pattern https://stackoverflow.com/questions/6366385/use-cases-and-examples-of-gof-decorator-pattern-for-io https://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries/ 关于我我是风云信步，目前在微软中国担任研发经理。希望在这个空间和大家分享交流技术心得，职业生涯，团队和项目管理，趋势动态。旨在畅谈、分享和记录，不拘小节；但也不排除刨根问底、钻牛角尖。 本人热爱技术和打码，尤其享受用技术解决实际问题的过程和结果；相信创造力是顶级能力，是人价值的放大器。此外，本人专注于软件和代码质量、工程效率和研发能效方面多年，目前在微软和团队一起推动2023年新开源的项目Hydra Lab的完善与发展；欢迎和我在开源世界组队打码，造轮子 or 添砖加瓦。","link":"/2022/10/15/tech/design-patterns-all-in-one/"},{"title":"PlantUML指北：用UML设计和规划你的项目","text":"随着ChatGPT爆火，网络上贩卖焦虑的声音此起彼伏，我等工程师、程序员似乎马上要被一锅端起，倒入历史涡流。笔者想说，莫慌，软件开发是一门极其复杂的学问，断然不是写两行代码那么简单。产品百万千万行的代码依然需要人来读懂和维护，架构设计、模式、扩展性依然是核心命题。UML是软件设计的利器，而PlantUML是一个很好的UML创作工具。 PlantUML简介PlantUML是一个开源的UML绘图工具，目前在GitHub上有7.5K Stars，最早于2021年10月发布第一个正式版本，历经二十多个版本迭代，目前已非常成熟。它可用于快速创建UML（统一建模语言，Unified Modeling Language）图表，生成可视模型，帮助开发者将复杂的设计概念表示出来PlantUML 最与众不同的地方在于它提供了一套简单的纯文本语法来定义UML，堪称是UML界的Markdown，起到了桥梁和规范的作用。也就是说，你可以扫描代码来生成PlantUML，也可以解析PlantUML文本来生成代码。 PlantUML开源社区也很繁荣，其结果就是它丰富的插件，可与Visual Studio Code，JetBrains，Eclipse，NetBeans等系列IDE集成，以方便创作和预览。它能生成的视图支持包括SVG，PDF，PNG，EPS和LaTeX等丰富格式，基本上应有尽有。此外，PlantUML甚至还可以支持思维导图、甘特图、JSON、YAML的可视化，把影响力扩大到了UML之外。它已成为越来越多神级工程师、架构师、项目经理的必选工具。我在微软的开发团队出品的开源作品 Hydra Lab 就采用了PlantUML进行架构设计和协议规范可视化，用起来可谓得心应手。 关于PlantUML的细节用法，官方中文文档已经说得很清楚了，本文将不再赘述，而着重将篇幅放在具体使用经验的分享上。 小试牛刀PlantUML是一个基于Java的工具，需要Java运行环境。本文将基于其当前最新版本1.2023.1进行实战讲解。不过，最快捷的试用PlantUML语言的方法莫过于直接使用官网的服务，各位可以尝试把一下内容粘贴进输入框看效果： 以下代码呈现了类之间关系的表达，学习UML时候最容易搞混的就是各种箭头之间的区别和联系： 1234567891011121314@startuml class-relations-1Postman -- Postbox : associate，（关联）Driver -- Car : drives（关联） &gt;Car *-- Wheel : have 4 （包含，组合） &gt; Car -- Person : &lt; owns（关联）Folder *-- 字母F : starts with (composition，组合) &gt;Folder o-- File : contains (aggregation，聚合) &gt;Department o-- Employee : contains &gt;@enduml 下面的代码展现了或者扩展、实现、依赖的类间关系： 1234567891011121314151617@startuml class-relations-2Cat -up-|&gt; Animal : extends &gt;Dog -up-|&gt; Animal : extends &gt;class Cat { -meow()}class Dog { +bark()}iPhone ..|&gt; SmartPhone : realize （实现） &gt;DBReader ..&gt; DB : depends on （依赖） &gt;@enduml PlantUML会自动处理图表的外观和布局，开发人员可以不用在意细节，同时他也支持一定程度的自定义。他的语法中使用@startuml和@enduml作为开头和结尾的声明，此外还有@startjson和@startyaml支持JSON\\YAML数据结构的可视化，@startgantt用于画甘特图，@startmindmap用于绘制思维导图，@startmath（AsciiMath）或@startlatex（JLaTeXMath）用于绘制数学公式，功能可谓十分强大。这里仅展示一些示例，不再一一赘述，官方PDF写的很清楚了。下面是一段Spring Boot配置文件的可视化： 1234567891011121314@startyaml yaml-preview-demoserver: port: 9886 compression: enabled: true min-response-size: 102400spring: cache: type: ehcache application: name: 'my-app' datasource: driver-class-name: org.sqlite.JDBC@endyaml 以下是一个活动图（activity diagram）示例： 12345678910@startuml activity-diagram-preview-demostartif (Graphviz installed?) then (yes):process all\\ndiagrams;else (no):process only__sequence__ and __activity__ diagrams;endifstop@enduml 更多示例可以看这里：REAL WORLD PlantUML。 实际应用在实际的开发场景中，我们可以运用PlantUML语法规范在代码库中进行撰写设计，以文本的形式输出内容到.puml文件中，然后调用PlantUML来生成可视化的图表，从而方便用来在Markdown技术文档当中引用，支持技术评审。那么，我们是否可以自动化这一流程，形成闭环？答案当然是可以的，PlantUML提供了Java依赖库，可以在代码中直接调用。这里演示一个小小的实例，利用Gradle创建构建任务，实现UML图片生成。 首先我们在项目中添加PlantUML依赖: 1implementation 'net.sourceforge.plantuml:plantuml:1.2023.1' 接着，我们在Gradle中创建一个任务，扫描特定目录下的所有puml文件，将他们交给生成逻辑（UMLImageGenerator#generateUMLImageFromFile）进行处理： 12345678910111213task generateUMLImage(group: 'documentation') { doFirst { def scanningDirList = ['agent/doc/UML'] def outputDir = new File(projectDir, 'docs/images/UML') def generator = new UMLImageGenerator() scanningDirList.each { fileTree(new File(projectDir, it)).filter { it.name.endsWith(&quot;.puml&quot;) }.files.each { generator.generateUMLImageFromFile(it.absoluteFile, outputDir) } } }} 具体的从文件生成图片的逻辑如下，这里调用的核心类就是PlantUML提供的SourceFileReader API： 12345678910111213141516171819202122232425import net.sourceforge.plantuml.FileFormat;import net.sourceforge.plantuml.FileFormatOption;import net.sourceforge.plantuml.GeneratedImage;import net.sourceforge.plantuml.SourceFileReader;import java.io.File;import java.io.IOException;import java.util.List;public class UMLImageGenerator { public void generateUMLImageFromFile(File source, File outputDir) throws IOException { generateUMLImageFromFile(source, outputDir, false); } public void generateUMLImageFromFile(File source, File outputDir, boolean svg) throws IOException { if (!source.exists()) throw new RuntimeException(source.getAbsolutePath() + &quot; file doesn't exist&quot;); SourceFileReader reader = svg ? new SourceFileReader(source, outputDir, new FileFormatOption(FileFormat.SVG)) : new SourceFileReader(source, outputDir); List&lt;GeneratedImage&gt; list = reader.getGeneratedImages(); System.out.printf(&quot;Successfully generated %d UML images.\\n&quot;, list.size()); }} 与上逻辑写好之后，我们在Gradle的任务列表documentation组中就可以看到这个新的任务了： 执行这个任务，就可以看到图片图片说出到了预期的目录下。本实战案例详细代码如下： generateUMLImage任务定义 PlantUML依赖声明 UMLImageGenerator.java 进一步探究我们是否有可能根据UML设计来生成代码？那么首先我们需要读取出PlantUML的解析信息，顺着SourceFileReader的API我们可以进一步找到如下调用链: 12345Diagram diagram = reader.getBlocks().get(0).getDiagram();if(diagram instanceof net.sourceforge.plantuml.classdiagram.ClassDiagram){ ClassDiagram classDiagram= (ClassDiagram) diagram; classDiagram.getLeafsvalues().forEach(leaf -&gt; System.out.println(leaf.getCodeGetName()));} 这里的net.sourceforge.plantuml.baraye.ILeaf类型的对象就是解析后的叶子实体了，包含了代码生成所需要的信息，可以利用他来生成一些接口代码，从而进一步实现从代码设计到初始实现的自动化。","link":"/2023/01/31/tech/plantuml-get-started/"},{"title":"国内利用Azure OpenAI在Java中使用ChatGPT模型","text":"在ChatGPT和各类生成式AI大热的今天，利用AI赋能产品开发和内容创作的价值不言而喻，在工作和生活中充分利用ChatGPT可以大幅提升效率。然而，由于在中国的访问限制，直接使用OpenAI的ChatGPT，对于希望利用这项技术的开发者和企业来说是一个巨大的挑战。本文将分享，如何在Java和Python环境下，如何分别通过Azure OpenAI（不限制中国IP）使用GPT大模型，希望帮助大家推动项目创新和提效。 本文源代码： AzureOpenAIServiceClient.java 开通Azure服务和订阅首先你需要有一个微软账户，可以到任意微软服务网站上注册，比如：Microsoft Azure。注册的时候地区选择美国的话可以为后面使用必应Chat提供方便。 然后，访问Azure控制台开通Azure服务，并创建订阅，第一次注册的话会有一定的免费试用额度。接着访问Azure OpenAI Service了解微软提供的OpenAI模型的服务，并在你的Azure控制台上开通Azure OpenAI服务。可以阅读这篇文章Introducing GPT-4 in Azure OpenAI Service获取申请链接，填写表单 “Request Access to Azure OpenAI Service”进行对所需要的模型进行申请。 开通完成之后，你的Azure里就会多一个这样的图标了： 随后，我们就可以在Azure AI studio中创建和管理模型Deployments： 选择你的模型： 创建成功后，我们就可以利用示例代码，在Java中通过Azure OpenAI的API请求完成使用Chat功能了。Azure AI Studio上还有很多好玩的功能，如果你申请了OpenAI的图片生成模型DALL·E的访问权限，那么这里还可以试用“DALL·E playground”来根据你的描述生成图片： 除此之外，也可以在这里使用聊天功能和文本完成功能： 通过代码调用服务通过示例代码AzureOpenAIServiceClient.java我们可以了解到，实际上与Azure OpenAI服务进行通信的主要是通过向我们在Azure中注册服务中的endpoint发送HTTP请求，来完成的。在这段代码中，首先导入了必要的HTTP请求依赖库。然后定义了一个名为AzureOpenAIServiceClient的类，它维护了与Azure OpenAI服务通信所需的一些配置参数，包括： API密钥(apiKey)：可以在你的Azure控制台相应的OpenAI service页面找到。见下图。 服务入口地址URL(endpoint)：一般形如https://{你的AzureOpenAI服务名字}.openai.azure.com。可以在你的Overview页面看到。 模型部署名(deployment)：你之前起的模型名字。 API版本(apiVersion)：目前的常用版本是2023-03-15-preview。 目前的核心功能，chatCompletion方法，接受一个ChatRequest对象和operation（这里其实就是chat/completions）作为参数，并调用callAzureAPI方法，将请求对象转换为JSON字符串，并发送到OpenAI RESTful API服务完成请求： 12345678910111213141516171819private String callAzureAPI(String operation, String requestBodyString) { MediaType mediaType = MediaType.parse(&quot;application/json&quot;); String url = String.format(&quot;%s/openai/deployments/%s/%s?api-version=%s&quot;, endpoint, deployment, operation, apiVersion); logger.info(&quot;Request body: {}&quot;, requestBodyString); RequestBody body = RequestBody.create(requestBodyString, mediaType); Request httpRequest = new Request.Builder().url(url).post(body) .addHeader(&quot;api-key&quot;, apiKey).build(); try (Response response = client.newCall(httpRequest).execute()) { if (!response.isSuccessful()) { throw new RuntimeException(&quot;Unexpected response code: &quot; + response); } return Objects.requireNonNull(response.body()).string(); } catch (Exception e) { throw new RuntimeException(&quot;Error occurred while invoking Azure OpenAI API: &quot; + e.getMessage(), e); }} 其中，ChatRequest对象中的几个参数的含义解释如下： Azure OpenAI HTTP请求中的几个参数的含义如下： max_tokens: 生成文本的最大长度。 temperature: 生成文本的随机性，取值从0到1，较高的“温度”值意味着模型将冒更多的风险。0表示随机性最低，创造性最差。 frequency_penalty: 使用词频惩罚。较高的频率惩罚将阻止模型重复。 presence_penalty: 使用存在惩罚。较高的存在惩罚将鼓励模型专注于输入提示本身。 top_p: 从模型预测中选择概率最高的标记，直到达到指定的总概率。默认为1。也就是说，一旦该分布超过top_p值，就会停止生成文本。例如，top_p为0.3表示仅考虑组成前30％概率质量的标记。 stop: 停止生成文本，当模型生成某些指定字符时，就停止不在生成。默认为空。 代码使用示例接下来，我们就可以写一个简单的用例，来试用该功能了，先让它讲个笑话。 123456789AzureOpenAIServiceClient azureOpenAIServiceClient = new AzureOpenAIServiceClient(apiKey, deployment, endpoint, apiVersion);ChatRequest request = new ChatRequest();request.setTemperature(0.9);request.setMessages(Arrays.asList( new ChatMessage(ChatMessage.Role.SYSTEM, &quot;You are an AI assistant that helps people find fun and jokes, to make people laugh a lot.&quot;), new ChatMessage(ChatMessage.Role.USER, &quot;tell me 3 jokes&quot;)));logger.info(azureOpenAIServiceClient.chatCompletion(request)); 完成一次尬聊，得到很难get到笑点的三则笑话： 123456789101112131415161718192021{ &quot;id&quot;: &quot;***&quot;, &quot;object&quot;: &quot;chat.completion&quot;, &quot;created&quot;: 1680000000, &quot;model&quot;: &quot;gpt-35-turbo&quot;, &quot;choices&quot;: [ { &quot;index&quot;: 0, &quot;finish_reason&quot;: &quot;stop&quot;, &quot;message&quot;: { &quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;Sure, here are three jokes for you:\\n\\n1. Why don't scientists trust atoms? Because they make up everything!\\n\\n2. Why did the tomato turn red? Because it saw the salad dressing!\\n\\n3. Why did the bicycle fall over? Because it was two-tired!&quot; } } ], &quot;usage&quot;: { &quot;completion_tokens&quot;: 14, &quot;prompt_tokens&quot;: 37, &quot;total_tokens&quot;: 51 }} 试用一下就可以发现，全程使用国内网络也可以正常调用，没有任何问题。 后续一旦将完成在Java一端的接入，我们就可以将其集成到各项和聊天、文档生成、数据推理分析等等相关的应用功能当中。如果你感兴趣，可以持续关注 微软HydraLab 项目，我们将在其中持续探索大语言模型赋能智能化测试的如下方向： 测试环境的模拟生成。 测试数据生成。 智能探索型测试。 测试用例生成和优化。 测试结果分析解读。 测试智能调度和重试：提升运行稳定性提升。 基于测试结果的诊断建议。 … 并在代码库中逐步分享一些相关场景prompt、向量模型和可复用代码。如果申请Azure OpenAI Service遇到问题，可以私信我联系。","link":"/2023/07/15/tech/ai/call-azure-openai-gpt/"},{"title":"编程的本质","text":"编程的本质是什么，或者说代码的本质是什么？有一个很古老（20世纪70年代）的说法： $$程序 = 算法 + 数据结构$$ 那么，难道说编写程序就是在编写算法和数据结构吗？事情肯定不是那么简单，往大一点说，除了算法和数据结构本身之外，代码里还凝结着解决问题的思路、商业社会的价值规律、人类社会运行的规则。人类社会的逻辑和程序的价值息息相关。 这样讲可能并不夸张，编程最初的目的就是为了指挥机器帮助人做事，而我们最开始就是为了减少重复性的工作。然而重复性本身就体现着规律和逻辑，我们在不断提升程序的价值，让代码涵盖越来越多的重复性的工作的同时；不知不觉间把社会的规律写进了代码当中。这项工作是由产品经理和开发者一起完成的。 一个人单打独斗总是低效的，所以过去没有机器的时候，如果个人想放大自己的价值，一种办法是向深处探究，成为科学领域的领袖，推进历史车轮向前；另外一种办法是攀登权力的阶梯，掌握话语权，领导一个群体达成社会成就。 但计算机的出现改变了这个局面，一个人如果能够控制机器为自己做事。 是程序把人类的思想和逻辑固化下来，把流程和规则。通过代码体现出来。 代码是现实世界在虚拟世界的投影。 程序控制结构(program control structure)：顺序结构，条件（选择）结构，循环结构。程序是顺序、选择、循环三种结构的复杂组合。 References Algorithms + Data Structures = Programs","link":"/2022/11/01/tech/the-nature-of-code/"},{"title":"什么是好代码？","text":"","link":"/2022/09/01/tech/what-is-good-code/"},{"title":"代码中的人文故事：从一个Java的“Bug”说起","text":"缘起这几日闲来无事撸代码，无意中发现一桩趣事。原以为是一个Java的bug，没想到经过一系列死磕，挖掘出了一段和中国历史乃至人类文明相关联的人文故事，不禁唏嘘感叹一番。 这件事的缘起很简单，我在实现计算两个日期天数距离逻辑的过程中，发现了一个很诡异的事情，同样的起始日期，用python和Java计算出的结果居然不一样！ 例如，计算一个1990年1月1日到1990年9月4日之间的天数，用python计算如图： 得出天数为246。可以看到，python的API设计简单。 用Java计算则不同了，众所周知Java推荐的Calendar API不是一般的麻烦，实现函数如下： 按照这个逻辑测试如下： WTF!?得出的天数居然是245天？为什么和Python算出来的不一样？我马上实际数了一下，应该是246天，Python算的结果是对的！ 仔细核对了程序实现，没毛病啊？难道有精读损失？ 狐疑（懵逼）进而加入如下输出： 什么鬼？这0.0416666667天跑哪里去了？需知： 也就是说，Java计算的时间和实际正好差了一个小时！ 无独有偶，各种百度后，居然发现了和我有类似疑问的兄弟：https://ask.csdn.net/questions/241889然而这个提问下并没有靠谱的答案！ 这样看，似乎很像时区上出了问题，然而并不是，前后Calendar对象的时区完全一致！都是Asia/Shanghai！ 由此难免要想，难道Java代码有Bug？把这一个小时给吃了？好吃吗？啥味道？ 然而，用同样的函数，计算990年1月1日到1990年12月4日之间的天数，有一切正常了！ 心中万马奔腾啊！ 经过一番探索，我又写了如下代码： 惊奇地发现： 进而又发现： 由此我灵机一动，又写了一段代码，找到从1900年至今所有当天长度非24小时的日期！ 此中必有蹊跷！ 豁然然而这对于没文化的我来说，实在是一件不可理喻的事情。只能从源码入手了！ 找源码的过程就不再赘述了，总之，时间的偏移来自于一个zoneOffsets的数组，而这个数组中除了因为时区而产生的偏移外，还有一个神秘的DST_OFFSET！ 找到这里，这个谜团即将揭晓了！ 啥是DST_OFFSET呢？ 没错，daylight saving offset，也就是夏令时！ 也就是说，中国的1990年4月15日这天里，人为地将时间拨快了一个小时，1990年9月16日这天再拨慢回来。进一步说，中国的1990年4月15日这天确实是23个小时，1990年9月16日这天也确实是25小时，Java没搞错！ 也就是说之前找到的所有非24小时的日期，都是中国政府（或国民政府）施行夏令时调整的日期，这段历史断断续续地持续了半个多世纪！而Java的Calendar API将其忠实地记录了下来。 关于夏令时详情见百度百科。哈哈哈，真相揭晓，好感慨好激动。所以说，这并不是Java的bug，而正是Java严谨的体现！Calendar API确实设计的很烂很不友好，但并不代表其中有bug，相反地，这也正体现了其中的工程师精神。 这就引出了一段已经被淡忘的历史，很多90年出生的朋友可以问问父母，90年和91年是我国至今为止实行夏令时的最后两年，我国曾经也想向美国等西欧国家学习，充分利用太阳下的时光！年轻的小朋友问问你们的父母，一定能勾起他们的一段回忆！ 这就是隐藏在Java代码中的一段历史，一段已经被遗忘的人文故事！ 想了解这段历史的同学可戳： 还记得大明湖畔的夏令时吗？ 只要刨根问底，一定有意想不到的收获！感觉解决了个大谜团！","link":"/2018/07/13/tech/java/java-calendar-story/"},{"title":"Java字节码修改神器HiBeaver：黑掉你的SDK","text":"前言有时候我们在Java开发过程中可能有这样的需求：需要研究或者修改工程依赖的Jar包中的一些逻辑，查看代码运行中Jar包代码内部的取值情况（比如了解SDK与其服务器通信的请求报文加密前的情况）。 这个需求类似于Hook。 但是往往这些依赖的Jar包中的代码已经被混淆过，删去了本地变量表和代码行号等debug信息，所以无法直接断点调试，其内部逻辑和运行情况也几乎无法触及，研究更难以下手。这时候，一般的办法有二： 将Jar反解为Java源码，以module方式引入，便可自由修改调试； 修改字节码或者打包后的smali代码，实现想要的逻辑后再重新打包。 这两种方法中，前者往往十分繁杂，尤其在混淆后逻辑变得极其复杂，几乎不可能完成；后者也很麻烦，工序较多，修改成本也比较高。 插件：HiBeaverGradle编译插件hibeaver结合Java AOP编程中对于大名鼎鼎的ASM.jar的应用，和Android gradle 插件提供的最新的Transform API，在Apk编译环节中、class打包成dex之前，插入了中间环节，依据开发者的配置调用ASM API对项目所依赖的jar进行相应的修改，从而可以比较高效地实现上面的Hook需求。源码地址：https://github.com/hydraxman/hibeaver （现在hiBeaver已经发布了1.2.7版本，支持轻量级AOP框架设计。） 唯一需要注意的是，运用好这个插件需要有一定的Java汇编指令基础，并了解基本的ASM3的使用方法：后者还是很简单的，而前者，关于Java汇编指令基础这块，对于事先不了解的同学，接触起来有一定难度，但是学一学这个其实非常有益处，对于理解Java的运行有很大的帮助。闲话少说，先看看如何快速实践一把！关键看疗效！ 关于汇编指令的资料可以参阅本人的文章：大话+图说：Java汇编指令——只为让你懂 实战演练我们就先来尝试用这个Hook掉小米推送的SDK。 首先，在需要的工程的根项目gradle配置中加入以下内容： 如图所示，该插件上传到了jcenter中，只需引入classpath： classpath 'com.bryansharp:HiBeaver:1.2.7' 这里需要注意的是，目前该插件仅支持Android gradle编译插件2.0及以上的版本。然后，在你的App项目gradle配置底部或任意位置加入如下代码： apply plugin: 'hiBeaver' hiBeaver { //turn this on to make it print help content, default value is true showHelp = true //this flag will decide whether the log of the modifying process be printed or not, default value is false keepQuiet = false //this is a kit feature of the plugin, set it true to see the time consume of this build watchTimeConsume = false //this is the most important part modifyMatchMaps = [:] } 然后，重新编译一下项目，会先去jitpack下载这个插件，开始编译后可以看到Android Studio的右下角的Gradle Console中，多输出了以下内容： 如果你看到了和我一样的内容，那说明初步配置成功。可以看到，使用插件后会输出一段友好的帮助内容，还是中英文的，告诉我们可以直接拷贝作为初始配置，这个帮助输出也是可以关闭的。下面我们正式开始尝试Hook小米推送SDK，首先，找出其业务逻辑中的一个节点。首先，引入小米推送，这个过程不赘述了，blablabla，引入成功！众所周知，使用小米推送需要先在代码中调用如下： MiPushClient.registerPush(this, APP_ID, APP_KEY); 这个代码应该会调起本地长连接的建立、注册服务器等流程。假如我们出于学习的目的，想研究其中的流程，试举一例，先从查看其反编译的代码开始，找一个切入的节点，如下：首先进入查看MiPushClient.registerPush这个方法: 在initialize的方法中，找到一段逻辑如下： 进入a方法，来到了这个类：com.xiaomi.mipush.sdk.u中，发现： 下面如果我们想看看运行时前两个方法传入参数的值，就可以开始Hook了。该如何做呢？这个方法体内打Log输出所有的值吗？那样太麻烦了。我们可以这样做：首先在我们项目的源码里新建一个静态方法，包含两个参数，如下图： 其后，我们只要在a方法中加入一段代码，调用我们的静态方法，并传入我们想查看的两个参数即可。这就有赖于我们的hibeaver插件了，具体如何做呢？我们可以先看看之前的帮助内容： 里面有提到一个the most important par，最重要的部分。没错，这个插件的核心就在于配置这个类型为Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;的传入量。首先我们配置如下： 然后重新编译，发现输出log如下： 这样就输出这个u类的所有方法信息，用于后面进行配置。再来看看刚刚的方法a： 是一个泛型方法，众所周知泛型只存在于编码阶段，编译后是没有泛型的，其实传入的参数的实际类型为org.apache.thrift.a，最终找到其方法描述应该为： (Lorg/apache/thrift/a;Lcom/xiaomi/xmpush/thrift/a;ZLcom/xiaomi/xmpush/thrift/r;)V 进一步配置： 然后重新编译，console输出新增revist部分，如下： 最后，我们增加如下代码，在其中植入我们的代码，调用刚刚的静态方法，并把对应值传递过来：终极配置： 以上代码就不做详细解释了，相信有基础的都能明白，然后编译查看输出: 下面我们debug一下，看看是否可以成功在registerPush的运行流程中调用到我们的方法： 上面可以看到，无论是debug还是log输出都可以抓到想要的参数了。因为小米推送是商业产品，这里不便于探索太多内容，但是通过hibeaver这个插件可以比较方便的进行类似的研究。 总结hibeaver所体现的技术，并没有特别大的价值，仅仅作为工具来讲比较方便易用，有助于学习研究Jar中的逻辑，和学习应用Java汇编码。除此之外，还有几个应用场景：1.修改引用SDK中的一些bug或者提高其效率；2.获得必要的SDK的一些关键调用时机，通过hook建立回调；3.欺骗SDK、关闭或减少SDK中不受控制的网络传输。不一而足，还是很有趣、很有想象空间的。目前存在的问题，如下，这个除了偶尔同步报错之外没有影响，编译正常： 还有，如果仅仅修改了gradle文件，不会触发更新，需要在代码上也进行任意修改方生效。 关于项目hibeaver完全开源，大家可以自行查看其中代码，有大量的中文注释，对于学习gradle插件开发大有裨益。github开源项目地址：https://github.com/BryanSharp/hibeaver","link":"/2017/02/26/tech/java/java-classcode-edit-toolkit/"},{"title":"一次Java字节码插桩实战","text":"理解本文需要一定的Java字节码指令基础，可以阅读笔者的另一篇文章：大话+图说：Java字节码指令——只为让你懂 利用Android字节码插桩技术可以很方便地帮助我们实现很多手术刀式的代码设计，如无埋点统计上报、轻量级AOP等。下面我们就通过一次实战，把这门技术真正用起来。 奇葩需求假设有这样一个需求，我们需要在本项目工程的所有组件（Activity/Receiver/Service/Provider）的on系列生命周期类方法执行时，调用一个我们写好的方法，传入组件的实例对象，来对组件的相关状态进行监测，如何实现？ 一般的思路有两种： 通过Java继承体系，为我们实现的四大组件分别建立基类，在基类父方法里对监测方法进行调用。 通过Android API Hook技术，即通过动态代理等方法替换关键节点，抓住组件的节点方法并调用我们的监测方法。 上面的第一种方法比较麻烦，而且控制力较弱，也无法顾及我们所依赖的Jar或者aar中的组件，比如小米推送中自带的Service和Receiver，是完全无法触及的。第二种方法则比较强大，但是需要考虑兼容性问题，技术实现上的成本也比较高，毕竟有一些生命周期的节点不好找，难免焦头烂额。 本文对此的实战即通过字节码插桩，在class文件编译成dex之前（同时也是proguard操作之前），遍历所有要编译的class文件并对其中符合条件的方法进行修改，注入我们要调用的监测方法的代码，从而实现这个需求。 HiBeaver 是目前这方面比较完善的字节码插桩Gradle插件，目前最新的1.2.4版本支持通过通配符或正则表达式的方法来匹配目标类和目标方法，进行方法的批量插桩注入和修改，非常灵活易用。对于类似上文提出的需求，实现起来非常方便，唯一前提的仅仅是：知道所有组件的类的全名就可以了。 准备工作好，基于这些，正式开始实战，牛刀小试一下：首先建立一个工程，为便于演示，我们引入小米推送（接入方式不再赘述，详见小米推送文档），然后完善代码到如下状态： MainActivity内容很简单，注册了小米推送，有一个TextView点击后可以跳转到SecondActivity，仅此而已。具体如下： SecondActivity中一切从简： 至于DemoMessageReceiver这个类里完全依照小米推送接入文档中的配置，没有实质改动，不再贴出。注意到还有一个MonitorUtil的类，内容如下： 其中的monitorThis的方法就是我们打算在各个生命周期方法里插入的调用方法。 开始实战下面我们就开始实现开头处提到的需求：通过字节码插桩的方法，本工程里的所有组件的生命周期方法return之前调用我们的monitorThis方法，传入组件实例等信息作为参数。 首先，要引入HiBeaver插件：然后在项目的根build.gradle下面增加classpath如下： classpath 'com.bryansharp:hibeaver:1.2.4' 随后为我们工程的app/build.gradle增加如下配置： apply plugin: 'hiBeaver' import com.bryansharp.gradle.hibeaver.utils.MethodLogAdapter import org.objectweb.asm.ClassVisitor import org.objectweb.asm.MethodVisitor import org.objectweb.asm.Opcodes hiBeaver { modifyMatchMaps = [ //类名称匹配规则，*表示任意长度任意字符，|为分隔符，可以理解为或 '*Activity|*Receiver|*Service|!android*': [ //方法名匹配规则与类名类似，同时也支持正则表达式匹配（需要加r:）；adapter后为一个闭包，进行具体的修改 ['methodName': 'on**', 'methodDesc': null, 'adapter': { //下面这些为闭包传入的参数，可以帮助我们进行方法过滤，以及根据方法参数来调整字节码修改方式 ClassVisitor cv, int access, String name, String desc, String signature, String[] exceptions -&gt; //这里我们有了ClassVisitor实例，其实可以为类添加新的方法。 MethodVisitor methodVisitor = cv.visitMethod(access, name, desc, signature, exceptions); MethodVisitor adapter = new MethodLogAdapter(methodVisitor) { @Override void visitCode() { super.visitCode(); //实例对象入栈 methodVisitor.visitVarInsn(Opcodes.ALOAD, 0); //下面两句我们将方法的名称和描述作为常量入栈 methodVisitor.visitLdcInsn(name); methodVisitor.visitLdcInsn(desc); //调用我们的静态方法 methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, //下面这个MethodLogAdapter.className2Path(String)为 // hibeaver插件提供的方法，可以将类名转为路径名 MethodLogAdapter.className2Path(&quot;bruce.com.testhibeaver.MonitorUtil&quot;), &quot;monitorThis&quot;, &quot;(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V&quot;); } } return adapter; }] ] ] } HiBeaver在类名和方法名的匹配上非常灵活，可以非常方便地实现批量匹配，除了完整匹配外，还支持通配符匹配和正则表达式匹配两种模式。通配符匹配模式中主要可以使用两种符号，即 | 和，表示任意长度（&gt;0）的任意字符，而|表示分隔符，这里可以理解为或。因此，上面的： *Activity|*Receiver|*Service 可以理解为，匹配任意全类名以Activity、Receiver或Service结尾的类。 一般来讲，我们的Android组件在命名上都会遵从这个规范，即组件类名以相应的组件名结尾，对于个别不遵从这个原则的，也可以通过|分隔符来把特殊情况纳入进去。 除此之外，如果存在更复杂的匹配规则，上述通配符已经无法满足，hiBeaver也支持正则表达式进行全类名匹配，只需要在表达式前加上“r:”就可以。比如： r:.*D[a-zA-Z]*Client 表示匹配符合“.*D[a-zA-Z]*Client”这个正则表达式的类名。 更进一步地，HiBeaver 未来 还将支持根据类的继承关系进行匹配，比如： &gt;ext&gt;android.support.v4.app.FragmentActivity 表示匹配所有继承android.support.v4.app.FragmentActivity的类，而： &gt;imp&gt;android.os.Handler.Callback 表示匹配所有实现android.os.Handler.Callback接口的类。不过，目前这两个特性还没有支持，仅提上了其项目的issue中。回到刚刚的配置中，下面的methodName方法的匹配规则与类名匹配用法一样，**和*是一样的效果，on**即表示名字以on开头的方法。好了，编译运行工程，过程中在Gradle Console中可以看到hibeaver进行字节码插桩输出如下（局部）： 程序运行起来，插桩成功，成功调用了monitorThis方法，但赫然发现输出如下： 调用了三个onCreate和若干的onCreateView！这是为什么？我们的MainActivity也没有这个onCreateView的方法啊！ 结合之前Gradle编译日志，在仔细一琢磨，突然明白了： 原来，我们的*Activity规则会匹配所有的Activity结尾的类，包括一些android v4支持包中的类，什么AppCompatActivity、FragmentActivity等继承链上的Activity通通被hook了一遍，难怪会有那么多输出了，可辛苦了我们的monitorThis方法。 既然如此，如何是好？针对于当前的需求，我们当然不想匹配v4包里的组件类。 所幸的是，HiBeaver中还有另一种排除匹配，运用!符号改造如下即可： *Activity|*Receiver|*Service|!android* 这样就表示，匹配前三种之一（或的关系）且不匹配第四个android*的全类名。改好后，再次运行，并点击跳转到SecondActivity： 可以看到log输出一下子少多了，证明没有再注入v4包里的类，同时，小米的组件也被正常注入了，我把网断掉，可以看到小米的Receiver被唤起： 再开启调试，打开网，断点也可以正常进入： 同时，每次HiBeaver进行字节码插桩后还会把修改过、实际使用的字节码保存到build/HiBeaver目录下，以便于查看： 如下图为修改后的MainActivity类： 修改后的小米推送里的某Receiver: 这样，无论是进行节点控制还是研究其运行机制都大大地方便了。 HiBeaver","link":"/2017/03/11/tech/java/jvm-classcode-practice/"},{"title":"Aspect-Oriented Programming in Android","text":"What is AOP?​In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut“ specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. The Microsoft Transaction Server is considered to be the first major application of AOP followed by Enterprise JavaBeans.​ Similar concepts: Proxy pattern Interceptors &amp; Filters Basic terminology: ConcernsAdvice, Pointcut and Join Point compose an Aspect:​ Primary concerns Secondary and Cross-cutting concerns Joint point Advice Pointcut Described by expressions: AspectJ Pointcut expressions Described by annotations Aspect Weaving AOP processor i.e. the Weaver Weaving timing: At run-time At load-time At compile-time Why do we need AOP?In a word, AOP is an evolution and supplement of OOP General Benefits: Increase modularity and logic clarity and concentration Less tangled code Shorter code Easier application maintenance and evolution Applications that are easier to debug, refactor and modify Code is more reusable in a shape of aspect An idea of resolving complicated process Application of the implementation: help to hook and inject third-party SDKs (So as to block malicious method calls or to monitor or study crucial process, like network communication) Mastering AspectJ: Aspect-Oriented Programming in Java, Joseph Gradecki, Nicholas. WILEY Practice Areas: Logging Permission check Performance Profiling Data check Thread status check How to adopt it? AOP Core Implementation Basic Techniques Weaving time Dynamic Proxy Pattern Java Proxy API Run-time DexMaker DexClassLoader API Load-time AspectJ Java Bytecode Manipulation Compile-time AspectJ: AOP standard extension, the open-source projects Maintained by Eclipse Foundation https://git.eclipse.org/c/aspectj/org.aspectj.git/ Dark side: True Magic or Fancy Stuff?“AOP considered harmful”: Makes control flow obscured: Implicit AOP to Explicit AOPAffect method stack trace: increase its depthRequire additional weaving time “AOP Considered Harmful”. uni-karlsruhe.de. 23 March 2016. Mitigation: prevent invisible code, better use Annotation and combine with DI technique Appropriate use: it’s only a supplement and a way to simplify complicated structure and reuse components, not a software design principle. More about AspectJPointcut expression: 1execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?) https://docs.spring.io/spring/docs/2.0.x/reference/aop.html https://howtodoinjava.com/spring-aop/aspectj-pointcut-expressions/ As the return value is ignored, the method must be declared as void return. Pointcut described by annotation: Annotated Joint Point: the primary concern. Check log outputs: Other Possible Scenarios: @ProfilerTracker(BuildConfig.DEBUG) @CallFrequencyLimit @CheckPermission(“”), @RequirePermission(“”) How does it work? Technique Anatomy:​​​​​​​​​​​​​​Weaving in Build-time: Next session: Java Bytecode manipulation. Other implementations: Based on the idea of AOP and DI (Dependency Injection), lots of Android opensource frameworks are created to help improve the code structure and modularity. AndroidAnnotations Hugo OTHER REFERENCEShttps://fernandocejas.com/2014/08/03/aspect-oriented-programming-in-android/","link":"/2018/12/27/tech/java/aop-in-android/"},{"title":"白话Java字节码指令","text":"前言随着Java开发技术不断被推到新的高度，对于Java程序员来讲越来越需要具备对更深入的基础性技术的理解，比如Java字节码指令。不然，可能很难深入理解一些时下的新框架、新技术，盲目一味追新也会越来越感乏力。 本文既不求照本宣科，亦不求炫技或著文立说，仅力图以最简明、最形象生动的方式，结合例子与实战，让小白也能搞懂这门看似复杂的技术概念。 单刀直入闲言碎语不要讲，先表一表，什么是Java字节码指令？简而言之，Java字节码指令就是Java虚拟机能够听得懂、可执行的指令，可以说是Jvm层面的汇编语言，或者说是Java代码的最小执行单元。有点Java基础的人一定都知道，javac命令会将Java源文件编译成字节码文件，即.class文件，其中就包含了大量的字节码指令。因此可以将javac命令理解为一个翻译命令，将源文件翻译成Jvm可以执行的指令。那么最直观的探究方法莫过于直接对比翻译前后的内容。具体如何对比呢？就不得不用到Java为我们一直默默提供的一项利器，javap命令，它可以解析字节码，将字节码内部逻辑以可读的方式呈现出来。为了紧贴实战，我们直接在新建的Java工程里，写这样一个UserServiceImpl类，里面包含几个由简单到复杂的方法，以及一个名为serviceType的属性： 如图，以上方法，复杂度由低到高依次为：getServiceType&lt;setServiceType&lt;genToken&lt;login（以及一个实例代码块），后面我也会按照这个顺序解读其字节码指令的执行逻辑。下面我们编译工程，然后在下图所示的目录(gradle编译工程)找到该类的字节码文件： cd到这个路径下，运行javap命令： 1javap -v -p UserServiceImpl 就可以观看到翻译版的Java字节码的胴体了！这里的-v意思是啰嗦模式，会输出全面的字节码信息，而-p是指涵盖所有成员。原字节码信息输出内容较多，基于本文的目标，取其一方法的内容，整理如下图：方法1，getServiceType()： 这个getServiceType的方法应该是再简单不过的Java代码，翻译成字节码后也变成了三行，我们先来简单推理一下：第一句，aload_0不知所云，索性略过；第二行，getfield应该可以读懂，后面这个#8似乎是他的参数（实际上是对常量池的引用），//后面注释的内容是javap给我们加上的，意思应该是#2的指向是”Field serviceType:Ljava/lang/String;”这个内容。所以getfield这一行就是取出serviceType这个字段喽，so easy。areturn肯定就是return的意思，a的含义也先略过不表。总之就是取出serviceType字段然后return喽。 那么现在的问题就是aload_0是什么意思了，看似多余，但仔细思考一下，似乎之前给getfield指令传入了“Field serviceType:Ljava/lang/String;”这样一个并不完整的参数，其后半部分的“Ljava/lang/String;”仅仅表示这个serviceType字段的类型是String，也就是说，整个参数里没有说是取的谁的serviceType字段啊！究竟是get谁的feild呢？ 由此可以想到：aload操作一定是在为getfield指令准备了一个主体。 实际上，再结合下面的局部变量表，aload_0中的0正是局部变量表里的Slot 0的含义。意思是将局部变量表里的Slot 0的东西压入操作数栈，这个Slot 0里的东西name正是this，也就是UserServiceImpl的实例，即getfield的主体。 大戏上演好了，对于小白同学有些陌生的概念来了，啥是操作数栈？啥是局部变量表？其实这两个东西理解好了，关于虚拟机指令就懂了一大半了。那么，不妨删繁就简，由易入难，先讲一个这样的故事，故事起名叫： Java方法之创世纪话说Jvm大帝是神之旨意的履行者（Jvm大帝就是虚拟机，神就是开发者，神之旨意是开发者写好并编译后的字节码…），当Jvm大帝带领Java世界运行进入了一个新的方法后，会为这个方法在栈内存大陆上创造两个重要的领域：局部变量表和操作数栈。 要有栈。要有表。神说。 依照神之旨意，jvm大帝创造的局部变量表里一般会包含this指针（针对实例方法，静态方法当然无此）、方法的所有传入参数和方法中所开辟的本地变量。 那么操作数栈是干嘛用的呢？ 我们再引入另外一个比喻，如果把运行Java方法理解为拍戏，那么局部变量表里的各个局部变量就是这部戏的核心主角，或者说领衔主演，而操作数栈正是这部戏的舞台。所谓操作数栈搭台，局部变量唱戏，是也。那么aload_0就是告诉Jvm导演（大帝已沦落为导演），请0号演员this同志登台（压栈），演后边的本子。当然了，这个比喻并不完全恰当，因为操作数栈并不是“舞台”的结构，而是栈的结构。但是这个比喻可以很好地说明局部变量表和操作数栈之间的关系，以及aload_0的作用。 下面我们用一张图来演示一下getServiceType这个小剧本桥段所导演的故事： 好吧这部剧虽然短的可怜，但已经基本把指令、操作数栈和局部变量表三者的关系演绎了出来。值得注意的是，getfield这条指令对操作数栈进行了复合操作，其流程可以示意如下图： 后面我们将要接触到的许多指令都如此，指令内部执行了弹出—&gt;处理—&gt;压回的流程。下面我们就来分析一个相对复杂一点的方法，setServiceType(String)，如下图： 这里我们看到，变化主要有，指令多了一行，多进行了一次aload，getfield变成了putfield，areturn变成了return，仅此而已。另外领衔主演也就是局部变量表里多了一位，也就是方法的传入参数serviceType字符串对象了。其情节如下： 这里，putfield只弹出栈内的操作数，而没有向操作数栈压回任何数据，而且执行putfield之前，栈内元素的位置也必须符合“值在上，主体在下”要求。而最后的return仅表示方法结束，而不会像areturn一样返回栈顶元素。这也印证了setServiceType(String)方法没有返回参数。 融会贯通相信有了以上的讲解，大家对指令、操作数栈、局部变量表三者的运作关系有了一定认识，为了后边能够分析更复杂的方法，这里必须概括性地讲解一下更多的Java字节码指令。虽然Java字节码指令非常多，但其实常用的不外乎几个类别，先从这几个常用类别入手理解，便可渐入佳境。关于字节码指令的分类，可以从两个维度进行：一是指令的功能，二是指令操作的数据类型。我们先从功能说起，指令主要可以分为如下几类： 存储和加载类指令：主要包括load系列指令、store系列指令和ldc、push系列指令，主要用于在局部变量表、操作数栈和常量池三者之间进行数据调度；（关于常量池前面没有特别讲解，这个也很简单，顾名思义，就是这个池子里放着各种常量，好比片场的道具库） 对象操作指令（创建与读写访问）：比如我们刚刚的putfield和getfield就属于读写访问的指令，此外还有putstatic/getstatic，还有new系列指令，以及instanceof等指令。 操作数栈管理指令：如pop和dup，他们只对操作数栈进行操作。 类型转换指令和运算指令：如add/div/l2i等系列指令，实际上这类指令一般也只对操作数栈进行操作。 控制跳转指令：这类里包含常用的if系列指令以及goto类指令。 方法调用和返回指令：主要包括invoke系列指令和return系列指令。这类指令也意味这一个方法空间的开辟和结束，即invoke会唤醒一个新的java方法小宇宙（新的栈和局部变量表），而return则意味着这个宇宙的结束回收。 如下图，展示了各类指令的作用： 再从另外一个维度，即指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型： a对应对象，表示指令操作对象性数据，比如aload和astore、areturn等等。 i对应整形。也就有iload，istore等i系列指令。 f对应浮点型。 l对应long，b对应byte，d对应double，c对应char。 另外，ia对应int array，aa对应object array，da对应double array。不在一一赘述。 了解了以上内容，我们再去看最后几个方法，应该就会容易理解很多了。下面我们就直捣黄龙genToken这个方法(图中的颜色暗示了指令和方法调用之间的关系)： 这个过程简单解读如下： new一个StringBuilder对象（在堆内存中开辟空间），并将其引用入栈，用于实现加号连接字符串功能（相当于C++中的运算符重载）； dup复制栈顶的刚刚放入的引用，再次压栈，这时栈里有两个重复的内容，深度为2； 调用并弹出栈顶StringBuilder引用对象的方法，栈深度为1； （绿色部分）调用UUID.randomUUID()静态方法，结果压栈后弹出调用String的toString方法，再压栈，栈深度为2； （黄色部分）将”-“和””字符压栈，此时栈深度为4，弹出（栈顶3个元素）调用replace方法，结果压栈，深度为2；6.调用StringBuilder对象的append方法，结果压栈，深度为1； （蓝色部分）将参数user压栈并调用hashCode方法，结果压栈，深度为2； 调用StringBuilder对象的append方法（此处和上面的append调用共同完成了加号功能，在图中为红色部分），结果压栈，深度为1，再调用toString方法后结果压栈，深度为1； areturn返回栈顶对象。 再看这个包含if跳转的方法login： 如上图，图中已经说明的比较全面了，不再赘述。值得一提的是，Java的这种基于栈结构的指令，在设计上有一种非常简洁的美感，指令与指令之间并没有较重的依赖，每条指令仅仅与操作数栈等领域内的数据发生关系，充满着某种平衡与秩序感。因此也必须注意，几乎每条指令的运行都有其前提，比如在invokevirtual或invokespecial指令执行前，必须保证操作数栈内提前按顺序压入好所需的操作数，否则就会发生问题。关于最复杂的onCreate方法，就不再啰嗦解读了，读者可以前往我的github上的对应demo repo，进入tutorial分支，拉取源码和教程资源，或者自己写demo体验这一完整过程。 后话关于实战，一是可以学习使用强大开源工具ASM.jar；二是，可以参考本人的另一篇文章：Java字节码修改神器HiBeaver：黑掉你的SDK以及一次Android字节码插桩实战，利用hibeaver这个助手，开发者可以非常灵活地对字节码进行修改，插入指令，hook代码，甚至建立一些简单的AOP框架，对于Java字节码学习大有裨益。hibeaver完全开源，github项目地址：https://github.com/hydraxman/hibeaver 祝玩的愉快！本文如有不妥之处，欢迎交流指正。 另外，本文为了尽可能地简明生动、直入核心，简化了很多概念和细节，读者须知实际情况的更为复杂。但相信在理解了本文以后，就可以抓住Java字节码指令的核心理念，也就算扣开虚拟机学习的大门并可以开始读书精进了。下面盗图一张（后有出处），可作拓展： 关注最新技术分享和资讯：TechHome，技术人之家！","link":"/2017/03/07/tech/java/jvm-classcode-tutorial/"},{"title":"Gradle插件开发秘籍之断点调试（基于Intellij）","text":"Gradle插件开发这件事说大不大说小不小，但是对于有一定体量规模的Java项目来讲，从插件开发入手来思考解决问题，有的时候能找到意想不到的法门。所以说这是一门锦上添花的手艺。 废话少说，相信对于很多Gradle插件开发朋友们，开发过程中很大的一个痛点就是，插件的调试很痛苦，下面我就分享一下在这方面的心得。 1. 增加运行参数好吧这个很菜鸟，比如很常用参数的是–stacktrace，报错后会打印出堆栈信息 2. Log输出控制这个不多说了，println就可以了，可以自己设置一些分级和flag。 3. Attach a debugger！先上最终效果图： 如上图，是可以正常地设置断点调试和step into和step out、resume等等。实现办法和原理：大家都知道Gradle基于Groovy，而Groovy其实就是Java，所以也同样遵循JDWP协议，只是这个技巧似乎在国内的文章中没有人出来分享，我就在此分享给大家。首先，在你要执行gradle命令的环境中加入如下环境变量（以Linux、MacOS为例）： export GRADLE_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot; 其中，address等号后面的参数就表示debugger要监听的端口，这里我们设置为5005。然后执行gradle或gradlew任务，会发现有如下提示： 这时任务就不会继续执行了，挂起等待Debugger的handshake！这时我们启动IDE，以Intellij为例，打开我们的gradle插件项目（包含正在运行的插件源码的项目），然后找到工具栏的执行区域，进入如下： 在界面里添加一个运行项，Remote： 需要配置的最核心参数就是如图所示的端口号，就是上文中的address: 注意到下面有一个Search sources using …意思是从什么范围查找源码，保持默认就好了，这个debugger收到JDWP消息后会从当前工程中搜索源码，基于当前的源码进行与gradle命令行中的JDWP agent进行交互。 OK，如果插件源码中打好断点，执行到代码时就会挂起在相应位置了，大部分调试功能都很好使，大家可以尝试一下！这个技巧还是比较简单的，大家只要了解一下JDWP的核心原理，就可以理解上述过程了！ 时间有限，如有不妥，欢迎指正！","link":"/2017/02/06/tech/java/gradle-debug-tips/"},{"title":"测试类书籍阅读笔记综述","text":"近期阅读和重读了一些测试相关的书籍，深感测试也是一门工程学问。汇总综述所学于此。 阅读书目 书名 出版时间 阅读状态 快评 ISBN 软件测试 2006.4 笔记待整理 不用仔细看，太旧 9787111185260 微软的软件测试之道 2009 阅读中 知识梳理 9787111277538 Google软件测试之道 2013.10 尚未开始 值得阅读 9787115330246 探索式软件测试 2010.4 尚未开始 快速阅读 大话软件测试 2018.11 笔记待整理 快速阅读 软件测试的艺术 2012.3 阅读中 值得阅读 腾讯Android自动化测试实战 2016.9 阅读中 主要看技术框架 构建之法 2015.3 阅读中 学习写作方法, 要看 9787115460769 测试驱动开发 2004.3 笔记待整理 快速阅读 测试驱动开发的艺术 2010.11 尚未开始 值得阅读 A Practical Guide to Testing in DevOps 尚未开始 Mobile Test Automation with Appium 尚未开始 探索吧！深入理解探索式软件测试 2014.1 尚未开始 9787111451587 全程软件测试 2019.1 尚未开始 9787115496560 颠覆完美软件 2015.7 尚未开始 9787121258619 大话移动APP测试 2014.7 尚未开始 快速阅读或者不读 9787302368793 单元测试的艺术 2014.8 尚未开始 快速阅读 9787115360359 知识梳理测试分类： 功能测试 非功能测试 书摘 构建之法我成为了一名职业程序员，但是我发现所有的算法别人都已经实现了，我只要调用就可以。似乎我们公司的软件与数据结构、算法的关系都不大。那我当初辛辛苦苦学习的数据结构和算法有用么？如何区分一个好的程序员和不好的程序员呢？ 体会：书中举的四则运算的例子做深了以后可能还涉及一些相对比较复杂的算法，可是在现实中接触到的系统很多是业务驱动的系统，用户量可能不会超过2000，CRUD，业务复杂流程交给成熟的工作流系统去做了，CRUD是很简单的数据库表操作，数据库操作有现成的框架，前端有现成的框架，后端有现成的框架，程序员要做的事情就是熟悉现有的框架，完成相应的业务模块的开发。典型的开发过程是：拿到一个业务需求，建模-&gt;转换成实体类-&gt;对这个实体类的CRUD-&gt;拖出一个工作流流程图-&gt;把流程涉及的表单用前端框架做好-&gt;调用封装好的工作流的方法实现业务流程操作。在整个过程中，似乎用不到任何复杂一些的算法和数据结构（最多可能会考虑一下实体类之间一对多之间的关系），但是仍旧有些程序员做的很好，bug非常少，功能也很稳定，有些bug很多，这样可以区分去好的程序员和不好的程序员么? xinz: 从老板/经理的角度来看， 你提到的稳定易用的 CRUD 模型是不是正和他们的意愿？ 就像建房子，并不是每一个房子都是世界级的挑战，前人从来没有碰到过。 把基本的工作不断做得更完美， 就是很好的工程师。 把所有的错误记在一个“我常犯的错误”表中，作为以后自我复审的第一步。 什么是好的软件？一些同学认为，所谓好软件，就是软件没有缺陷（Bug），所谓软件工程，就是把软件中的Bug都消灭掉的过程。这的确是抓住了软件工程的一个要素。和软件打交道的专业人士都知道软件有“Bug”（缺陷），软件团队的很多人都整天和Bug打交道，Bug的多少可以直接衡量一个软件的开发效率、用户满意度、可靠性和可维护性。 ——P15 很多人认为有Bug就是质量不合格，没有Bug就是质量完美，其实这也未必。我们在大街上看到很多小汽车，这些汽车出厂时都通过了各自的质量检测，符合行业的质量标准。但是你问路人哪些车的“质量好”，很多人会告诉你有些车的质量大大好于另外一些车，那为什么还有人买那些质量“不够好”的汽车呢？对于某些顾客来说，某一类的汽车满足了他们的需求，他们就会买。如果销售人员不经市场调研胡乱推销自己公司的汽车，最后销量未必理想。 市面上有这么多不完美的产品，软件团队为什么还要把这些不完美的软件发布出来呢？为什么不能等到它们完美之后再发布？**软件工程的一个重要任务，就是要决定一个软件在什么时候能“足够好”，可以发布。 既然代码复审能发现这么多问题，有这么好的效果，如果我们每时每刻都在代码复审的状态，那不是很好么？事实上，极限编程（Extreme Programming）正是这一思想的体现——为什么不把一些卓有成效的开发方法用到极致（Extreme），让我们无时无刻地使用它们？ ——p84页 极限编程对工程师提出了更高的要求。这种要求不关乎技术水平，也不关乎学历水平或工作经验。这种要求是对一个人的心智、道德修养的更高要求。结队编程中，编码不再是私人的工作，而是一种公开的“表演”。程序员的代码、工作方式、技术水平都变得公开和透明，这也许是一些人不喜欢这一方式的原因。 ——P87 用户体验设计的一个重要目的就是要降低用户的认知阻力（Cog-nitive Friction），即用户对于软件界面的认知（想象某事应该怎么做，想象某操作应该产生什么结果）和实际结果的差异。我们来看一个具体的例子，如果用户（一个生活在中国二线城市，有高中文化水平，有基本计算机基础的成年人）要在一个文稿中写居中的一句话，在下表所列的各种工具中，用户是怎么才能做到的。 倘若认知阻力大，学习曲线就会比较陡；但是经过学习和练习，如果用户适应了新的认知模式，工作效率便会有较大的提高。 一个成熟的软件工程师应该能够降低任务交付时间的标准方差。 软件领域可以分为两个方面：一方面是技艺创新的大爆发；而另一方面是坚持不懈的工程工作，包括软件的改善、维护和测试等，这一方面占了 90%~95% 的比例。 1）软件构建：除了代码和静态数据，还有各种文件和数据来描述各个程序文件之间的依赖关系等；2）源代码管理/配置管理：保证代码的平台兼容性、配置兼容性等；3）质量保障（软件测试）：保证软件的质量在修改过程中可以不断提高，或者至少可以保持；4）项目管理：软件维护和服务运营5）生命周期：以上称为软件的生命周期SLC 对于后来者，一个赶上的办法就是把别人的优势变成大路货（Commodity）。 牛人主导的项目，往往会大起大落。PM 主导的产品中，“不犯大错”成了一个特点，微软的很多产品在长期竞争中，靠“不犯大错”，从第三版开始，赶上并超越竞争对手。这也是了不起的能力。 压力测试严格地说不属于效能测试，压力测试要验证的问题是: 软件在超过设计负载的情况下能否仍能返回正常结果，没有产生严重的副作用或崩溃。 有人说一个人就可以快速成长为一名全栈工程师，这让我想起街头卖艺的单人乐队(One-man-band), 他们什么都会一些，可以很快地演奏一些曲子。 术产品的发展周期（萌芽-&gt;成长-&gt;成熟-&gt;衰退-&gt;结束） 软件工程是把系统的、有序的、可量化的方法应用到软件的开发、运营和维护的上的过程。软件工程包括下列领域：软件需求分析、软件设计、软件构建、软件测试和软件维护。软件工程和下列的学科相关：计算机科学、计算机工程、管理学、数学、项目管理学、质量管理、软件人体工学、系统工程、工程设计和用户界面设计。 设想和目标 我们的软件要解决什么问题？是否定义得很清楚？是否对典型用户和典型场景有清晰的描述？ 是否有充足的时间来做计划？ 团队在计划阶段是如何解决同事们对于计划的不同意见的？用户量、用户对重要功能的接受程度和我们事先的预想一致么？我们离目标更近了么？有什么经验教训？如果历史重来一遍，我们会做什么改进？计划 你原计划的工作是否最后都做完了？如果有没做完的，为什么？ 有没有发现你做了一些事后看来没必要或没多大价值的事？ 是否每一项任务都有清楚定义和衡量的交付件？ 是否项目的整个过程都按照计划进行？ 在计划中有没有留下缓冲区，缓冲区有作用么？ 将来的计划会做什么修改？（例如：缓冲区的定义，加班。）我们学到了什么？如果历史重来一遍，我们会做什么改进？资源 我们有足够的资源来完成各项任务么？ 各项任务所需的时间和其他资源是如何估计的，精度如何？ 测试的时间、人力和软件/硬件资源是否足够？对于那些不需要编程的资源（美工设计/文案）是否低估难度？ 你有没有感到你做的事情可以让别人来做（更有效率）？有什么经验教训？如果历史重来一遍，我们会做什么改进？变更管理 每个相关的员工都及时知道了变更的消息吗？ 我们采用了什么办法决定“推迟”和“必须实现”的功能？ 项目的出口条件（Exit Criteria——什么叫“做好了”）有清晰的定义么？ 对于可能的变更是否能制定应急计划？ 员工是否能够有效地处理意料之外的工作请求？我们学到了什么？如果历史重来一遍，我们会做什么改进？设计/实现 设计工作在什么时候，由谁来完成？是合适的时间，合适的人么？ 设计工作有没有碰到模棱两可的情况，团队是如何解决的？ 团队是否运用单元测试（Unit Test）、测试驱动的开发（TDD）、UML或者其他工具来帮助设计和实现？这些工具有效么？ 什么功能产生的Bug最多，为什么？在发布之后发现了什么重要的Bug？为什么我们在设计/开发时没有想到这些情况？ 代码复审（Code Review）是如何进行的，是否严格执行了代码规范？我们学到了什么？如果历史重来一遍，我们会做什么改进？测试/发布 团队有没有测试计划？为什么没有？ 有没有做过正式的验收测试？ 团队是否有测试工具来帮助测试？ 团队是如何测量并跟踪软件的效能的？从软件实际运行的结果来看，这些测试工作有用么？应该有哪些改进？ 在发布的过程中发现了哪些意外问题？我们学到了什么？如果历史重来一遍，我们会做什么改进？总结：你觉得团队目前的状态属于CMMI中的哪个级别？你觉得团队目前处于萌芽/磨合/规范/创造阶段的哪一个阶段？你觉得团队在这个里程碑相比前一个里程碑有什么改进？你觉得目前最需要改进的一个方面是什么？引自 15.3 事后诸葛亮会议 Google软件测试之道在测试上难以自动化的软件，很难成为好的软件。 除此之外，安排好优先级，寻找小成本大回报的自动化项目。一定要记住自动化并不能解决所有问题，尤其是前端项目和设备测试。 我首先会让我的团队思考，“对被测系统来说，什么是最为重要的东西？”对搜索来说是性能，对新闻来说是时效性，对地图来说是综合性和完整性。每个应用都有其最重要的属性。类似的，对系统基础架构来说，数据完整性对存储最为重要，可扩展性对网络系统最为重要，利用率对任务管理系统最为关键。当你分清了你要测试的特定产品的关键因素以后，就要把你的大部分精力集中在检验系统的核心能力是不是能够满足这些关键属性要求上。 当这些重要的事情搞定以后，再去关心那些简单的事情（用户界面这些锦上添花的东西）。还要关注那些核心的不容易改动的方面（如性能设计），而不对那些很容易修改的方面花费太多精力。如果你过早报告关于字体的bug，我就会担心你是不是没有搞清楚事情的优先次序。 质量不等于测试。当你把开发过程和测试放到一起，就像在搅拌机里混合搅拌那样，直到不能区分彼此的时候，你就得到了质量。 SET编写代码，通过这些代码提供的功能让SWE能够自己测试他们的功能。多数测试代码是由SWE完成，SET存在的目的就是保证这些功能模块具有可测试性，并且响应的SWE还可以积极的参与到测试代码的编写中。 我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。 如果能够自动化，并不需要人脑的睿智与直觉来判断，那就应该以自动化的方式实现。 通过使用定位点击的验证方式、录制技术等可以把一些手动测试转变成自动化测试，这些自动化测试在每次建立之后都会重复地回归运行，而手动测试更倾向于关注于新功能。 Google测试成功的关键是什么？不要招聘太多的测试人员，写代码的开发人员也承担了质量的重任。 开发和测试并肩齐驱。Google能用如此少的专职人员的原因，就是开发对质量负责。这意味着质量更像是一种预防行为，而不是检测。质量是开发过程的问题，而不是测试问题。 开发团队在寻求测试帮助的时候，有义务让测试人员相信他们的产品是令人兴奋且并充满希望的。在Chrome OS的开发总监给我们介绍他们项目、进度和发布计划时，我们也要求提供当前已有的测试状态、期望的单元测试覆盖率水平、以及明确在发布过程中各自承担的责任。 mock对象是指对外面依赖系统的模拟，在运行时刻可以根据假设的需求提供期望的结果。fake对象是一种虚假的实现，内部使用了固定的数据或逻辑，只能返回特定的结果。 探索吧！深入理解探索式软件测试测试的本质就在于此：设计一个试验以便收集经验证据，由此解答与风险相关的问题。 探索式测试就是同时进行学习、测试设计和测试执行。 探索时，想到某个测试之后就要立刻执行。 这一点至关重要：除非你执行这些测试，不然的话，你怎么知道接下来还会冒出些什么问题等你去调查呢。 软件测试软件测试工程师不负责软件的质量！医生测量体温不能退烧、气象专家测量风速不能阻止阻止风暴，同样软件测试工程师寻找缺陷并不能使质量低劣的产品变好！软件测试工程师只能报告事实、提供数据。即便测试工程师竭尽全力使发现的bug都得以修复，也不能使质量本身低劣的产品变好，质量不是靠测试来解决的。 持续的培训、充分论证的设计、经过业界论证的开发方法、持续保障的流程等，都能减少bug。 只有至少满足下列5个规则之一才称发生了一个Bug： 软件未实现产品说明书（product specification）要求的功能。 软件出现了产品说明书指明不应该出现的错误。 软件实现了产品说明书未提到的功能。 软件未实现产品说明书虽未明确提及但应该实现的目标。 软件难以理解，不易使用，运行缓慢或者–从测试员的角度看–最终用户会认为不好。 软件测试员的目标是尽可能早地找出软件缺陷，并确保其得以修复。 次边界条件：2的幂，ASCII表等，默认值、空白、空值、零值和NULL 测试软件兼容性时选择程序的标准：流行程度、年头、类型、生产厂商。 优秀UI的7个要素：符合标准和规范、直观、一致、灵活、舒适、正确、实用。 DREAD Formula：潜在的危害、可反复性、可利用性、受影响的用户、可发现性。 Beta测试是将软件分发给选定的潜在客户群，让他们在实际环境中使用软件。Beta测试时寻找配置、兼容性和易用性缺陷的好方法，但对寻找普通软件缺陷表现很差。不能依靠Beta测试来代替实际测试。 测试计划的目的： 规定测试活动的范围、方法、资源和进度；明确正在测试的项目、要测试的特性、要执行的测试任务，每个任务的负责人，以及与计划相关的风险。 测试计划的最终目标是交流（而不是记录）软件测试小组的意图、期望，以及对要执行的测试任务的理解。重要的是计划过程，而不是产生的结果文档。 产品的质量和可靠性目标必须明确，必须绝对。 Alpha版本：意在对少数主要客户和市场进行数量有限的分发、用于演示目的的早期版本。 报告软件缺陷的基本原则：（1）尽快报告Bug（2）有效描述Bug（3）在报告Bug时不要做评价（4）对Bug跟踪到底，跟踪其生命周期 有效描述Bug：（1）短小（2）单一：一个报告只针对一个软件缺陷（3）明显且通用。使用简明易行的步骤来描述发现Bug的过程，分离Bug（4）可再现 计划测试用例的4个原则：组织、重复性、跟踪和测试证实。 分离和再现Bug（1）不要想当然地接受任何假设，记下所做的每一件事（2）查找时间依赖和竞争条件的问题（3）查找边界条件、内存泄露和数据溢出问题（4）状态缺陷仅在特定的软件状态中显露出来，重要的是事件的次序（5）考虑资源依赖性和内存、网络、硬件共享的相互作用（6）不要忽视硬件 严重性：Bug的恶劣程度，当用户碰到该缺陷时影响的可能性和程度1：系统崩溃、数据丢失、数据毁坏、安全性被破坏2：操作性错误、结果错误、功能遗漏3：小问题、拼写错误、UI布局、罕见故障4：建议 优先级：修复Bug的重要程度和紧迫程度1：立即修复，阻止了进一步测试2：在产品发布前必须修复3：如果时间允许应该修复4：可能会修复，但即使有此Bug产品也能发布 常用项目级Bug度量（1）将Bug按发现的功能区域进行划分（2）发现的Bug随时间推移的情况（3）随时间推移累计发现的Bug。Resolved/Fixed Bugs（4）需标明项目的进度和重大事件 软件质量保证人员的主要职责是检查和评价当前软件开发的过程，找出改进过程的方法，以达到防止软件缺陷出现的目标。 软件测试员不负责软件的质量，质量不是靠测试来解决的。 假设自己是客户；像黑客一样考虑问题。 产品说明书属性检查清单：完整；准确；精确，不含糊；前后一致；贴切；合理；代码无关；可测试性 状态测试的方法：（1）每种状态至少测试一次（2）测试最常见和最普遍的状态转换（3）测试最不常用的分置（4）测试所有错误状态及其返回值（5）测试随机状态转换 硬件配置测试：明确与硬件配置有关的特性。软件兼容性测试：测试程序之间不同的数据流动方式。 网站测试（1）首先建立状态表，把每个网页当做不同的状态，链接当做状态之间的连接线（2）通过大幅缩放浏览器窗口来检查文字布局问题（3）查找孤页，向网页设计人员索要网页清单 半聪明的猴子：记录行为日志，只在被测试软件商运行，具备崩溃辨认能力。聪明的猴子：会阅读软件的状态转换图，能够验证遇到的情况。 灰盒测试（gray-box testing）把黑盒测试和白盒测试的界限打乱了。仍然把软件当作黑盒来测试，但是通过简单查看（不是像白盒测试那样完整地查看）软件内部工作机制作为补充。 能力成熟度模型（CMM） 5级CMMI成熟度描述如下： 1级：初始的。该等级的软件开发过程是随意的，常常很混乱。项目成功依靠个人英雄的行为和运气。过程没有通用的计划、监视和过程控制。开发软件的时间和费用无法预知。测试过程与其它过程混杂在一起。 2级：可重复的。该等级成熟度的最好描述是项目级的思想。使用基本项目管理过程来跟踪项目费用、进度、功能和质量。以前类似的项目经验可以应用到当前项目当中。该等级有一定的组织性，使用了基本软件测试行为，例如测试计划和测试用例。 3级：定义的。该等级具备了组织化思想，而不仅仅是针对具体项目。通用管理和工程活动被标准化和文档化。这些标准在不同的项目中得到采用并得到证实。当压力增加时，不会放弃规则。当测试开始之前，要审查和批准测试文档和计划。测试团队与开发人员独立。测试结果用于确定软件完成的时间。 4级：可管理的。在该成熟度等级中，组织过程处于统计的控制之下。产品质量事先以量化的方式指定（例如，产品直到每1000行代码只有0.5个以下毛病时才能发布），软件在未达到目标之前不得发布。在整个项目开发过程中，收集开发过程和软件质量的详细情况，经过调整校正偏差，使项目按计划进行。 5级：不断优化的。该等级成为不断优化（不是“已经优化”）是因为它从4级不断提高。尝试新的技术和处理过程，评价结果，采用提高和创新的变动以期达到质量更佳的等级。正当所有人认为已经达到最佳时，新的想法又出现了，再次提高到下一个等级。 软件测试的艺术提出了软件测试的心理学和经济学。 测试是为发现错误而执行程序的过程 测试用例中一个必需部分是对预期输出或结果进行定义 程序员应该避免测试自己缩写的程序 编写软件的组织不应当测试自己编写的软件 应当彻底检查每个测试的执行结果 测试用例的缩写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和末预料到的输入情况 检查程序是否“末做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的” 应避免测试用例用后即弃，除非软件本身就是一个一次性的软件 计划测试工作时不应默许假定不会发现错误 程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比 软件测试是一项极富创造性、极具智力挑战性的工作 在代码检查进行时，主要进行两项活动： 由程序编码人员逐条语句讲述程序的软件结构。……换句话说，对着大家大声朗读程序，这种简单的做法看来是一个非常有效的错误检查办法 对着历来常见的编码错误列表分析程序 我们推荐的步骤是先使用黑盒测试方法来设计测试用例，然后视情况需要使用白盒测试方法来设计补充的测试用例 软件测试经济学 黑盒测试 不需要去了解程序的内部结构穷举输入测试是无效的软测经济学：要用有限的测例，发现最多的错误 白盒测试 穷举路径测试不可行： 问题1：不同逻辑路径测例数量可能达到天文数字 问题2：即使真的测试完所有路径，可能仍有错 1：程序不符合设计规范（比如设计的目的是向左，做的是向右） 2：程序缺少路径（已有的路径虽然没错） 3：数据敏感错误（如比较的是绝对值，但比的没有加| |） 1.测试是为了发现错误而执行程序的过程。正向测试验证功能，但核心内容是反向测试，发现错误。测试人员首先要直觉认为被测物有错误需要去发现。 2.从心理学观点论述了为什么开发人员不能做测试。以及如何逐渐一个合理的团队，最好是独立的测试部门。 3.能发现错误的测试用例才是成功的用例。 全部测试用例通过，不能作为测试结束的标志。给出了3个测试结束准则。 4.该书多次提到，任何方式方法都有局限性，需要对不同问题采取不同的方法。 5.调试（Debug）一章强调了用思考去解决问题，而非大量的print,trace和debugger的内存观察。有时人会偷懒而采取暴力调试，及不去思考，胡乱修改代码来猜测问题。调试方式也是启发式解决问题的方法。 6.两次提到“采集-分析-汇总-提高”。及开发、测试过程要留心去总结提高，建立项目和个人的 bug、易犯错误表，调试错误分析表等。 7.增量测试和XP方法: 做事先有计划，然后由小到大，一步一个脚印，后一步踩在前一步上。 8.测试过程有很多方法都需要经验和直觉。测试是个复杂的脑力劳动。 探索式软件测试总得来说，James 把手工测试的一些方法，假借旅游的名义，设计了一套漫游测试的理念，重点是这些理念所引发出来的不同角度的测试点的关注，所以和国内流行的等价类、边界值等等各种测试用例设计方法是一个目的，但是角度不同。 书中一共分 8 个正式的章节，3 个附录。 书中第 1 章用了 4 个曾经发生过的关于软件质量的例子，让我们理解什么是软件缺陷，并对软件缺陷造成的影响有简单的了解。 第 2 章介绍了软件缺陷的根源，以及各种缺陷预防和检测的策略，并引申出后面要讲的重点内容「探索式测试」。 第 3 章根据软件的各种属性，分别从输入、状态、代码路径、用户数据和执行环境这 5 个部分提出了对应的测试关注点，以及怎么考虑到这些关注点，角度总结的很不错，详细内容建议粗读，吸取里面的精髓即可。 第 4、5、6 章是真正的使用漫游测试的概念，把旅游中可能出现的场景同我们的软件测试点进行关联，从而让我们有一套完整的去考虑手工测试覆盖率的方法论，虽然有点晦涩，但还是推荐详细读一下第 4 章，并把里面的内容同我们现在的做法结合起来看看。 第 7 章总结了漫游与测试中的五个棘手问题，不得不佩服 James 的总结提炼能力，每个问题都总结的很到位，我们可以看看是否和我们当前工作中碰到的问题类似，如果是，James 刚好提供了漫游测试的解决方案。 第 8 章软件测试的未来，这个话题就像惯例一样的存在，当然，相对于在《Google 软件测试之道》里面的预测，这次的内容我认为简单看看就行了。 接着是附录，重点推荐下附录1，里面通过上山、巅峰和下山的比喻，详尽的描述了成功的软件测试职业生涯的完整面貌，一定要反复多读几遍，细嚼慢咽。 使用探索式测试并不是说不写文档。测试结果、测试实例和测试文档都会在运行测试时创建。这和普通测试在测试计划里预先编写好截然不同。用于记录探索式测试结果的最佳工具就是那些截屏软件和记录击键的软件。探索性测试处理这个问题的方法是计划、测试，然后再计划，每次前进一小步，试图以所有过去的知识和现在的信息，（就是怎样运行目标软件和测试结果得到的线索）来作为测试的指导。 微软的软件测试之道第3章 工程生命周期瀑布模式 瀑布模式是最常见的软件开发模式之一。在这种软件开发方式中，每一个阶段的结束同时也是下一个阶段的开始。 要求→程序设计→编程→测试→维护 好处：当你开始一个新的阶段的时候，前一阶段的所有工作都已完成，能够强制你在动手写程序之前尽可能多的进行思考和设计。坏处：不够灵活，不允许阶段的重复。 螺旋模式 “螺旋”是一个包含四个主要阶段的迭代过程： 确定目标（为项目的当前阶段确定和设定特定的目标）、 风险评估（确认主要风险、减少风险及应急计划。风险可能包括超支或资源问题）、 工程实现（是完成工作的阶段，包括需求、设计、开发、测试、等等）、 和下一迭代规划：对项目评估，并开始计划下一轮的“螺旋”。 重复使用原型来让风险最小化是螺旋模式的另一重要概念。初始模式构建于早起设计之上并接近最终产品的特性。在后续迭代过程中，原型可以帮助我们评估工程系统的优缺点和风险。 敏捷开发 特征： 频繁而短暂的迭代：敏捷团队致力于快速发布软件，并且有做到这一点的记录。 强调面对面的交流和协作：敏捷团队注重队员相互间和与顾客之间的交流。 对产品要求变化的适应力：短暂迭代允许他们频繁的对变化区分优先次序和应对。 贯穿适中的质量责任制：在敏捷开发团队里，单元测试广泛的为开发人员所用。很多人使用TDD（Test-driven Development, 即测试驱动的开发方法）。开发人员先写单元测试程序，然后在实现产品功能已通过测试的开发方法。 里程碑模式 里程碑进度计划建立了项目发布的时间表，也包含了关键的过渡安排和中期版本的时间表。它帮助每个团队了解整个项目的期望值和现状。 要完成一个里程碑，必须满足具体的、事先定义好的阶段结束标准。通常包括： 关键功能编程完毕。即使尚未完全测试，但关键功能已经实现。 中企测试目标达到。如代码覆盖目标或测试完成率目标达成。 BUG目标达到。如无第一类严重BUG或无当机的BUG。 非功能目标达到。如性能、负荷测试完成且无严重问题。 各阶段的标准随着每一个里程碑的推进而日趋严格，直到团队达到了最终完成产品的标准。 里程碑（或其它任何一种迭代模式）的另一个优点是，在每一个里程碑阶段中，团队都能通过一步步迈向发布而积累经验。而且每一里程碑发布的产品都是一个完整的产品，都可以用于大范围的试用。 宏观视野 代码→函数→产品功能→项目→产品线 流程改进 PDCA循环：计划、执行、检查、处理，循环。 第二部分 关于测试 第4章 软件测试用例设计的实用方法设计是一个在开始具体实现解决方案以前，系统的思考或计划这个解决方案的行为。认真仔细的计划和设计可以提高测试在其整个生命周期中的价值。 软件设计包括制定计划和解决难题。它包括对用户体验的预见和对解决方案以及备选方案的重要分析。 测试设计需要从计划和问题解决方面来决定做哪些测试，以及哪种测试在验证功能和确认错误路径处理得当上是最有效的。良好的测试设计通常从对软件设计的审查或批评开始。一个好的设计审查会对所有主要的设计决策中的各种备选方案做深度比较。 测试模板属性：名称、问题、分析、设计、预言、用例、缺陷和局限、相关的模式。 测试时间估计中应该要考虑的一些因素：历史数据、复杂度、商业目标、一致性和服从性。 测试设计的一个起点可以是对软件的功能规格和需求的审查。如果已经具备了良好的产品功能需求，基于需求的测试会是一个不错的出发点。如果没有产品需求，那么最好的测试设计的出发点就是问问题。问一下这个软件应该如何工作，如何处理数据，如何处理错误。 如果代码已经存在，但是需求或者功能规格并没有到位，最好的开始测试设计的方法就是运行这个应用程序。 探索性测试，也就是测试和设计测试同时进行，可以很大程度地影响测试设计而且对于整个测试设计过程也是很有利的一部分。 测试策略：测试的种类、进程，和测试时测试团队采用什么方法。它包括对风险的预估以帮助团队决定错误最有可能发生在哪里或者某些组件是否可能需要更加全面彻底的测试。这个策略通常包括对测试团队培训和教育的计划。 测试策略属性：介绍、需求规格、关键背景、测试方法可交付使用的测试（测试结果；代码覆盖率；规格说明完成的状况；缺陷的比率和趋势；使用场景的性能测试结果）、培训。 可测试性是指软件可以被完全有效测试的程度。选择不同的设计、选择简单的算法，使用测试hook和让内部变量可见都是如何提高可测试性的例子。 测试人员可以用来提高可测试性的最普遍的方法就是在需求或设计评审中简单的问，“我们如何来测试这个东西？” 一个简单的可测试性的模式：SOCK——简单、可见、控制、知识。 一个测试设计规格说明一般可适用于手动和自动化测试。它也应通过评审过程，与软件工程中的功能规格说明和设计文档是一样的。 测试设计规格说明的基本元素示例：概要、目标、目的；策略；功能测试；组件测试；集成测试或系统测试；互操作性测试；一致性测试；国际化测试和全球化测试；性能测试；安全测试；安装或部署测试；依赖关系；度量。 测试用例一般包括验证测试（使用期望的输入来验证产品功能的测试）和错误避免测试（使用预期之外的数据来检验产品是否能适当处理的测试）。验证测试是必要的，而错误测试则可能会更重要一些。 在测试用例设计中要考虑的其他因素：进度，资源（预算），质量，产品的范畴，用户基数的大小，测试团队的大小以及测试团队的技能。回答与这些因素相关的问题能够帮助你选择一个可以验证产品功能、找出错误并有效处理用户问题的测试集合。 做一个充分的测试用例设计需要测试工程师事先考虑好可能的测试范围，也需要能够全盘考虑并确定优先级，以使测试能够在满足项目进度要求的同事对产品进行了充分的测试。 【黑盒测试】根据一二应用程序的用户只关心这个应用程序是否满足了他们的需求，而不关心这个应用程序是如何被设计和实现的原理，它是一个有效的方法去模仿和预估用户会如何使用这个产品。也会导致过度测试程序的某些部分而对另一些部分没有做足够的测试。 【白盒测试】通过对应用程序内部代码或者用户看不到的模式进行分析，并以此设计测试用例。它总是会错过关键的终端用户使用场景。 【灰盒测试】首先从用户关心的角度出发，然后再利用白盒测试方法保证测试用例能够有效并全面的覆盖被测对象。从两方面进行测试：用户角度和确定应用程序的正确性的角度。 【探索性测试】是一种手工测试方法，每一步的测试和验证都是基于前一步的操作。需要根据已了解的被测产品的知识以及掌握的测试方法学，快速的找到产品的缺陷。 在一个不断强调自动化测试的团队里，探索性测试方法在早期的测试设计阶段很有帮助，它可以影响自动化测试的结构和目标。它旨在模拟用户体验，而且通常能够成功发现其他测试方法可能会错过的缺陷。 在做测试的时候，及早发现重要的缺陷是非常重要的，还要努力设计出可以发现缺陷，并保证可以在整个产品生命周期之内验证产品的功能以及正确性的测试用例。 【结对测试】两个测试工程师一起完成探索性测试。其中一个关注与如何调用各项功能，而另一个则是从高层面考虑被测程序。 为了能使测试用例长久使用，设计测试用例的一个关键是不断地实践各种技术和方法，并将得到的所有信息用于后续的测试活动。最重要的就是要花时间去了解每个组件，每个功能，或是应用程序，并且要基于对各种各样技术的了解来设计测试用例。 第5章 功能测试相关技术杰出的测试工程师不仅依靠其好奇心去探究产品，还会对其作深入挖掘、在更加精细的多的粒度上，对正在测试的软件的能力及书写实施深度分析。 收集更多深度信息的途径之一是将产品的功能集进行分解，然后针对分解后的各个组件的功能属性及能力分别实施测试。 【探索性测试，ET】主要关注于行为测试。ET在对软件进行初步评估摸底的时候特别有用，有助于使测试工程师对于测试的软件迅速形成一个概念。也能够有效地对软件的操作能力和整体可用性给出一个初步的、宏观的总体评价。 探索性测试不能适应大型的复杂项目，或是任务非常关键的软件。 使用黑盒方法进行软件行为测试，仅能企及所有测试能够覆盖范围的35%到65%之间。 提高测试的有效性并收集产品特定方面关键信息的一种途径是采用功能测试相关技术。功能测试相关技术是指某些系统化的过程，使我们能够对软件的属性和能力实施全面的考察。常应用于从用户界面出发的测试，但是同样也能够应用于设计黑盒和白盒视角出发的测试。 功能测试相关技术的另一个好处是：它能够把针对产品特定功能范围内的测试覆盖率逐渐提升至一个很高的置信度，同时降低测试用例的冗余数量。功能测试相关技术知识专业测试工程师使用的工具，用以收集软件的能力和属性的关键信息，以及揭示潜在的缺陷。 功能测试相关技术，如边界值分析（BVA），等价类划分（ECP）、组合分析，以及状态转换测试等就像工具箱中的各种工具，每种工具都适用于不同的用途。 【等价类划分（ECP）】使得测试工程师能够以系统化的方式评估一个功能点中每个参数的输入和输出变量。 ECP测试可以经由这样的手段导出：创建每个合法分类子集的合集，直到测试取遍合法分类的所有子集为止；尔后，再对非法数据子集依次评估。既可以定义正向测试，也可以定义负向测试，以针对输入和输出参数在功能方面的能力，以及系统是否对于所有种类的错误都具备了足够的处理能力实施系统获得评估。 ECP的功效：有助于我们系统化的降低从所有可能的测试中遴选的测试的数目。另一个优势在于我们可以通过从给定的测试子集中随机选择元素用做测试数据，以有效地提高数据的覆盖率。 从合法和非法子集中随机选择元素为测试用例的后续迭代提供了巨大的多变性，而且增加了将不常见的畸形用例曝光的几率，而它们是不太可能通过典型的或是实际中常用的合法类的静态数据测试出来的。 等价类划分必须非常熟悉数据的各种类型，了解程序和系统运行、操作、转换盒存储数据的机制。同时必须知道输入变量的可能值以及回顾失败指示信息。也必须考虑外部因素。 ECP数据分解理论：过于宽泛的变量数据归纳减少了ECP测试的数量，但增加了遗漏错误的可能性或产生负向错误或正向错误。变量数据过量的分解会增加冗余测试的可能性，这会减少ECP测试的整体效率。 最初，必须把数据分为离散的合法类数据和非法类数据。在每一个等价类数据集合中使用多个元素来增加覆盖的宽度并减少错误功能的可能性。 等价类划分的四个启发式方法，在决策制定、故障检修和解决问题的任务重十分有用。把数据分解为在合法和非法类中的离散集合的四个启发式方法包括： 值的范围（在数据的邻近集合中最小值和最大值间的任何数据点应产生相同的结果）、 变量相似组（只要元素被等价的处理，那么元素组是允许的）、 唯一值（在类或子集中的数据可能以不同于同一类或子集中的其他数据的方式被处理）、 特殊值（条件必须提供或必须不被提供）。 当数据划分为离散子集之后，ECP技术的下一步是定义在测试之中如何使用数据子集。最常用的方法是对于所有参数创建合法类子集的组合直至在验证测试中所有合法类子集已经至少包含一次。接着，对于每一个参数单独测试的每一个非法类子集，把其他参数设置为一些合法值。 利用随机概率生成测试数据或随机选取给定测试子集中的特定测试数据元素可以覆盖更多的可能变量数据。 ECP所有的测试都不专门针对边界条件。这是由于ECP测试是用于识别特定类型的错误，而边界测试是用于识别不同类型的错误。 ECP测试不专门针对极大极小边界条件，同样它也不包括边界值分析和边界测试。 等价类划分小结 ECP是个用于设计一组黑盒或白盒的功能性测试技术，并以此来评估输入输出参数的功能性。该技术不能用于评估边界条件、相互依赖参数的组合、按序或已经排序的输入。 在可靠理论中的单点故障假设规定中，故障很少是2个或多个故障共同作用的结果。ECP测试和边界测试的主要目的是暴露单点故障，尤其是处在线性边界的变量或处在所谓边角案例的等价数据可能吧程序相应的处理。 【边界值分析（BVA）】仔细分析线性变量的边界条件。当BVA和ECP结合使用，则BVA这个功能性技术可以有效地分析独立输入和输出参数等线性参数的边界值。 BVA或边界测试可以检测以下类型的错误： 错误的数据类型的人工约束； 错误的分配关系运算符； 数据类型的封装； 差一错误。 在一个软件程序的环境中，边界值是个特定值，该数值处在独立线性变量或它的等价类子集的极限边界上。 BVA在系统的分析在软件中常见的两类边界值：不变常数的数值，固定变量数值。不变边界常数是数字常数或在运行阶段保持不变而且通常不会被用户改变的实数。固定边界，意味着测量可以改变但是在特定时段必须不变。 有效边界值分析取决于测试员准确识别关于任何特定独立参数的所有特定边界条件的能力。等价类子集对于帮助我们确定潜在的边界条件也非常有用。ECP子集不仅揭示了数值的极限线性范围，也会暴露一些可能表明额外重要边界条件的数值。 在确定所有独立输入输出参数的边界条件之后，可以通过一个简单的公式：3(BC)来计算最小的测试数据子集，BC等于特定边界条件的数量。 当其他参数都被设定为额定值时，每个参数都被评估为边界值和忽上忽下的数值。这些参数的ECP测试已经正式额定数值可以如期的执行。当额定数值给定，我们设计BVA测试来使用有效范围内的随机概率数值，如此可以提供更大的灵活度，并使得测试中的硬编码或静态数据最小化。 不是所有的边界都能通过数字型输入或输出来确定，或者它们是代表直接面向用户的线性测量数据。 代码中存在许多的循环算法，循环结构在边界条件中是众所周知的问题。 循环结构的边界值分析包括（最小）绕过循环，1次遍历循环，2次遍历循环，最大次数的遍历循环，最大次数-1的遍历循环，最后是超过最大次数的遍历循环。 边界测试基于确定的边界数值，而不是基于参数的数量。边界值分析的有效性取决于我们是否有能力将离散变量分解为等价类，并确定重要的边界条件。 基本边界测试是基于单点故障的前提，因此BVA测试常常不能有效地评估依赖或半依赖参数的复杂组合。 组合分析，通过从所有可能的组合中选择一个有效地子测试系统，并借此分析一个复杂的特征集中地系统性依赖和半耦合参数的相互作用。 组合分析的优点： 能最大程度的识别由于变量作用所导致的缺陷； 提供了更大的结构性覆盖； 具有很大的潜力来降低整体测试成本。该技术的优势是用于你在测试一个功能时，该功能的参数直接相互依赖或者半耦合，而且参数输入都是无序的。 通常有两种测试参数相互作用的途径。第一种途径一般涉及随机或者待定的方法，而第二张包括了更加系统的过程。随机评估的方法包括最优猜测或特定测试和随机选择。系统评估方法包括每个变量或者分支(EC)，基准测试(BC)，正交陈列(OA)，？组合测试和穷举测试(AC)。 最优猜测或特定方法主要依靠测试人员的直觉和运气。比较适合测试常用的组合或者快乐路径，也能暴露源于异常组合情境下的细微缺陷。 分支测试(EC)，将每个变量测试至少一次，它使用了最少量的测试。基准测试(BC)，指定一组变量作为基准测试。这组变量通常是快乐路径中常用变量状态的组合。额外的测试在一段时间内改变一个参数的变量状态，同时保持在基准测试中的其他参数变量状态不变。 正交阵列(OA)，需要每个相互依赖的参数具有同等数量的变量状态，那些状态都对应在数组中。 测试相互依赖的参数可变组合最有效地解决方案之一是组合分析或用到覆盖阵列的n-对测试。 选择适当的测试集合： 识别相互依赖的参数。当彻底分析功能，决定哪些参数是相互依赖，并分解每个参数的可变状态，进而选择合适的变量来测试之后，就可以建立BC矩阵。BC矩阵通常定义了最通用的可变状态组合，然后在保持其他参数可变状态处于初始状态的同时，每次改变一个参数的可变状态，直到每个变量都被测试过为止。 在完成BC测试之后，接下来找到任何在故障指标上问题的，但未在BC矩阵中定义的常用组合。接下来，必须创建输入文件来模拟每个参数的、适当的可变状态。 ？PICT工具 历史经验表明大多数、源于参数间相互作用的缺陷常出现在简单配对组合。但是，除了测试BC矩阵和把PICT工具中的配对输出随机化以外，最近研究表明持续增加的n-对组合测试可以暴露之前未察觉的细微缺陷。 检测缺陷的有效性（DDE）是个最常用的测试有效性的方法之一。 建议测试人员从BC和配对测试开始，然后将配对输出结果随机化，并持续增加n-对测试组合总量知道6-对覆盖。 另一种评估测试有效性的方式是查看测试人员提供给的资料。 经验数据表明多数黑盒测试都将结构性的覆盖65%的附在程序。相比于黑盒测试，使用配对测试的，在产品代码块和弧覆盖的数量方面会有所增加。 另一种检测有效性的途径是降低运作的成本。 组合测试中，测试人员必须有能力正确分析功能参数，鉴别依赖参数和半耦合参数，并分解变量状态，识别有条件的和不变的约束。 第6章 结构测试技术结构测试技术通过对函数控制流程的详细分析来帮助我们降低风险。 与那些既能应用于设计黑盒测试也能应用于设计白盒测试的功能测试方法不同，结构测试技术是一种白盒测试设计方法。 使用白盒测试方法所设计的测试既能在用户界面层次执行，也能通过使用存根或虚拟对象的方式在用户界面之下的组建层次执行。 一个了解数据类型、函数调用和程序结构的优秀测试员能够更有效地发现不同类型的问题。 块测试（block testing） 函数的基本结构测试方法使用了一些简单技术，包括语句测试和块测试。语句测试的目的是执行一个函数中的所有语句。块测试则执行成组的连续语句或不包含分支或函数调用的语句块。 语句覆盖测量一个程序在测试过程中被执行过的语句的数量。块覆盖测量无分支的连续语句组的数量。导致控制流程转向分支的条件语句可以包含若干块。相较于语句测试，块测试对控制流程提供了更好的敏感度。 结构测试的价值取决于测试员分析控制流程以及设计测试以确保各个不同的控制路径至少执行一次的能力。 控制流程图（CFD）就是函数或类的模型。一个CFD必须有一个入口和一个出口。在函数的入口和出口之间，CFD提供了程序代码的一种抽象表示或模型，从而帮助测试人员通过遍历一个复杂函数的不同代码路径来追踪控制流程。 矩形：语句或语句块；菱形：决策或条件子句；圆形：函数中的决策点。 如果目的是进行单元测试，块测试一般已经足够，但它只是结构测试的一个相对较弱的形式。 适合于块测试的一种结构类型是case/switch语句。 块测试体现其重要性的另一个地方是异常处理。 块测试是健壮的结构测试中相对较弱的标准，它还可能漏掉控制流程的一些重要的分支。此外，块测试还容易忽略一些潜在的问题，特别是在我们测试的目的只是要提高代码覆盖率而不是要仔细分析被测试代码的情况下。 决策测试（Decision Testing）对条件子句求值，根据条件为真为假，简单的布尔表达式就可以确定控制流程的分支。决策测试的主要目标是设计既能够验证布尔表达中的真也能验证假结果的测试。 决策测试不是用于执行代码的连续代码块，而是注重于评价函数中的条件子句。优点在于它对控制流提供更好的敏感度。它的目的不是测试所有可能的输入或输出，而是简单的帮助我们测试贯穿函数的控制流程。 决策测试对简单条件语句是行之有效的，这些条件语句只需要计算布尔条件表达式的值，比如if语句或循环结构。但与块结构类似，决策测试并不能充分验证条件语句中的关系运算符。决策测试也不能有效地评估符合条件判断的控制流程。 条件测试（Condition Testing） 又是一个函数中的控制流程取决于多个条件语句的结果，可以使用一个由多个布尔子表达式经逻辑运算符AND或OR连接承德条件语句来简化代码，而不是用级联的多个条件语句。 当一个条件语句包含两个货两个以上的布尔子表达式，我们可以使用条件测试这种结构测试技术。它用于评估复合条件语句中每个子表达式估值为“真”和“假”的结果。在测试符合条件语句时，条件测试比决策测试对控制流程提供更好的敏感度。 ？基础路径测试（Basis Path Testing） 路径测试试图遍历程序中所有可能的途径。每次控制流程通过一次循环体就被认为是一条不同的路径。 圈复杂性是用来帮助开发人员测定他们的函数复杂性的一个测量单位。用于在软件开发生命周期中评价一个模块的潜在可靠性、可测试性和可维护性。也可被测试人员用来确定最低的测试数量，从而对一个函数的控制流程进行比块测试和决策测试更加严格的测试。圈复杂性衡量控制一个模块或函数流程的决策逻辑。 计算圈复杂性的公式 V(G)=边的数目-节点数+2 线性独立的基础路径是通过一个函数的独特路径的有限集合。 测试人员可以使用基准路径技术来查明通过一个函数的线性独立的基础路径集合。 简化基准路径技术流程： 1. 确认从被测函数入口到出口的最短基准路径。 2. 回到函数入口。 3. 跟踪控制流程，从入口点到第一个未被先后评估为真和假两种结果的条件语句。 4. 改变该条件语句的结果。 5. 按最短路径从这个条件语句到函数出口。 6. 重复2至6，直到所有的基础路径被定义。 实用基准路径技术流程： 1. 确定一个有可能的功能性的通过函数的基准路径，它代表一个非常可能的通过函数的控制流程。该流程是运行时最常见的，或是最重要或最关键的路径。 2. 回到函数入口点。 3. 跟踪控制流程，从函数入口点到第一个未被先后评估为真和假两种结果的条件路径。 4. 改变该条件语句的结果。 5. 沿一条包括最大数量的被基准路径所遍历的条件语句到函数出口点的路径。 6. 重复步骤2至6，直到没一个条件语句都被先后评估为真和假两种结果，而且所有基础路径都被定义。 基础路径测试与块测试和决策测试的不同之处在于：每一个条件语句的每个结果都必须被独立的测试。但是，基础路径测试需要一个测试把控制流程绕过循环，另一个测试的程序控制流程经过循环结构。所以，类似于条件覆盖范围，基础路径测试包含了块和决策测试。 当分析有简单条件语句的函数，特别是使用循环结构的函数时，基础路径测试提供了鞥好的控制流程敏感性。但是，当评估一个符合条件语句时，基础路径测试包含了块和决策测试。 结构测试技术的目的是支持和加强其他测试方式和方法，通过设计和运行能遍历其他测试方法所不能遍历的代码路径测试，还可以提供更深入的信息和降低风险。 第7章 用代码复杂度分析风险基于风险的测试，就是基于缓解产品中潜在风险的测试方法。它倾向于把可用的测试资源集中在最需要的区域。 80/20法则：在很多度量标准下80%的结果源自20%的原因。 80%的用户使用仅仅20%的功能，80%的缺陷存在于20%的产品中，或者说80%的运行时间耗费在20%的代码上。 复杂的代码和不同代码的复杂部分之间的交互通常会更容易的带来错误。复杂的代码更容易产生更多的缺陷，也更难维护。 代码复杂度是衡量代码“难度”的重要标准（LOC）。 最简单的代码复杂度测量方式可能是代码行数。 确定程序中判断的数目的最常用的方法中，有一种称为回路复杂度的度量方法。它是辨别函数中线性独立路径（或者判断）数目的度量方法。 一个没有包含条件操作（比如条件语句，循环，或者三元算子）的函数在整个程序中只有一条线性独立的路径。条件语句在程序流中加入了分支也就在函数中创建了另外的路径。 计算复杂度最常用的方法是首先基于源代码创建一个控制流程图，然后基于此图计算出结果。 计算公式：边-节点+2 快速计算回路复杂度的方法是简单地将条件语句的数量加1. 回路复杂度主要用在衡量函数的可测试度。1-10：低风险的简单程序11-20：中等的复杂度和风险21-50：高复杂度和风险50+：非常高的风险/不可测试 Halstead度量是一套完全不同的复杂度度量，基于对程序中语法要素的以下4个度量： 独特算子的数量n1； 独特算域的数量n2； 所有算子出现的总数N1； 所有算域出现的总数N2； 面向对象度量是在各种语言中类和类结构相关的度量CK度量包括： 每个类的权重方法（WMC）：一个类中方法的数目； 继承树的深度（DIT）：一个类所继承的类的数目； 对象类之间的耦合（CBO）：一个类引用其他类的方法或者实例变量的数目 在面向对象的编程中，扇入和扇出度量分别用来计算有多少类调用到某一个特定的类和多少类被某一个特定的类调用。例如，如果一个类包含的方法被其他5个类调用而且这些方法也调用了其他10个类，那么她的扇入就是5，扇出就是10。 这些度量值作为可维护性度量是非常有效的，同时也表明了需要额外的测试的区域。 当被用在函数或者模块层面，扇入和扇出度量对于非面向对象编程也很有价值。另一方面，扇出度量表明了程序中有多少依赖关系。 减少复杂度度量误诊的方法就是同时检视各种不同的复杂度度量，通过结合和权衡这些数据来减少误诊。 微软Visual Studio工具集的最新版本包含了多个复杂度度量的测量方法，包括回路复杂度、Halstead度量、和代码行数的度量方法。 高的复杂度只能表示这段代码可能会有很多缺陷，仍然需要额外更多的调查来证实这个结果。 第8章 基于模型的测试（MBT）一个模型可以是对系统的任意描述。一个典型的行为模型中会有一个开始状态，一个或多个转变，以及一个结束状态。 每次生成模型时考虑的三个问题： 1. 我在哪里？ 2. 我可以进行什么操作？ 3. 我做这些事的结果会怎样？ 模型的测试自动化并不是对端到端场景进行自动化，而是将重点放在过渡自动化和状态验证上。 在MBT中，边和节点分别代表转移和状态。MBT的主要功效体现在遍历算法中。随机的通过每种状态的测试时有趣的，并且经常会发现缺陷，但将图论的概念应用于遍历会有利而且有效。 随机行走遍历会随机选择一个可用的转换。它没有指导或计划；它只是在设定时间内尽可能的走遍各个状态。随机行走通常会发现缺陷，但可能会花特别长的时间来遍历大的模型。 加权遍历在某种程度上是有指导的随机行走。选择哪个转换仍然是随机的，但最有可能的选择都进行了加权，以便它们的发生更频繁。 最短路径遍历使用最少量的转换走过两个节点间的路径。 所有转换路径也包括所有节点。而所有状态遍历则不保证所有转换路径都被尝试过。 用于API测试的模型 在较低级别，许多操作系统或平台功能也可以由基于状态的方法来测试。 随机模型 基于模型的另一简单形式是猴子测试。猴子测试会生成随机（或假随机）输入，以期找到缺陷。猴子测试在压力测试中很通用，而且通常也不难创建。它的缺点是这种测试一般难于进行调试。 语法模型 MBT的另一种常用形式是使用语法模型进行测试。语法模型描述数据的特征和结构。正则表达式就是一种语法模型的实现。正则表达式的一个常见用途是搜索文本。语法模型对于创建测试数据而言是很有用的。 基于模型的测试，可以通过少量工作实现非常广泛的测试覆盖。最困难的问题之一是创建模型来描述我们讨论的系统。一旦通过正确定义所有可能的输入、转换和输出，就会发现准确的定义从任何可能的参数组中得出的结果是很容易的。 基于模型的测试非常健壮，可以用它来测试从API到UI的各种领域。当模型实现时，就可以完全取消手动测试。经过适当调整，基于模型的测试可以提供从快速验证测试到全面功能测试的覆盖。这是通过将我们的输入、转换盒输出列表删减到我们感兴趣的子集实现的。 使用MBT生成的测试用例花费更少的时间，得到更好的覆盖率。另外，模型十分容易扩展。作为一个好的建模实践，应该首先为最基本的功能建模，然后逐步扩展它。 关于基于模型测试的总结： MBT为功能的设计提供了不同的视角； 测试时自动生成的，而且保证用最少的步骤达到对模型的完全覆盖。 扩展模型十分容易，而且可以利用以前生成的测试。 基于模型的测试最常见的错误： 过多的建模； 建模并不能代替其他的测试； 只能为验证的东西建模； 仔细设计。 第三部分 测试工具和系统 第9章 缺陷和测试用例管理测试用例描述测试过程的意图，缺陷则描述了这些测试用例的结果。 缺陷的工作流程描述了一个缺陷从创建到关闭的过程，所有的参与者，以及缺陷报告的所有可能途径。 缺陷的工作流程： 产品代码→运行测试用例→创建缺陷报告→三方会审讨论缺陷。 如果缺陷没有被批准，把缺陷安装不修正来解决→关闭缺陷。 如果缺陷批准了要调查→研究是代码错误，还是设计错误。 如果是代码错误，提议修正代码错误，再进行三方会审→如果修正批准了→修正代码→解决缺陷→重现缺陷→通过则关闭缺陷，如果不通过，重新激活缺陷→重新调查是代码错误还是设计错误。 如果是设计错误，修正设计指导批准→再进行三方会审。其他后续流程和以上类似。 缺陷跟踪系统的特性：简单好用、可设置性、可靠性、缺陷通知、互操作性、外部用户访问。 好缺陷报告的特点：属性、标题、说明、状态、版本号、功能区、重现步骤、分配、严重性、客户影响、环境、决断。如何发现、问题类型、缺陷类型、资源来源。 缺陷的优先顺序通常设定值如下： 必须修正；应修正；有时间就修正。 缺陷报告中常见缺陷： 电子邮件讨论；缺陷渐变；多个缺陷。 缺陷度量：修复的缺陷/所有解决了的缺陷；每种语言总计缺陷；缺陷发现率；错误修正率；每个代码区的缺陷数；每个功能区发现的缺陷；不同严重性的缺陷；哪里发现；如何发现；缺陷发生时候；缺陷重新激活率；每个测试活动发现的缺陷；平均解决缺陷的时间；平均关闭缺陷的时间。 缺陷数据的可变因素：所测试功能的复杂性；开发人员编程能力；规格完整性；缺陷预防与缺陷发现；报告的及时性。 一个测试用例管理器（TCM）是一个系统，它可以管理测试用例的定义、版本、储存和执行。测试用例管理器与缺陷管理系统有着许多相同的属性。 一个测试用例描述了针对某一特定的软件组件及预期的结果的与其操作。该组件可以是一个小的应用程序编程接口（API），一个用户界面（UI）的控制，或设备驱动程序的端口（port）处理。 测试用例可以由一组步骤和预期结果组成。自动化测试用例应该自我核查。 测试用例可以验证程序功能正常或验证错误能被正确处理。测试用例的其他用处是可以尝试增加代码覆盖或专门的用于覆盖很少使用的路径。 测试用例文档的优点：历史借鉴；测试进展跟踪；可重复性。测试用例文档的缺点：建立文档的时间；功能变化引起测试用例过期；很难设想读者的知识。 测试用例的属性：目的；条件；具体的输入和步骤；预测结果。测试频率；配置；自动化（手动，半自动化，自动化）。 测试用例的误区：步骤缺乏；太多细节；行话太多；不明确的通过/失败标准。 测试用例是为执行一个测试行为设定的一组步骤的一个单一实例，而测试点是那个测试用例在某个特殊环境里的一个具体实现。众多测试点的结果可以与横跨测试矩阵或以前已有记录的测试点互相进行比较，而此时这些测试点基于的测试用例也许根本没改变。 测试术语： 测试用例、 测试点（一个测试用例和它的一种运行环境的组合）、 测试套件（相关测试用例或测试点的一个集合。通常一个测试套件是被测试功能的单位，常限于产品的某组件或特性）、 测试运行、 测试通过。 测试常用的度量：通过比率；通过/失败的数目；测试用例的总数/计划的测试用例的总数；自动化比率、测试类型的数目；发现缺陷的测试数目或百分比。 第10章 测试自动化是否自动化的考量因素： 投入；测试的生命期；价值；切入点；准确性。 误报：测试用例报告一个错误，但实际上并没有错误存在。漏报：当一个测试用例汇报验证通过，而被测试的软件功能其实有问题。 是否自动化测试的因素：支持平台；复杂度；其他因素（自动化所需时间、自动化测试的测试人员的技能、产品设计早期的设计对可测试性和自动化支持的考虑、管理层对自动化的指导意见）。 面向公众的函数或任何通过编程界面面向公众的功能，都很适合做自动化测试。通过针对单个API功能的自动化测试，可以使用测试应用程序有效测试多个参数的组合。 很多非功能测试都适合自动化，如性能测试、负载测试、压力测试和泄露测试。 用户界面自动化：使用击键和鼠标点击写成的代码是重现用户与软件互动行为最相近的自动化测试方法，但也是最不稳定的UI自动化测试方法之一。控件会移动，控件的标识符会改变，文本也会更新或者本地化。另一种自动化的方式是自动化那些用户与用户界面互动时发生的行为。 自动化的组成部分： 设置Setup：指的是将软件准备好，让实际的测试操作可以开始执行； 执行Execute：包括检验软件功能的特定步骤，充分的错误处理，或者一些其他的相关工作； 分析Analysis：确定测试通过还是失败的过程。 报告Reporting：包括分析结果的显示和传播，例如日志文件、数据库或者其他分析过程中生成的文件； 清理Cleanup：将软件返回到已知状态使得接下来的测试能继续执行； 帮助Help：使测试用例在其生存周期中保持可维护性和健壮性的帮助系统。 一个完整的自动化方案要求自动化不仅仅测试执行这一环节。在一个自动化策略中，如果没有一个把应用程序准备好到测试可以执行状态的计划，也没有自动的测试结果报告和分析，就很少能带来什么益处。 测试用具的工作流程： 测试用具启动并检查任何传给它的附加数据。把控环境变量、要运行的测试、文件位置、网络地址或者测试需要的其他任何数据。 测试用具执行测试用例。取决于测试用具或者可选数据，自动化测试用例可能依次运行，也可能随机运行，或按特定的顺序运行。 测试用例可以记录测试数据（包括测试状态）并输出到一个文件、一个调试流或者别的固定的位置。日志文件必备元素：测试标识符、测试名称、环境信息、被测程序信息、测试结果。 测试结果的分类：通过、失败、跳过、放弃、阻断、警告。 自动化测试代码中一些常见的错误： 硬编码路径； 过于复杂； 难于调试； 误报和漏报； 第11章 非功能测试定义为肺功能的测试领域包括了性能、负载、安全、可靠性和其他很多方面。非功能测试有时也被称作行为测试或质量测试。 非功能属性： 可靠性（是度量软件如何在主流情形和非预期情形下维持它的功能，有时也包括软件出错时的自恢复能力）、 可用性（用户学习和控制软件以达到用户需求的容易程度）、 可维护性（描述了修改软件而不引入新错误所需的工作量）、 可移植性。 性能测试 最常见的性能测试可以称作读秒测试。旨在测量某些重要操作的执行时间。它是设计单个测试或一组测试去测量软件对不同的用户操作的响应时间，或是测量在受控环境下的产品功能。大多数的性能测试实际上是通过执行测试用例并记录所用时间的自动化测试来实现的。 在设计过程的早期就积极地介入代码评审和分析性能目标是绝对必要的。 在设计阶段发现潜在性能问题的技巧： 提出疑问； 考虑全局； 明确目标。 性能测试的技巧： 建立基线； 经常运行测试； 测试响应效率； 测试的是性能； 充分利用性能测试； 预估瓶颈； 使用工具； 合理使用资源（响应时间，延迟，CPU负荷，硬盘或网络I/O，内存）； “干净机器”：用还是不用； 避免改变。 性能计数器是揭示应用软件或系统的某些性能指标的细节测量工具，它使得检测和分析这些指标成为可能。 压力测试 应用软件在预期的和重负载条件下的表现和处理容量增大的能力，通常被归类为在性能测试下面。 广义上，压力测试（通过模拟比预期要大的工作负载来让只在峰值条件下才出现的缺陷曝光。如内存泄露、竞态条件、数据库中的线程或数据行直接的死锁条件和其他同步问题）经常包括: 负载测试（探讨在高峰或高于正常水平的负载下，系统或应用软件会发生什么情况）、 平均无故障时间（MTBF）测试（测量系统或应用软件在出错或当机前的平均运行时间）、 低资源测试（确定当系统在重要资源&lt;内存、硬盘空间等&gt;降低或完全没有的情况下的状况）、 容量测试（一般是用来执行服务器或服务测试，目的是确定一台或多台计算机能支持的最多用户数目）、 重复性测试（确定重复某一程序或场景的效果而采取的一项简单而粗暴的技术，循环运行测试直到达到一个具体界限或临界值）。 分布式压力测试 多客户端压力测试的特点：无穷运行、内存使用、没有已知问题。 兼容性测试 应用程序兼容性测试一般注重于应用程序之间或所测试的目标系统与其他应用程序之间的交互。其他应用程序可能包括内部和外部两种。 可达性测试 可达性是指为每个人提供接触信息和工具的相等机会，这些信息和工具是他们每天工作所必需的。它的根本点是让用户有一种感觉，他有能力创造和维护应用程序、网站或者 文件，并且有能力与之互动。 可达性测试的特性： 操作系统的设置：设置大字体、高DPI、高反差界面风格、光标闪烁速度、粘滞键、过滤键、鼠标设置子键、串行键设置子键、切换键设置子键、屏幕分辨率、自定义鼠标设置及从屏幕键盘的输入。 “内置”可达性特性：Tab键顺序、热键、快捷键。 编程访问。 可达性的技术工具：屏幕阅读器、放大镜、语音识别或者其他输入程序。 应用程序的可达性测试方法： 遵守系统范围的可达性设置； 支持高反差界面风格； 尺寸事关重大； 注意音频功能； 能够对UI元素和文本进行编程访问。 可用性测试 可用性是指用户能不能很容易的理解和与用户界面互动。有用的文档、工具提示、容易找到的功能等 可用性实验的目标： 用户的需要是什么？ 什么样的设计能够解决用户的问题？ 用户需要做哪些工作，他们能不能很好的解决问题？ 用户如何学习软件，以及保持他们对软件的技能？ 软件用起来是否有意思？ 安全测试 James Whittaker 安全测试的主要方法和技巧： 威胁建模（审查应用程序结构以找到潜在的安全威胁和弱点。输入校验、数据处理、会话管理等。在程序设计时完成最佳。意图是找出一个程序被攻击的所有可能的方法，然后根据概率和可能的危害来排优先级）； 模糊测试（一种用来决定程序对无效输入数据会怎样反应的技术。简单办法就是用十六进制的编辑器来改变程序所使用的数据文件的文件格式。处理随机改动数据之外，模糊测试通常还包括将数据改变成更易暴露潜在的安全问题的样子。它的适用范围还有数据库测试、协议测试或者任何一种必需读取和解释数据的系统或应用程序中） 第12章 其他工具代码改动量：指的是在一段时间内，一个文件或模块中的代码变化的总量。 代码改动的计量方法： 修改的次数、增加的代码行数、删除的代码行数、修改的代码行数。 使用“代码改动”指标可以显示出软件中哪一部分出现缺陷的可能性较高。 “代码改动”只是一个警示的指标，如果一个产品具有很高的“代码改动”值，并不总是意味着那个产品存在很多问题，只是提醒产品某些部分发生了大的变化。 需要被严密监测的并不局限于源代码的变更，同样重要的是还要对所有规范说明和所有辅助文档进行控制管理。 软件构建 构建过程包括编译，链接，和运行应用程序所需的其他步骤：如构建安装程序和部署到新版本发布服务器上。 构建验收测试（BATs）或构建验证测试（BVTs）确保每天的构建是可用于测试的。 BVT属性：自动化一切，测试一小部分，快速测试，报错恰到好处，广泛测试而非深入测试，可调试和可维护性，可信，关键。 每日构建和BVT过程可以减少大的集成或全面的更改引发错误的机会。保持该产品天天成功的构建和运行时一个健康软件团队的关键。 每日构建至少确保编译错误在代码签入24小时之内被发现。 最常见的编译错误也是最容易预防的：开发人员代码中的语法错误。 构建中断通常由语法错误以外的其他原因引起。忘记签入某个文件是引起构建中断最常见的原因之一。当改动大型的复杂系统时，因为有依赖关系的系统的另一部分发生变化造成构建中断也很常见。 停止构建过程中的中断的有效方法： 滚动构建：基于该产品最新的源代码自动连续的构建。基本步骤包括：一个良好，没有问题的构建环境；自动同步到最新的源代码；构建整个系统；自动报告构建结果。最简单的的实现方法是用简单的windows脚本语言写一个控制文件。 签入系统。 静态分析 一个在测试代码中寻找缺陷的有效方法是利用工具做自动静态分析。静态分析工具可以分析源代码或二进制文件，发现许多类型的缺陷，而不必实际运行程序。 …… 第13章 用户反馈系统寻找并收集客户反馈信息的方法： 客户体验改善计划（在产品生产周期中，经常分析从测试用户和主要合作伙伴那儿得到的数据，可使测试团队有可能更好的了解用户的使用模式和疼痛点，不断更新测试场景和测试优先级）、 Windows错误报告、 发送微笑（对独特错误的贡献；提高顾客意识；用户的实际问题影响错误的优先级；理解用户是如何使用我们的产品；加强其他客户反馈）、 Microsoft Connect。 通过这些反馈机制，测试工程师能够发现漏掉的测试场景，找到测试漏洞，并直接针对用户的使用模式设计出新的场景测试。开发高质量软件的一个关键因素是，如何平衡使用用户反馈方法还是通过功能而是和代码覆盖分析等深入的技术分析方法。 …… 第14章 测试“软件加服务”软件加服务（ Software Plus Services ）是微软创造的术语。这种分布式软件集成了在线服务的集中和协作之功能，同时又可以利用超过 8亿台计算机和数十亿台智能设备的处理能力和脱机功能，这些设备是消费者、知识工作者和游戏玩家已经拥有的。 【服务组】是功能基本上相互独立的生产单元。一个服务组是生产规模的单元，同时也是下一次升级的部署单元。服务组也为网站级别的服务中断提供缓冲。 【现场可更换单元】把主板、硬盘和电源黏在一个平板上。 合适的软件加服务的测试方法：客户端支持；建造于服务器上；服务平台与顶级服务；松散耦合与紧密耦合的服务 在计算机科学中，耦合或依赖是指每一个程序对另一个程序的依赖程度。在源程序或目标程序频繁更改的情况下，松散耦合的系统使最好的。 好的安装程序的关键特征：零停工期、零数据损失、部分成品更新（或混合模式）、滚动式更新和快速反转机能。 部分成品更新提供了一个新版本和现有版本的混合模式来让在线服务能够控制风险。滚动式更新和部分成品更新相似，只不过采取全自动的方式。如果在安装部署的过程中发现了需回收产品的大缺陷时，快速反转机能可以使服务快速回到上一个好的状态。 …… 第四部分 关于未来 第15章 今天解决明天的问题就像测试自动化室解决测试无穷多的产品配置的一种方法一样，自动失败分析（AFA）是一种处理很多测试失败的解决方案。防止瘫痪最有效的方法是预见到它。 失败分析架构：AFA系统最重要的部分是失败匹配。为了能使AFA工作，自动化的测试需要报告导致错误发生的关于环境、场景、和步骤的一致性的信息，好的记录实践是一个可靠地失败分析的脊柱，如果测试日志是非结构性的，或者没有包含足够信息，就没有可能进行失败匹配。 日志实践：日志在成功时要简短，失败是要极其详细；当测试失败时，记下所看到的失败前的成功操作；日志应该跟踪产品信息；跟踪足够的和有帮助的失败上下文；避免记录没有必要的信息；如果结果已经被确认和证实了，每个测试点都应该记录这个结果；跟随团队的命名标准。 日志文件剖析：测试用例；系统信息；日期时间；测试输入界限；测试下限；测试下限通过；测试上限；期望结果；实际结果；结果。 大型测试自动化要想有非常好的投资回报需要集成自动化的每一个阶段，检入系统，和缺陷跟踪系统。一个成功的方案能够极大的减少手动干涉分析测试结果和失败的需要。AFA的另一个用途是分析测试失败的走势。 核查清单会在代码评审时引导评审员找到最容易检测到的缺陷类型，也会在代码评审时找到最关键的缺陷。核查清单的例子可能有：功能核查；可测性；检查错误并正确处理错误；资源管理；线程安全（同步，重入，计时）；简单性/可维护性；安全（中断溢出，缓冲溢出，类型不匹配）；运行时的性能；输入校验。 面临挑战：失败分析、代码评审、虚拟机的应用、和代码重用方面的改进。 第16章 建设未来早期的检测和预防对于防止以后很难“治愈”的问题最关键。 测试是一种被动方法——通过多重的检测盒调查技术来找到潜藏在产品中的缺陷，而质量保证是一种主动方法——建造一个预防和质量文化固化在开发周期中的环境。 质量成本，是“未能”生成优质产品或服务的代价。每次需要返工的时候，质量成本就提高了。 质量成本划分为三类：鉴定成本、预防成本和失败成本。鉴定成本包括薪资，和发布所需的费用。预防成本是跟实现和维护预防技术相关的开销。失败成本是返工的花费。 在一个每个人都把质量当成习惯的组织中，测试角色的着重点就从找到一大堆缺陷转移到了集中模拟用户场景、同时评审和校验方面。","link":"/2022/09/25/tech/testing/books-on-testing/"},{"title":"微软开源自动化测试平台Hydra Lab助力移动开发者建立测试流水线","text":"","link":"/2023/03/22/tech/testing/microsoft-new-cloud-testing-hydra-lab/"},{"title":"Java bytecode and AOP","text":"What is Java bytecode?Java bytecode is the instruction set of the Java virtual machine (JVM). From Wikipedia: In a word, just like X86 and ARM or MIPS running on each ABI platform, Java bytecode is executed by JVM engine. And as a machine language defined by JVM specification, Java bytecode plays a much more fundamental part in Java ecosystem than Java language itself. The following picture can be the best case to cast light upon it. https://docs.oracle.com/javase/specs/index.html JVM handles the platform independency. A Java programmer does not need to be aware of or understand Java bytecode at all. However, as suggested in the IBM developerWorks journal, “Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer.” An anatomy of the .class fileClass file dissemble Use this java source code as an example: Java method data structure: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html Stack-Based Architecture?All the instructions is centered by the Stack-Based Architecture and methodology of JVM. This largely simplifies the instruction set of JVM and therefore make it possible that the opcode size could be limited to 8 bit. In JVM for each thread, a last-in-first-out (LIFO) stack, also known as its JVM stack, is allocated where Java frames are stored. Here is an illustration showing stacks for 3 threads. A new Java frame is created each time a method is invoked and is destroyed when its method invocation completes. It is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions. Operand StacksAs opposed to a register-based architecture, stack based one will use stack data structure as its instruction executing and computing playground and notepad, which means each instruction execution will be companied with stack operations like pop and push. The operand stack is empty when the frame that contains it is created, and will normally be empty when the invokation of the corresponding method is completed. Local Variables tableIt is a bit reckless to jump to conclusion that JVM is stack-based as JVM also use local variable table during it bytecode execution, which make JVM a bit more register-based. Each frame contains an table of variables known as its local variables table. The length of the local variable array of a frame is determined at compile-time. So based on this understanding, let’s take a look at a more complicated method, setServiceType(String): Each frame for a method call has an “operand stack” and an array of “local variables”. Instruction typesThe byte-long and 256 possible opcode instructions fall into a number of broad groups: Load and store (e.g. aload_0, istore) Arithmetic andc (e.g logi. ladd, fcmpl) Type conversion (e.g. i2b, d2i) Object creation and manipulation (new, putfield) Operand stack management (e.g. swap, dup2) Control transfer (e.g. ifeq, goto) Method invocation and return (e.g. invokespecial, areturn) Prefix/suffix Operand type i integer l long s short b byte c character f float d double a reference https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html Bytecode manipulationThe most powerful and widely used manipulation tool: ASM Site: https://asm.ow2.io/ Used in: OpenJDK Groovy and Kotlin compiler CGLIB AspectJ Gradle …… It is the fundament of compile-time AOP, basically by applying ASM API we can analyze and modify class file method call after source code compile.","link":"/2018/12/31/tech/java/more-about-java-bytecode-and-aop/"}],"tags":[{"name":"35岁危机","slug":"35岁危机","link":"/tags/35%E5%B2%81%E5%8D%B1%E6%9C%BA/"},{"name":"自我管理","slug":"自我管理","link":"/tags/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/"},{"name":"领导力","slug":"领导力","link":"/tags/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"艺术","slug":"艺术","link":"/tags/%E8%89%BA%E6%9C%AF/"},{"name":"育儿","slug":"育儿","link":"/tags/%E8%82%B2%E5%84%BF/"},{"name":"人文自然","slug":"人文自然","link":"/tags/%E4%BA%BA%E6%96%87%E8%87%AA%E7%84%B6/"},{"name":"减肥","slug":"减肥","link":"/tags/%E5%87%8F%E8%82%A5/"},{"name":"悬疑","slug":"悬疑","link":"/tags/%E6%82%AC%E7%96%91/"},{"name":"方法论","slug":"方法论","link":"/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Code design","slug":"Code-design","link":"/tags/Code-design/"},{"name":"Design Patterns","slug":"Design-Patterns","link":"/tags/Design-Patterns/"},{"name":"GoF","slug":"GoF","link":"/tags/GoF/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"开发工具","slug":"开发工具","link":"/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"Azure","slug":"Azure","link":"/tags/Azure/"},{"name":"夏令时","slug":"夏令时","link":"/tags/%E5%A4%8F%E4%BB%A4%E6%97%B6/"},{"name":"历史","slug":"历史","link":"/tags/%E5%8E%86%E5%8F%B2/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"面向切面","slug":"面向切面","link":"/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/"},{"name":"字节码","slug":"字节码","link":"/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"bytecode","slug":"bytecode","link":"/tags/bytecode/"}],"categories":[{"name":"人生杂谈","slug":"人生杂谈","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/"},{"name":"管理","slug":"管理","link":"/categories/%E7%AE%A1%E7%90%86/"},{"name":"自然地理","slug":"人生杂谈/自然地理","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/%E8%87%AA%E7%84%B6%E5%9C%B0%E7%90%86/"},{"name":"健康","slug":"人生杂谈/健康","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/%E5%81%A5%E5%BA%B7/"},{"name":"读书","slug":"人生杂谈/读书","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/%E8%AF%BB%E4%B9%A6/"},{"name":"AI","slug":"人生杂谈/AI","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/AI/"},{"name":"小说","slug":"人生杂谈/小说","link":"/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88/%E5%B0%8F%E8%AF%B4/"},{"name":"演讲技巧","slug":"管理/演讲技巧","link":"/categories/%E7%AE%A1%E7%90%86/%E6%BC%94%E8%AE%B2%E6%8A%80%E5%B7%A7/"},{"name":"打码要义","slug":"打码要义","link":"/categories/%E6%89%93%E7%A0%81%E8%A6%81%E4%B9%89/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"技术经典","slug":"技术经典","link":"/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E5%85%B8/"},{"name":"刨码问底","slug":"打码要义/刨码问底","link":"/categories/%E6%89%93%E7%A0%81%E8%A6%81%E4%B9%89/%E5%88%A8%E7%A0%81%E9%97%AE%E5%BA%95/"}],"pages":[{"title":"关于我","text":"大家好，我是内森(GitHub: Nathan Bu)，欢迎来到我的水水水文输出阵地。我2013年毕业于南开大学，目前在微软中国担任研发经理。希望在这个空间和大家分享交流技术心得，职业生涯，团队和项目管理，趋势动态，生活日常。旨在畅谈分享，不拘小节；但也不排除会刨根问底、钻牛角尖。 本人热爱技术和打码，尤其享受用技术解决实际问题的过程；相信创造力是顶级能力，是人价值的放大器。此外，本人专注于软件和代码质量、工程效率和研发能效方面多年，目前在微软和团队一起推动2023年新开源的项目Hydra Lab的完善与发展；欢迎和我在开源世界组队打码，造新轮子，添砖加瓦。 其他爱好有打篮球，翻书，叨逼叨。 自称是个全栈，涉猎的技术：Java, Python, Android, React, Node.JS, Gradle, Docker, C/C++, Spring。 搞过的技术领域： 移动互联网广告、强化学习、工程系统、自动化测试、DevOps、Azure。 能够胡吹的话题： 自动化测试、研发能效、产品质量控制、大型项目管理、人工智能、广告变现、团队管理、高效沟通、企业财务、国民经济。","link":"/about/index.html"},{"title":"","text":"1234567891011121314151617181920212223@startuml strategyclass SolutionContext { IStrategy strategy void solveProblem()}interface IStrategy { int compute()}class StrategyA { int compute()}class StrategyB { int compute()}class StrategyC { int compute()}SolutionContext o--&gt; IStrategyIStrategy &lt;|-- StrategyAIStrategy &lt;|-- StrategyBIStrategy &lt;|-- StrategyC@enduml 1234567891011121314151617181920212223@startuml stateclass TCPConnectionContext { TCPState state void request()}interface TCPState { handle()}class TCPEstablished { handle()}class TCPListen { handle()}class TCPClosed { handle()}TCPConnectionContext o--&gt; TCPStateTCPState &lt;|-- TCPEstablishedTCPState &lt;|-- TCPListenTCPState &lt;|-- TCPClosed@enduml 123456789101112131415161718192021222324252627282930313233343536373839@startuml abstract-factoryclass Clientabstract class AbstractFactory { createProductA() createProductB()}class Factory1 { createProductA() createProductB()}class Factory2 { createProductA() createProductB()}abstract class AbstractProductAabstract class AbstractProductBclass ProductA1class ProductB1class ProductA2class ProductB2ProductA1 -u-|&gt; AbstractProductAProductA2 -u-|&gt; AbstractProductAProductB1 -u-|&gt; AbstractProductBProductB2 -u-|&gt; AbstractProductBFactory1 -u-|&gt; AbstractFactoryFactory2 -u-|&gt; AbstractFactoryFactory1 ...&gt; ProductA1Factory1 ...&gt; ProductB1Factory2 ...&gt; ProductA2Factory2 ...&gt; ProductB2Client --&gt; AbstractProductA : createsClient --&gt; AbstractProductB : createsClient --&gt; AbstractFactory : holds@enduml :memento12345678910111213141516171819@startuml mementoclass Originator{ State state setMemento(Memento m) createMemento()}class Memento { State state}class Caretaker { Memento memento}Originator ..&gt; MementoCaretaker o--&gt; Memento@enduml :observer1234567891011121314151617181920212223242526@startuml observerclass Observer { update()}class ConcreteObserver { observerState update()}class Subject { attach(Observer) detach(Observer) notify()}class ConcreteSubject { subjectState getState() setState()}ConcreteObserver --|&gt; ObserverConcreteSubject --|&gt; SubjectSubject o-- ObserverConcreteSubject --o ConcreteObserver@enduml : adapter123456789101112131415161718@startuml adapterclass Contextclass Target { request()}class Adapter { request()}class Adaptee { specificRequest()}Context --&gt; TargetAdapter --|&gt; TargetAdapter --&gt; Adaptee@enduml : bridge123456789101112@startuml bridgePhone o-- PhoneFunctioniPhone --|&gt; PhoneAndroidPhone --|&gt; PhoneNonsmartPhone --|&gt; PhoneCall --|&gt; PhoneFunctionInstallApp --|&gt; PhoneFunction@enduml : command123456789@startuml commandClient ..&gt; InvokerClient ..&gt; ReceiverInvoker o-- CommandConcreteCommand --|&gt; CommandConcreteCommand *-- Receiver@enduml : chain-of-responsibility1234567891011121314151617@startuml chain-of-responsibilitytogether { class Client class Handler}together { class ConcreteHandler1 class ConcreteHandler2}Client --&gt; HandlerConcreteHandler1 --|&gt; HandlerConcreteHandler2 --|&gt; HandlerConcreteHandler2 o--&gt; Handler@enduml : mediator1234567891011@startuml mediatorMediator &lt;--o ColleagueConcreteColleague1 --|&gt; ColleagueConcreteColleague2 --|&gt; ColleagueConcreteMediator --|&gt; MediatorConcreteMediator --&gt; ConcreteColleague1ConcreteMediator --&gt; ConcreteColleague2@enduml : visitor1234567891011121314151617@startuml visitorclass Visitor { +visitElementA(ElementA elementA) +visitElementB(ElementB elementB)}note top of Visitor : Visitor design enables us to redefine the action/operation on a object without a change to its values.class Element { + accept(Visitor visitor)}ElementA --|&gt; ElementElementB --|&gt; Element@enduml : facade12345678910@startuml facadeClient --&gt; Facadepackage SubSystem{ Facade --&gt; SubSystemA Facade --&gt; SubSystemB Facade --&gt; SubSystemC Facade --&gt; SubSystemD}@enduml : proxy123456789101112@startuml proxyclass Subject { request()}Proxy --|&gt; SubjectRealSubject --|&gt; SubjectProxy --&gt; RealSubject@enduml : decorator123456789101112131415161718192021@startuml decoratorclass Subject { operate()}Decorator --|&gt; SubjectRealSubject --|&gt; SubjectDecorator o--&gt; SubjectConcreteDecoratorA --|&gt; DecoratorConcreteDecoratorB --|&gt; Decoratorclass ConcreteDecoratorA { -addedState}class ConcreteDecoratorA { -addedBehavior}@enduml : interpreter12345678910111213@startuml interpreterabstract Expression { +interpret(Context context)}Client --&gt; ContextClient --&gt; ExpressionTerminalExpression --|&gt; ExpressionNonterminalExpression --|&gt; ExpressionNonterminalExpression o--&gt; Expression@enduml","link":"/images/UML/design-patterns.html"}]}