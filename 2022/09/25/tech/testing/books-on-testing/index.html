<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>测试类书籍阅读笔记综述 - 内森淼文</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="内森淼文"><meta name="msapplication-TileImage" content="/images/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="内森淼文"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="近期阅读和重读了一些测试相关的书籍，深感测试也是一门工程学问。汇总综述所学于此。"><meta property="og:type" content="blog"><meta property="og:title" content="测试类书籍阅读笔记综述"><meta property="og:url" content="https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/"><meta property="og:site_name" content="内森淼文"><meta property="og:description" content="近期阅读和重读了一些测试相关的书籍，深感测试也是一门工程学问。汇总综述所学于此。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/books.png"><meta property="article:published_time" content="2022-09-24T16:04:49.000Z"><meta property="article:modified_time" content="2023-03-09T01:14:59.793Z"><meta property="article:author" content="Nathan"><meta property="article:tag" content="测试"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/books.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/"},"headline":"测试类书籍阅读笔记综述","image":["https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/books.png"],"datePublished":"2022-09-24T16:04:49.000Z","dateModified":"2023-03-09T01:14:59.793Z","author":{"@type":"Person","name":"Nathan"},"publisher":{"@type":"Organization","name":"内森淼文","logo":{"@type":"ImageObject","url":"https://hydraxman.github.io/images/logo.svg"}},"description":"近期阅读和重读了一些测试相关的书籍，深感测试也是一门工程学问。汇总综述所学于此。"}</script><link rel="canonical" href="https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/"><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.svg" alt="内森淼文" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="My GitHub Index" href="https://github.com/hydraxman"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-24T16:04:49.000Z" title="9/25/2022, 12:04:49 AM">2022-09-25</time>发表</span><span class="level-item"><time dateTime="2023-03-09T01:14:59.793Z" title="3/9/2023, 9:14:59 AM">2023-03-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E7%BB%8F%E5%85%B8/">技术经典</a></span><span class="level-item">3 小时读完 (大约26224个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">测试类书籍阅读笔记综述</h1><div class="content"><blockquote>
<p>近期阅读和重读了一些测试相关的书籍，深感测试也是一门工程学问。汇总综述所学于此。</p>
</blockquote>
<span id="more"></span>

<h1 id="阅读书目"><a href="#阅读书目" class="headerlink" title="阅读书目"></a>阅读书目</h1><table>
<thead>
<tr>
<th>书名</th>
<th>出版时间</th>
<th>阅读状态</th>
<th>快评</th>
<th>ISBN</th>
</tr>
</thead>
<tbody><tr>
<td>软件测试</td>
<td>2006.4</td>
<td>笔记待整理</td>
<td>不用仔细看，太旧</td>
<td>9787111185260</td>
</tr>
<tr>
<td>微软的软件测试之道</td>
<td>2009</td>
<td>阅读中</td>
<td>知识梳理</td>
<td>9787111277538</td>
</tr>
<tr>
<td>Google软件测试之道</td>
<td>2013.10</td>
<td>尚未开始</td>
<td>值得阅读</td>
<td>9787115330246</td>
</tr>
<tr>
<td>探索式软件测试</td>
<td>2010.4</td>
<td>尚未开始</td>
<td>快速阅读</td>
<td></td>
</tr>
<tr>
<td>大话软件测试</td>
<td>2018.11</td>
<td>笔记待整理</td>
<td>快速阅读</td>
<td></td>
</tr>
<tr>
<td>软件测试的艺术</td>
<td>2012.3</td>
<td>阅读中</td>
<td>值得阅读</td>
<td></td>
</tr>
<tr>
<td>腾讯Android自动化测试实战</td>
<td>2016.9</td>
<td>阅读中</td>
<td>主要看技术框架</td>
<td></td>
</tr>
<tr>
<td>构建之法</td>
<td>2015.3</td>
<td>阅读中</td>
<td>学习写作方法, 要看</td>
<td>9787115460769</td>
</tr>
<tr>
<td>测试驱动开发</td>
<td>2004.3</td>
<td>笔记待整理</td>
<td>快速阅读</td>
<td></td>
</tr>
<tr>
<td>测试驱动开发的艺术</td>
<td>2010.11</td>
<td>尚未开始</td>
<td>值得阅读</td>
<td></td>
</tr>
<tr>
<td>A Practical Guide to Testing in DevOps</td>
<td></td>
<td>尚未开始</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mobile Test Automation with Appium</td>
<td></td>
<td>尚未开始</td>
<td></td>
<td></td>
</tr>
<tr>
<td>探索吧！深入理解探索式软件测试</td>
<td>2014.1</td>
<td>尚未开始</td>
<td></td>
<td>9787111451587</td>
</tr>
<tr>
<td>全程软件测试</td>
<td>2019.1</td>
<td>尚未开始</td>
<td></td>
<td>9787115496560</td>
</tr>
<tr>
<td>颠覆完美软件</td>
<td>2015.7</td>
<td>尚未开始</td>
<td></td>
<td>9787121258619</td>
</tr>
<tr>
<td>大话移动APP测试</td>
<td>2014.7</td>
<td>尚未开始</td>
<td>快速阅读或者不读</td>
<td>9787302368793</td>
</tr>
<tr>
<td>单元测试的艺术</td>
<td>2014.8</td>
<td>尚未开始</td>
<td>快速阅读</td>
<td>9787115360359</td>
</tr>
</tbody></table>
<h1 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h1><p>测试分类：</p>
<ul>
<li>功能测试</li>
<li>非功能测试</li>
</ul>
<h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><p><img src="/2022/09/25/tech/testing/books-on-testing/books.png"></p>
<h2 id="构建之法"><a href="#构建之法" class="headerlink" title="构建之法"></a>构建之法</h2><p>我成为了一名职业程序员，但是我发现所有的算法别人都已经实现了，我只要调用就可以。似乎我们公司的软件与数据结构、算法的关系都不大。那我当初辛辛苦苦学习的数据结构和算法有用么？如何区分一个好的程序员和不好的程序员呢？ </p>
<blockquote>
<p> 体会：书中举的四则运算的例子做深了以后可能还涉及一些相对比较复杂的算法，可是在现实中接触到的系统很多是业务驱动的系统，用户量可能不会超过2000，CRUD，业务复杂流程交给成熟的工作流系统去做了，CRUD是很简单的数据库表操作，数据库操作有现成的框架，前端有现成的框架，后端有现成的框架，程序员要做的事情就是熟悉现有的框架，完成相应的业务模块的开发。典型的开发过程是：拿到一个业务需求，建模-&gt;转换成实体类-&gt;对这个实体类的CRUD-&gt;拖出一个工作流流程图-&gt;把流程涉及的表单用前端框架做好-&gt;调用封装好的工作流的方法实现业务流程操作。在整个过程中，似乎用不到任何复杂一些的算法和数据结构（最多可能会考虑一下实体类之间一对多之间的关系），但是仍旧有些程序员做的很好，bug非常少，功能也很稳定，有些bug很多，这样可以区分去好的程序员和不好的程序员么?</p>
</blockquote>
<blockquote>
<p>xinz: 从老板&#x2F;经理的角度来看， 你提到的稳定易用的 CRUD 模型是不是正和他们的意愿？ 就像建房子，并不是每一个房子都是世界级的挑战，前人从来没有碰到过。   把基本的工作不断做得更完美， 就是很好的工程师。</p>
</blockquote>
<p>把所有的错误记在一个“我常犯的错误”表中，作为以后自我复审的第一步。</p>
<p>什么是好的软件？一些同学认为，所谓好软件，就是软件没有缺陷（Bug），所谓软件工程，就是把软件中的Bug都消灭掉的过程。这的确是抓住了软件工程的一个要素。和软件打交道的专业人士都知道软件有“Bug”（缺陷），软件团队的很多人都整天和Bug打交道，Bug的多少可以直接衡量一个软件的开发效率、用户满意度、可靠性和可维护性。 ——P15</p>
<p>很多人认为有Bug就是质量不合格，没有Bug就是质量完美，其实这也未必。我们在大街上看到很多小汽车，这些汽车出厂时都通过了各自的质量检测，符合行业的质量标准。但是你问路人哪些车的“质量好”，很多人会告诉你有些车的质量大大好于另外一些车，那为什么还有人买那些质量“不够好”的汽车呢？对于某些顾客来说，某一类的汽车满足了他们的需求，他们就会买。如果销售人员不经市场调研胡乱推销自己公司的汽车，最后销量未必理想。 市面上有这么多不完美的产品，软件团队为什么还要把这些不完美的软件发布出来呢？为什么不能等到它们完美之后再发布？**软件工程的一个重要任务，就是要决定一个软件在什么时候能“足够好”，可以发布。</p>
<p>既然代码复审能发现这么多问题，有这么好的效果，如果我们每时每刻都在代码复审的状态，那不是很好么？事实上，极限编程（Extreme Programming）正是这一思想的体现——为什么不把一些卓有成效的开发方法用到极致（Extreme），让我们无时无刻地使用它们？ ——p84页 </p>
<p>极限编程对工程师提出了更高的要求。这种要求不关乎技术水平，也不关乎学历水平或工作经验。这种要求是对一个人的心智、道德修养的更高要求。<strong>结队编程中，编码不再是私人的工作，而是一种公开的“表演”</strong>。程序员的代码、工作方式、技术水平都变得公开和透明，这也许是一些人不喜欢这一方式的原因。 ——P87</p>
<p>用户体验设计的一个重要目的就是要降低用户的认知阻力（Cog-nitive Friction），即用户对于软件界面的认知（想象某事应该怎么做，想象某操作应该产生什么结果）和实际结果的差异。我们来看一个具体的例子，如果用户（一个生活在中国二线城市，有高中文化水平，有基本计算机基础的成年人）要在一个文稿中写居中的一句话，在下表所列的各种工具中，用户是怎么才能做到的。 倘若认知阻力大，学习曲线就会比较陡；但是经过学习和练习，如果用户适应了新的认知模式，工作效率便会有较大的提高。</p>
<p>一个成熟的软件工程师应该能够降低任务交付时间的标准方差。 软件领域可以分为两个方面：一方面是技艺创新的大爆发；而另一方面是坚持不懈的工程工作，包括软件的改善、维护和测试等，这一方面占了 90%~95% 的比例。</p>
<p>1）软件构建：除了代码和静态数据，还有各种文件和数据来描述各个程序文件之间的依赖关系等；<br>2）源代码管理&#x2F;配置管理：保证代码的平台兼容性、配置兼容性等；<br>3）质量保障（软件测试）：保证软件的质量在修改过程中可以不断提高，或者至少可以保持；<br>4）项目管理：软件维护和服务运营<br>5）生命周期：以上称为软件的生命周期SLC</p>
<p>对于后来者，一个赶上的办法就是把别人的优势变成大路货（Commodity）。</p>
<p>牛人主导的项目，往往会大起大落。PM 主导的产品中，“不犯大错”成了一个特点，微软的很多产品在长期竞争中，靠“不犯大错”，从第三版开始，赶上并超越竞争对手。这也是了不起的能力。</p>
<p>压力测试严格地说不属于效能测试，压力测试要验证的问题是: 软件在超过设计负载的情况下能否仍能返回正常结果，没有产生严重的副作用或崩溃。</p>
<p>有人说一个人就可以快速成长为一名全栈工程师，这让我想起街头卖艺的单人乐队(One-man-band), 他们什么都会一些，可以很快地演奏一些曲子。</p>
<p>术产品的发展周期（萌芽-&gt;成长-&gt;成熟-&gt;衰退-&gt;结束）</p>
<p>软件工程是把系统的、有序的、可量化的方法应用到软件的开发、运营和维护的上的过程。软件工程包括下列领域：软件需求分析、软件设计、软件构建、软件测试和软件维护。软件工程和下列的学科相关：计算机科学、计算机工程、管理学、数学、项目管理学、质量管理、软件人体工学、系统工程、工程设计和用户界面设计。</p>
<p>设想和目标</p>
<ol>
<li>我们的软件要解决什么问题？是否定义得很清楚？是否对典型用户和典型场景有清晰的描述？</li>
<li>是否有充足的时间来做计划？</li>
<li>团队在计划阶段是如何解决同事们对于计划的不同意见的？用户量、用户对重要功能的接受程度和我们事先的预想一致么？我们离目标更近了么？有什么经验教训？如果历史重来一遍，我们会做什么改进？<br>计划</li>
<li>你原计划的工作是否最后都做完了？如果有没做完的，为什么？</li>
<li>有没有发现你做了一些事后看来没必要或没多大价值的事？</li>
<li>是否每一项任务都有清楚定义和衡量的交付件？</li>
<li>是否项目的整个过程都按照计划进行？</li>
<li>在计划中有没有留下缓冲区，缓冲区有作用么？</li>
<li>将来的计划会做什么修改？（例如：缓冲区的定义，加班。）我们学到了什么？如果历史重来一遍，我们会做什么改进？<br>资源</li>
<li>我们有足够的资源来完成各项任务么？</li>
<li>各项任务所需的时间和其他资源是如何估计的，精度如何？</li>
<li>测试的时间、人力和软件&#x2F;硬件资源是否足够？对于那些不需要编程的资源（美工设计&#x2F;文案）是否低估难度？</li>
<li>你有没有感到你做的事情可以让别人来做（更有效率）？有什么经验教训？如果历史重来一遍，我们会做什么改进？<br>变更管理</li>
<li>每个相关的员工都及时知道了变更的消息吗？</li>
<li>我们采用了什么办法决定“推迟”和“必须实现”的功能？</li>
<li>项目的出口条件（Exit Criteria——什么叫“做好了”）有清晰的定义么？</li>
<li>对于可能的变更是否能制定应急计划？</li>
<li>员工是否能够有效地处理意料之外的工作请求？我们学到了什么？<br>如果历史重来一遍，我们会做什么改进？<br>设计&#x2F;实现</li>
<li>设计工作在什么时候，由谁来完成？是合适的时间，合适的人么？</li>
<li>设计工作有没有碰到模棱两可的情况，团队是如何解决的？</li>
<li>团队是否运用单元测试（Unit Test）、测试驱动的开发（TDD）、UML或者其他工具来帮助设计和实现？这些工具有效么？</li>
<li>什么功能产生的Bug最多，为什么？在发布之后发现了什么重要的Bug？为什么我们在设计&#x2F;开发时没有想到这些情况？</li>
<li>代码复审（Code Review）是如何进行的，是否严格执行了代码规范？<br>我们学到了什么？如果历史重来一遍，我们会做什么改进？<br>测试&#x2F;发布</li>
<li>团队有没有测试计划？为什么没有？</li>
<li>有没有做过正式的验收测试？</li>
<li>团队是否有测试工具来帮助测试？</li>
<li>团队是如何测量并跟踪软件的效能的？从软件实际运行的结果来看，这些测试工作有用么？应该有哪些改进？</li>
<li>在发布的过程中发现了哪些意外问题？我们学到了什么？如果历史重来一遍，我们会做什么改进？<br>总结：<br>你觉得团队目前的状态属于CMMI中的哪个级别？<br>你觉得团队目前处于萌芽&#x2F;磨合&#x2F;规范&#x2F;创造阶段的哪一个阶段？<br>你觉得团队在这个里程碑相比前一个里程碑有什么改进？<br>你觉得目前最需要改进的一个方面是什么？<br>引自 15.3 事后诸葛亮会议</li>
</ol>
<h2 id="Google软件测试之道"><a href="#Google软件测试之道" class="headerlink" title="Google软件测试之道"></a>Google软件测试之道</h2><p>在测试上难以自动化的软件，很难成为好的软件。</p>
<p>除此之外，安排好优先级，寻找小成本大回报的自动化项目。一定要记住自动化并不能解决所有问题，尤其是前端项目和设备测试。</p>
<p>我首先会让我的团队思考，“对被测系统来说，什么是最为重要的东西？”对搜索来说是性能，对新闻来说是时效性，对地图来说是综合性和完整性。每个应用都有其最重要的属性。类似的，对系统基础架构来说，数据完整性对存储最为重要，可扩展性对网络系统最为重要，利用率对任务管理系统最为关键。当你分清了你要测试的特定产品的关键因素以后，就要把你的大部分精力集中在检验系统的核心能力是不是能够满足这些关键属性要求上。 当这些重要的事情搞定以后，再去关心那些简单的事情（用户界面这些锦上添花的东西）。还要关注那些核心的不容易改动的方面（如性能设计），而不对那些很容易修改的方面花费太多精力。如果你过早报告关于字体的bug，我就会担心你是不是没有搞清楚事情的优先次序。</p>
<p>质量不等于测试。当你把开发过程和测试放到一起，就像在搅拌机里混合搅拌那样，直到不能区分彼此的时候，你就得到了质量。</p>
<p>SET编写代码，通过这些代码提供的功能让SWE能够自己测试他们的功能。多数测试代码是由SWE完成，SET存在的目的就是保证这些功能模块具有可测试性，并且响应的SWE还可以积极的参与到测试代码的编写中。</p>
<p>我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。我喜欢由快速迭代和高质量带来的挑战。这两者相互矛盾但又都很重要。</p>
<p>如果能够自动化，并不需要人脑的睿智与直觉来判断，那就应该以自动化的方式实现。</p>
<p>通过使用定位点击的验证方式、录制技术等可以把一些手动测试转变成自动化测试，这些自动化测试在每次建立之后都会重复地回归运行，而手动测试更倾向于关注于新功能。</p>
<p>Google测试成功的关键是什么？不要招聘太多的测试人员，写代码的开发人员也承担了质量的重任。 开发和测试并肩齐驱。<strong>Google能用如此少的专职人员的原因，就是开发对质量负责。这意味着质量更像是一种预防行为，而不是检测。质量是开发过程的问题，而不是测试问题。</strong></p>
<p>开发团队在寻求测试帮助的时候，有义务让测试人员相信他们的产品是令人兴奋且并充满希望的。在Chrome OS的开发总监给我们介绍他们项目、进度和发布计划时，我们也要求提供当前已有的测试状态、期望的单元测试覆盖率水平、以及明确在发布过程中各自承担的责任。</p>
<p>mock对象是指对外面依赖系统的模拟，在运行时刻可以根据假设的需求提供期望的结果。fake对象是一种虚假的实现，内部使用了固定的数据或逻辑，只能返回特定的结果。</p>
<h2 id="探索吧！深入理解探索式软件测试"><a href="#探索吧！深入理解探索式软件测试" class="headerlink" title="探索吧！深入理解探索式软件测试"></a>探索吧！深入理解探索式软件测试</h2><p>测试的本质就在于此：设计一个试验以便收集经验证据，由此解答与风险相关的问题。</p>
<p>探索式测试就是同时进行学习、测试设计和测试执行。</p>
<p>探索时，想到某个测试之后就要立刻执行。 这一点至关重要：除非你执行这些测试，不然的话，你怎么知道接下来还会冒出些什么问题等你去调查呢。</p>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>软件测试工程师不负责软件的质量！医生测量体温不能退烧、气象专家测量风速不能阻止阻止风暴，同样软件测试工程师寻找缺陷并不能使质量低劣的产品变好！软件测试工程师只能报告事实、提供数据。即便测试工程师竭尽全力使发现的bug都得以修复，也不能使质量本身低劣的产品变好，质量不是靠测试来解决的。</p>
<p>持续的培训、充分论证的设计、经过业界论证的开发方法、持续保障的流程等，都能减少bug。</p>
<ol>
<li><p>只有至少满足下列5个规则之一才称发生了一个Bug：</p>
<ol>
<li>软件未实现产品说明书（product specification）要求的功能。</li>
<li>软件出现了产品说明书指明不应该出现的错误。</li>
<li>软件实现了产品说明书未提到的功能。</li>
<li>软件未实现产品说明书虽未明确提及但应该实现的目标。</li>
<li>软件难以理解，不易使用，运行缓慢或者–从测试员的角度看–最终用户会认为不好。</li>
</ol>
</li>
<li><p>软件测试员的目标是尽可能早地找出软件缺陷，并确保其得以修复。</p>
</li>
<li><p>次边界条件：2的幂，ASCII表等，默认值、空白、空值、零值和NULL</p>
</li>
<li><p>测试软件兼容性时选择程序的标准：流行程度、年头、类型、生产厂商。</p>
</li>
<li><p>优秀UI的7个要素：符合标准和规范、直观、一致、灵活、舒适、正确、实用。</p>
</li>
<li><p>DREAD Formula：潜在的危害、可反复性、可利用性、受影响的用户、可发现性。</p>
</li>
<li><p>Beta测试是将软件分发给选定的潜在客户群，让他们在实际环境中使用软件。Beta测试时寻找配置、兼容性和易用性缺陷的好方法，但对寻找普通软件缺陷表现很差。不能依靠Beta测试来代替实际测试。</p>
</li>
<li><p>测试计划的目的：<br> 规定测试活动的范围、方法、资源和进度；明确正在测试的项目、要测试的特性、要执行的测试任务，每个任务的负责人，以及与计划相关的风险。<br> 测试计划的最终目标是交流（而不是记录）软件测试小组的意图、期望，以及对要执行的测试任务的理解。重要的是计划过程，而不是产生的结果文档。<br> 产品的质量和可靠性目标必须明确，必须绝对。</p>
</li>
<li><p>Alpha版本：意在对少数主要客户和市场进行数量有限的分发、用于演示目的的早期版本。</p>
</li>
<li><p>报告软件缺陷的基本原则：<br>（1）尽快报告Bug<br>（2）有效描述Bug<br>（3）在报告Bug时不要做评价<br>（4）对Bug跟踪到底，跟踪其生命周期</p>
</li>
<li><p>有效描述Bug：<br>（1）短小<br>（2）单一：一个报告只针对一个软件缺陷<br>（3）明显且通用。使用简明易行的步骤来描述发现Bug的过程，分离Bug<br>（4）可再现</p>
</li>
<li><p>计划测试用例的4个原则：组织、重复性、跟踪和测试证实。</p>
</li>
<li><p>分离和再现Bug<br>（1）不要想当然地接受任何假设，记下所做的每一件事<br>（2）查找时间依赖和竞争条件的问题<br>（3）查找边界条件、内存泄露和数据溢出问题<br>（4）状态缺陷仅在特定的软件状态中显露出来，重要的是事件的次序<br>（5）考虑资源依赖性和内存、网络、硬件共享的相互作用<br>（6）不要忽视硬件</p>
</li>
<li><p>严重性：Bug的恶劣程度，当用户碰到该缺陷时影响的可能性和程度<br>1：系统崩溃、数据丢失、数据毁坏、安全性被破坏<br>2：操作性错误、结果错误、功能遗漏<br>3：小问题、拼写错误、UI布局、罕见故障<br>4：建议</p>
</li>
<li><p>优先级：修复Bug的重要程度和紧迫程度<br>1：立即修复，阻止了进一步测试<br>2：在产品发布前必须修复<br>3：如果时间允许应该修复<br>4：可能会修复，但即使有此Bug产品也能发布</p>
</li>
<li><p>常用项目级Bug度量<br>（1）将Bug按发现的功能区域进行划分<br>（2）发现的Bug随时间推移的情况<br>（3）随时间推移累计发现的Bug。Resolved&#x2F;Fixed Bugs<br>（4）需标明项目的进度和重大事件</p>
</li>
<li><p>软件质量保证人员的主要职责是检查和评价当前软件开发的过程，找出改进过程的方法，以达到防止软件缺陷出现的目标。</p>
</li>
<li><p>软件测试员不负责软件的质量，质量不是靠测试来解决的。</p>
</li>
<li><p>假设自己是客户；像黑客一样考虑问题。</p>
</li>
<li><p>产品说明书属性检查清单：完整；准确；精确，不含糊；前后一致；贴切；合理；代码无关；可测试性</p>
</li>
<li><p>状态测试的方法：<br>（1）每种状态至少测试一次<br>（2）测试最常见和最普遍的状态转换<br>（3）测试最不常用的分置<br>（4）测试所有错误状态及其返回值<br>（5）测试随机状态转换</p>
</li>
<li><p>硬件配置测试：明确与硬件配置有关的特性。<br>软件兼容性测试：测试程序之间不同的数据流动方式。</p>
</li>
<li><p>网站测试<br>（1）首先建立状态表，把每个网页当做不同的状态，链接当做状态之间的连接线<br>（2）通过大幅缩放浏览器窗口来检查文字布局问题<br>（3）查找孤页，向网页设计人员索要网页清单</p>
</li>
<li><p>半聪明的猴子：记录行为日志，只在被测试软件商运行，具备崩溃辨认能力。聪明的猴子：会阅读软件的状态转换图，能够验证遇到的情况。</p>
</li>
</ol>
<p>灰盒测试（gray-box testing）把黑盒测试和白盒测试的界限打乱了。仍然把软件当作黑盒来测试，但是通过简单查看（不是像白盒测试那样完整地查看）软件内部工作机制作为补充。</p>
<p>能力成熟度模型（CMM）</p>
<p>5级CMMI成熟度描述如下：</p>
<ul>
<li>1级：初始的。该等级的软件开发过程是随意的，常常很混乱。项目成功依靠个人英雄的行为和运气。过程没有通用的计划、监视和过程控制。开发软件的时间和费用无法预知。测试过程与其它过程混杂在一起。</li>
<li>2级：可重复的。该等级成熟度的最好描述是项目级的思想。使用基本项目管理过程来跟踪项目费用、进度、功能和质量。以前类似的项目经验可以应用到当前项目当中。该等级有一定的组织性，使用了基本软件测试行为，例如测试计划和测试用例。</li>
<li>3级：定义的。该等级具备了组织化思想，而不仅仅是针对具体项目。通用管理和工程活动被标准化和文档化。这些标准在不同的项目中得到采用并得到证实。当压力增加时，不会放弃规则。当测试开始之前，要审查和批准测试文档和计划。测试团队与开发人员独立。测试结果用于确定软件完成的时间。</li>
<li>4级：可管理的。在该成熟度等级中，组织过程处于统计的控制之下。产品质量事先以量化的方式指定（例如，产品直到每1000行代码只有0.5个以下毛病时才能发布），软件在未达到目标之前不得发布。在整个项目开发过程中，收集开发过程和软件质量的详细情况，经过调整校正偏差，使项目按计划进行。</li>
<li>5级：不断优化的。该等级成为不断优化（不是“已经优化”）是因为它从4级不断提高。尝试新的技术和处理过程，评价结果，采用提高和创新的变动以期达到质量更佳的等级。正当所有人认为已经达到最佳时，新的想法又出现了，再次提高到下一个等级。</li>
</ul>
<h2 id="软件测试的艺术"><a href="#软件测试的艺术" class="headerlink" title="软件测试的艺术"></a>软件测试的艺术</h2><p>提出了软件测试的心理学和经济学。</p>
<p>测试是为发现错误而执行程序的过程</p>
<ol>
<li>测试用例中一个必需部分是<strong>对预期输出或结果进行定义</strong></li>
<li>程序员应该避免测试自己缩写的程序</li>
<li>编写软件的组织不应当测试自己编写的软件</li>
<li>应当彻底检查每个测试的执行结果</li>
<li>测试用例的缩写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和末预料到的输入情况</li>
<li>检查程序是否“末做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”</li>
<li>应避免测试用例用后即弃，除非软件本身就是一个一次性的软件</li>
<li>计划测试工作时不应默许假定不会发现错误</li>
<li>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比</li>
<li>软件测试是一项极富创造性、极具智力挑战性的工作</li>
</ol>
<p>在代码检查进行时，主要进行两项活动：</p>
<ol>
<li>由程序编码人员逐条语句讲述程序的软件结构。……换句话说，对着大家大声朗读程序，这种简单的做法看来是一个非常有效的错误检查办法</li>
<li>对着历来常见的编码错误列表分析程序</li>
</ol>
<p>我们推荐的步骤是先使用黑盒测试方法来设计测试用例，然后视情况需要使用白盒测试方法来设计补充的测试用例</p>
<p>软件测试经济学</p>
<p>黑盒测试</p>
<p>不需要去了解程序的内部结构<br>穷举输入测试是无效的<br>软测经济学：要用有限的测例，发现最多的错误</p>
<p>白盒测试</p>
<p>穷举路径测试不可行：</p>
<p>  问题1：不同逻辑路径测例数量可能达到天文数字</p>
<p>  问题2：即使真的测试完所有路径，可能仍有错</p>
<pre><code>1：程序不符合设计规范（比如设计的目的是向左，做的是向右）

2：程序缺少路径（已有的路径虽然没错）

3：数据敏感错误（如比较的是绝对值，但比的没有加| |） 
</code></pre>
<p>1.测试是为了发现错误而执行程序的过程。正向测试验证功能，但核心内容是反向测试，发现错误。<br>测试人员首先要直觉认为被测物有错误需要去发现。</p>
<p>2.从心理学观点论述了为什么开发人员不能做测试。以及如何逐渐一个合理的团队，最好是独立的测试部门。</p>
<p>3.能发现错误的测试用例才是成功的用例。 全部测试用例通过，不能作为测试结束的标志。给出了3个测试结束准则。</p>
<p>4.该书多次提到，任何方式方法都有局限性，需要对不同问题采取不同的方法。</p>
<p>5.调试（Debug）一章强调了用思考去解决问题，而非大量的print,trace和debugger的内存观察。有时人会偷懒而采取暴力调试，及不去思考，胡乱修改代码来猜测问题。<br>调试方式也是启发式解决问题的方法。</p>
<p>6.两次提到“采集-分析-汇总-提高”。及开发、测试过程要留心去总结提高，建立项目和个人的 bug、易犯错误表，调试错误分析表等。</p>
<p>7.增量测试和XP方法: 做事先有计划，然后由小到大，一步一个脚印，后一步踩在前一步上。</p>
<p>8.测试过程有很多方法都需要经验和直觉。测试是个复杂的脑力劳动。</p>
<h2 id="探索式软件测试"><a href="#探索式软件测试" class="headerlink" title="探索式软件测试"></a>探索式软件测试</h2><p>总得来说，James 把手工测试的一些方法，假借旅游的名义，设计了一套漫游测试的理念，重点是这些理念所引发出来的不同角度的测试点的关注，所以和国内流行的等价类、边界值等等各种测试用例设计方法是一个目的，但是角度不同。</p>
<p>书中一共分 8 个正式的章节，3 个附录。</p>
<p>书中第 1 章用了 4 个曾经发生过的关于软件质量的例子，让我们理解什么是软件缺陷，并对软件缺陷造成的影响有简单的了解。</p>
<p>第 2 章介绍了软件缺陷的根源，以及各种缺陷预防和检测的策略，并引申出后面要讲的重点内容「探索式测试」。</p>
<p>第 3 章根据软件的各种属性，分别从输入、状态、代码路径、用户数据和执行环境这 5 个部分提出了对应的测试关注点，以及怎么考虑到这些关注点，角度总结的很不错，详细内容建议粗读，吸取里面的精髓即可。</p>
<p>第 4、5、6 章是真正的使用漫游测试的概念，把旅游中可能出现的场景同我们的软件测试点进行关联，从而让我们有一套完整的去考虑手工测试覆盖率的方法论，虽然有点晦涩，但还是推荐详细读一下第 4 章，并把里面的内容同我们现在的做法结合起来看看。</p>
<p>第 7 章总结了漫游与测试中的五个棘手问题，不得不佩服 James 的总结提炼能力，每个问题都总结的很到位，我们可以看看是否和我们当前工作中碰到的问题类似，如果是，James 刚好提供了漫游测试的解决方案。</p>
<p>第 8 章软件测试的未来，这个话题就像惯例一样的存在，当然，相对于在《Google 软件测试之道》里面的预测，这次的内容我认为简单看看就行了。</p>
<p>接着是附录，重点推荐下附录1，里面通过上山、巅峰和下山的比喻，详尽的描述了成功的软件测试职业生涯的完整面貌，一定要反复多读几遍，细嚼慢咽。</p>
<p>使用探索式测试并不是说不写文档。测试结果、测试实例和测试文档都会在运行测试时创建。这和普通测试在测试计划里预先编写好截然不同。用于记录探索式测试结果的最佳工具就是那些截屏软件和记录击键的软件。探索性测试处理这个问题的方法是计划、测试，然后再计划，每次前进一小步，试图以所有过去的知识和现在的信息，（就是怎样运行目标软件和测试结果得到的线索）来作为测试的指导。</p>
<h2 id="微软的软件测试之道"><a href="#微软的软件测试之道" class="headerlink" title="微软的软件测试之道"></a>微软的软件测试之道</h2><h3 id="第3章-工程生命周期"><a href="#第3章-工程生命周期" class="headerlink" title="第3章  工程生命周期"></a>第3章  工程生命周期</h3><p>瀑布模式</p>
<p>瀑布模式是最常见的软件开发模式之一。在这种软件开发方式中，每一个阶段的结束同时也是下一个阶段的开始。</p>
<p>要求→程序设计→编程→测试→维护</p>
<p>好处：当你开始一个新的阶段的时候，前一阶段的所有工作都已完成，能够强制你在动手写程序之前尽可能多的进行思考和设计。<br>坏处：不够灵活，不允许阶段的重复。</p>
<p>螺旋模式</p>
<p>“螺旋”是一个包含四个主要阶段的迭代过程：<br>     确定目标（为项目的当前阶段确定和设定特定的目标）、<br>     风险评估（确认主要风险、减少风险及应急计划。风险可能包括超支或资源问题）、<br>     工程实现（是完成工作的阶段，包括需求、设计、开发、测试、等等）、<br>     和下一迭代规划：对项目评估，并开始计划下一轮的“螺旋”。</p>
<p>重复使用原型来让风险最小化是螺旋模式的另一重要概念。初始模式构建于早起设计之上并接近最终产品的特性。在后续迭代过程中，原型可以帮助我们评估工程系统的优缺点和风险。</p>
<p>敏捷开发</p>
<p>特征：<br>     频繁而短暂的迭代：敏捷团队致力于快速发布软件，并且有做到这一点的记录。<br>     强调面对面的交流和协作：敏捷团队注重队员相互间和与顾客之间的交流。<br>     对产品要求变化的适应力：短暂迭代允许他们频繁的对变化区分优先次序和应对。<br>     贯穿适中的质量责任制：在敏捷开发团队里，单元测试广泛的为开发人员所用。很多人使用TDD（Test-driven Development, 即测试驱动的开发方法）。开发人员先写单元测试程序，然后在实现产品功能已通过测试的开发方法。</p>
<p>里程碑模式</p>
<p>里程碑进度计划建立了项目发布的时间表，也包含了关键的过渡安排和中期版本的时间表。它帮助每个团队了解整个项目的期望值和现状。</p>
<p>要完成一个里程碑，必须满足具体的、事先定义好的阶段结束标准。通常包括：<br>     关键功能编程完毕。即使尚未完全测试，但关键功能已经实现。<br>     中企测试目标达到。如代码覆盖目标或测试完成率目标达成。<br>     BUG目标达到。如无第一类严重BUG或无当机的BUG。<br>     非功能目标达到。如性能、负荷测试完成且无严重问题。</p>
<p>各阶段的标准随着每一个里程碑的推进而日趋严格，直到团队达到了最终完成产品的标准。</p>
<p>里程碑（或其它任何一种迭代模式）的另一个优点是，在每一个里程碑阶段中，团队都能通过一步步迈向发布而积累经验。而且每一里程碑发布的产品都是一个完整的产品，都可以用于大范围的试用。</p>
<p>宏观视野</p>
<p>代码→函数→产品功能→项目→产品线</p>
<p>流程改进</p>
<p>PDCA循环：计划、执行、检查、处理，循环。</p>
<p>第二部分 关于测试</p>
<h3 id="第4章-软件测试用例设计的实用方法"><a href="#第4章-软件测试用例设计的实用方法" class="headerlink" title="第4章  软件测试用例设计的实用方法"></a>第4章  软件测试用例设计的实用方法</h3><p>设计是一个在开始具体实现解决方案以前，系统的思考或计划这个解决方案的行为。认真仔细的计划和设计可以提高测试在其整个生命周期中的价值。</p>
<p>软件设计包括制定计划和解决难题。它包括对用户体验的预见和对解决方案以及备选方案的重要分析。</p>
<p>测试设计需要从计划和问题解决方面来决定做哪些测试，以及哪种测试在验证功能和确认错误路径处理得当上是最有效的。良好的测试设计通常从对软件设计的审查或批评开始。一个好的设计审查会对所有主要的设计决策中的各种备选方案做深度比较。</p>
<p>测试模板属性：名称、问题、分析、设计、预言、用例、缺陷和局限、相关的模式。</p>
<p>测试时间估计中应该要考虑的一些因素：历史数据、复杂度、商业目标、一致性和服从性。</p>
<p>测试设计的一个起点可以是对软件的功能规格和需求的审查。如果已经具备了良好的产品功能需求，基于需求的测试会是一个不错的出发点。如果没有产品需求，那么最好的测试设计的出发点就是问问题。问一下这个软件应该如何工作，如何处理数据，如何处理错误。</p>
<p>如果代码已经存在，但是需求或者功能规格并没有到位，最好的开始测试设计的方法就是运行这个应用程序。</p>
<p>探索性测试，也就是测试和设计测试同时进行，可以很大程度地影响测试设计而且对于整个测试设计过程也是很有利的一部分。</p>
<p>测试策略：测试的种类、进程，和测试时测试团队采用什么方法。它包括对风险的预估以帮助团队决定错误最有可能发生在哪里或者某些组件是否可能需要更加全面彻底的测试。这个策略通常包括对测试团队培训和教育的计划。</p>
<p>测试策略属性：介绍、需求规格、关键背景、测试方法可交付使用的测试（测试结果；代码覆盖率；规格说明完成的状况；缺陷的比率和趋势；使用场景的性能测试结果）、培训。</p>
<p>可测试性是指软件可以被完全有效测试的程度。选择不同的设计、选择简单的算法，使用测试hook和让内部变量可见都是如何提高可测试性的例子。</p>
<p>测试人员可以用来提高可测试性的最普遍的方法就是在需求或设计评审中简单的问，“我们如何来测试这个东西？”</p>
<p>一个简单的可测试性的模式：SOCK——简单、可见、控制、知识。</p>
<p>一个测试设计规格说明一般可适用于手动和自动化测试。它也应通过评审过程，与软件工程中的功能规格说明和设计文档是一样的。</p>
<p>测试设计规格说明的基本元素示例：概要、目标、目的；策略；功能测试；组件测试；集成测试或系统测试；互操作性测试；一致性测试；国际化测试和全球化测试；性能测试；安全测试；安装或部署测试；依赖关系；度量。</p>
<p>测试用例一般包括验证测试（使用期望的输入来验证产品功能的测试）和错误避免测试（使用预期之外的数据来检验产品是否能适当处理的测试）。验证测试是必要的，而错误测试则可能会更重要一些。</p>
<p>在测试用例设计中要考虑的其他因素：进度，资源（预算），质量，产品的范畴，用户基数的大小，测试团队的大小以及测试团队的技能。回答与这些因素相关的问题能够帮助你选择一个可以验证产品功能、找出错误并有效处理用户问题的测试集合。</p>
<p>做一个充分的测试用例设计需要测试工程师事先考虑好可能的测试范围，也需要能够全盘考虑并确定优先级，以使测试能够在满足项目进度要求的同事对产品进行了充分的测试。</p>
<p>【黑盒测试】根据一二应用程序的用户只关心这个应用程序是否满足了他们的需求，而不关心这个应用程序是如何被设计和实现的原理，它是一个有效的方法去模仿和预估用户会如何使用这个产品。也会导致过度测试程序的某些部分而对另一些部分没有做足够的测试。</p>
<p>【白盒测试】通过对应用程序内部代码或者用户看不到的模式进行分析，并以此设计测试用例。它总是会错过关键的终端用户使用场景。</p>
<p>【灰盒测试】首先从用户关心的角度出发，然后再利用白盒测试方法保证测试用例能够有效并全面的覆盖被测对象。从两方面进行测试：用户角度和确定应用程序的正确性的角度。</p>
<p>【探索性测试】是一种手工测试方法，每一步的测试和验证都是基于前一步的操作。需要根据已了解的被测产品的知识以及掌握的测试方法学，快速的找到产品的缺陷。</p>
<p>在一个不断强调自动化测试的团队里，探索性测试方法在早期的测试设计阶段很有帮助，它可以影响自动化测试的结构和目标。它旨在模拟用户体验，而且通常能够成功发现其他测试方法可能会错过的缺陷。</p>
<p>在做测试的时候，及早发现重要的缺陷是非常重要的，还要努力设计出可以发现缺陷，并保证可以在整个产品生命周期之内验证产品的功能以及正确性的测试用例。</p>
<p>【结对测试】两个测试工程师一起完成探索性测试。其中一个关注与如何调用各项功能，而另一个则是从高层面考虑被测程序。</p>
<p>为了能使测试用例长久使用，设计测试用例的一个关键是不断地实践各种技术和方法，并将得到的所有信息用于后续的测试活动。最重要的就是要花时间去了解每个组件，每个功能，或是应用程序，并且要基于对各种各样技术的了解来设计测试用例。</p>
<h3 id="第5章-功能测试相关技术"><a href="#第5章-功能测试相关技术" class="headerlink" title="第5章  功能测试相关技术"></a>第5章  功能测试相关技术</h3><p>杰出的测试工程师不仅依靠其好奇心去探究产品，还会对其作深入挖掘、在更加精细的多的粒度上，对正在测试的软件的能力及书写实施深度分析。</p>
<p>收集更多深度信息的途径之一是将产品的功能集进行分解，然后针对分解后的各个组件的功能属性及能力分别实施测试。</p>
<p>【探索性测试，ET】主要关注于行为测试。ET在对软件进行初步评估摸底的时候特别有用，有助于使测试工程师对于测试的软件迅速形成一个概念。也能够有效地对软件的操作能力和整体可用性给出一个初步的、宏观的总体评价。</p>
<p>探索性测试不能适应大型的复杂项目，或是任务非常关键的软件。</p>
<p>使用黑盒方法进行软件行为测试，仅能企及所有测试能够覆盖范围的35%到65%之间。</p>
<p>提高测试的有效性并收集产品特定方面关键信息的一种途径是采用功能测试相关技术。功能测试相关技术是指某些系统化的过程，使我们能够对软件的属性和能力实施全面的考察。常应用于从用户界面出发的测试，但是同样也能够应用于设计黑盒和白盒视角出发的测试。</p>
<p>功能测试相关技术的另一个好处是：它能够把针对产品特定功能范围内的测试覆盖率逐渐提升至一个很高的置信度，同时降低测试用例的冗余数量。功能测试相关技术知识专业测试工程师使用的工具，用以收集软件的能力和属性的关键信息，以及揭示潜在的缺陷。</p>
<p>功能测试相关技术，如边界值分析（BVA），等价类划分（ECP）、组合分析，以及状态转换测试等就像工具箱中的各种工具，每种工具都适用于不同的用途。</p>
<p>【等价类划分（ECP）】使得测试工程师能够以系统化的方式评估一个功能点中每个参数的输入和输出变量。</p>
<p>ECP测试可以经由这样的手段导出：创建每个合法分类子集的合集，直到测试取遍合法分类的所有子集为止；尔后，再对非法数据子集依次评估。<br>既可以定义正向测试，也可以定义负向测试，以针对输入和输出参数在功能方面的能力，以及系统是否对于所有种类的错误都具备了足够的处理能力实施系统获得评估。</p>
<p>ECP的功效：有助于我们系统化的降低从所有可能的测试中遴选的测试的数目。另一个优势在于我们可以通过从给定的测试子集中随机选择元素用做测试数据，以有效地提高数据的覆盖率。</p>
<p>从合法和非法子集中随机选择元素为测试用例的后续迭代提供了巨大的多变性，而且增加了将不常见的畸形用例曝光的几率，而它们是不太可能通过典型的或是实际中常用的合法类的静态数据测试出来的。</p>
<p>等价类划分必须非常熟悉数据的各种类型，了解程序和系统运行、操作、转换盒存储数据的机制。同时必须知道输入变量的可能值以及回顾失败指示信息。也必须考虑外部因素。</p>
<p>ECP数据分解理论：过于宽泛的变量数据归纳减少了ECP测试的数量，但增加了遗漏错误的可能性或产生负向错误或正向错误。变量数据过量的分解会增加冗余测试的可能性，这会减少ECP测试的整体效率。</p>
<p>最初，必须把数据分为离散的合法类数据和非法类数据。在每一个等价类数据集合中使用多个元素来增加覆盖的宽度并减少错误功能的可能性。</p>
<p>等价类划分的四个启发式方法，在决策制定、故障检修和解决问题的任务重十分有用。<br>把数据分解为在合法和非法类中的离散集合的四个启发式方法包括：<br>     值的范围（在数据的邻近集合中最小值和最大值间的任何数据点应产生相同的结果）、<br>     变量相似组（只要元素被等价的处理，那么元素组是允许的）、<br>     唯一值（在类或子集中的数据可能以不同于同一类或子集中的其他数据的方式被处理）、<br>     特殊值（条件必须提供或必须不被提供）。</p>
<p>当数据划分为离散子集之后，ECP技术的下一步是定义在测试之中如何使用数据子集。最常用的方法是对于所有参数创建合法类子集的组合直至在验证测试中所有合法类子集已经至少包含一次。接着，对于每一个参数单独测试的每一个非法类子集，把其他参数设置为一些合法值。</p>
<p>利用随机概率生成测试数据或随机选取给定测试子集中的特定测试数据元素可以覆盖更多的可能变量数据。</p>
<p>ECP所有的测试都不专门针对边界条件。这是由于ECP测试是用于识别特定类型的错误，而边界测试是用于识别不同类型的错误。</p>
<p>ECP测试不专门针对极大极小边界条件，同样它也不包括边界值分析和边界测试。</p>
<p>等价类划分小结</p>
<p>ECP是个用于设计一组黑盒或白盒的功能性测试技术，并以此来评估输入输出参数的功能性。该技术不能用于评估边界条件、相互依赖参数的组合、按序或已经排序的输入。</p>
<p>在可靠理论中的单点故障假设规定中，故障很少是2个或多个故障共同作用的结果。ECP测试和边界测试的主要目的是暴露单点故障，尤其是处在线性边界的变量或处在所谓边角案例的等价数据可能吧程序相应的处理。</p>
<p>【边界值分析（BVA）】仔细分析线性变量的边界条件。当BVA和ECP结合使用，则BVA这个功能性技术可以有效地分析独立输入和输出参数等线性参数的边界值。</p>
<p>BVA或边界测试可以检测以下类型的错误：<br>     错误的数据类型的人工约束；<br>     错误的分配关系运算符；<br>     数据类型的封装；<br>     差一错误。</p>
<p>在一个软件程序的环境中，边界值是个特定值，该数值处在独立线性变量或它的等价类子集的极限边界上。</p>
<p>BVA在系统的分析在软件中常见的两类边界值：不变常数的数值，固定变量数值。<br>不变边界常数是数字常数或在运行阶段保持不变而且通常不会被用户改变的实数。<br>固定边界，意味着测量可以改变但是在特定时段必须不变。</p>
<p>有效边界值分析取决于测试员准确识别关于任何特定独立参数的所有特定边界条件的能力。等价类子集对于帮助我们确定潜在的边界条件也非常有用。ECP子集不仅揭示了数值的极限线性范围，也会暴露一些可能表明额外重要边界条件的数值。</p>
<p>在确定所有独立输入输出参数的边界条件之后，可以通过一个简单的公式：3(BC)来计算最小的测试数据子集，BC等于特定边界条件的数量。</p>
<p>当其他参数都被设定为额定值时，每个参数都被评估为边界值和忽上忽下的数值。这些参数的ECP测试已经正式额定数值可以如期的执行。当额定数值给定，我们设计BVA测试来使用有效范围内的随机概率数值，如此可以提供更大的灵活度，并使得测试中的硬编码或静态数据最小化。</p>
<p>不是所有的边界都能通过数字型输入或输出来确定，或者它们是代表直接面向用户的线性测量数据。</p>
<p>代码中存在许多的循环算法，循环结构在边界条件中是众所周知的问题。</p>
<p>循环结构的边界值分析包括（最小）绕过循环，1次遍历循环，2次遍历循环，最大次数的遍历循环，最大次数-1的遍历循环，最后是超过最大次数的遍历循环。</p>
<p>边界测试基于确定的边界数值，而不是基于参数的数量。边界值分析的有效性取决于我们是否有能力将离散变量分解为等价类，并确定重要的边界条件。</p>
<p>基本边界测试是基于单点故障的前提，因此BVA测试常常不能有效地评估依赖或半依赖参数的复杂组合。</p>
<p>组合分析，通过从所有可能的组合中选择一个有效地子测试系统，并借此分析一个复杂的特征集中地系统性依赖和半耦合参数的相互作用。</p>
<p>组合分析的优点：<br>     能最大程度的识别由于变量作用所导致的缺陷；<br>     提供了更大的结构性覆盖；<br>     具有很大的潜力来降低整体测试成本。<br>该技术的优势是用于你在测试一个功能时，该功能的参数直接相互依赖或者半耦合，而且参数输入都是无序的。</p>
<p>通常有两种测试参数相互作用的途径。第一种途径一般涉及随机或者待定的方法，而第二张包括了更加系统的过程。<br>随机评估的方法包括最优猜测或特定测试和随机选择。<br>系统评估方法包括每个变量或者分支(EC)，基准测试(BC)，正交陈列(OA)，？组合测试和穷举测试(AC)。</p>
<p>最优猜测或特定方法主要依靠测试人员的直觉和运气。比较适合测试常用的组合或者快乐路径，也能暴露源于异常组合情境下的细微缺陷。</p>
<p>分支测试(EC)，将每个变量测试至少一次，它使用了最少量的测试。<br>基准测试(BC)，指定一组变量作为基准测试。这组变量通常是快乐路径中常用变量状态的组合。额外的测试在一段时间内改变一个参数的变量状态，同时保持在基准测试中的其他参数变量状态不变。</p>
<p>正交阵列(OA)，需要每个相互依赖的参数具有同等数量的变量状态，那些状态都对应在数组中。</p>
<p>测试相互依赖的参数可变组合最有效地解决方案之一是组合分析或用到覆盖阵列的n-对测试。</p>
<p>选择适当的测试集合：<br>     识别相互依赖的参数。当彻底分析功能，决定哪些参数是相互依赖，并分解每个参数的可变状态，进而选择合适的变量来测试之后，就可以建立BC矩阵。BC矩阵通常定义了最通用的可变状态组合，然后在保持其他参数可变状态处于初始状态的同时，每次改变一个参数的可变状态，直到每个变量都被测试过为止。</p>
<p>在完成BC测试之后，接下来找到任何在故障指标上问题的，但未在BC矩阵中定义的常用组合。<br>接下来，必须创建输入文件来模拟每个参数的、适当的可变状态。</p>
<p>？PICT工具</p>
<p>历史经验表明大多数、源于参数间相互作用的缺陷常出现在简单配对组合。但是，除了测试BC矩阵和把PICT工具中的配对输出随机化以外，最近研究表明持续增加的n-对组合测试可以暴露之前未察觉的细微缺陷。</p>
<p>检测缺陷的有效性（DDE）是个最常用的测试有效性的方法之一。</p>
<p>建议测试人员从BC和配对测试开始，然后将配对输出结果随机化，并持续增加n-对测试组合总量知道6-对覆盖。</p>
<p>另一种评估测试有效性的方式是查看测试人员提供给的资料。</p>
<p>经验数据表明多数黑盒测试都将结构性的覆盖65%的附在程序。相比于黑盒测试，使用配对测试的，在产品代码块和弧覆盖的数量方面会有所增加。</p>
<p>另一种检测有效性的途径是降低运作的成本。</p>
<p>组合测试中，测试人员必须有能力正确分析功能参数，鉴别依赖参数和半耦合参数，并分解变量状态，识别有条件的和不变的约束。</p>
<h3 id="第6章-结构测试技术"><a href="#第6章-结构测试技术" class="headerlink" title="第6章  结构测试技术"></a>第6章  结构测试技术</h3><p>结构测试技术通过对函数控制流程的详细分析来帮助我们降低风险。</p>
<p>与那些既能应用于设计黑盒测试也能应用于设计白盒测试的功能测试方法不同，结构测试技术是一种白盒测试设计方法。</p>
<p>使用白盒测试方法所设计的测试既能在用户界面层次执行，也能通过使用存根或虚拟对象的方式在用户界面之下的组建层次执行。</p>
<p>一个了解数据类型、函数调用和程序结构的优秀测试员能够更有效地发现不同类型的问题。</p>
<p>块测试（block testing）</p>
<p>函数的基本结构测试方法使用了一些简单技术，包括语句测试和块测试。<br>语句测试的目的是执行一个函数中的所有语句。<br>块测试则执行成组的连续语句或不包含分支或函数调用的语句块。</p>
<p>语句覆盖测量一个程序在测试过程中被执行过的语句的数量。<br>块覆盖测量无分支的连续语句组的数量。<br>导致控制流程转向分支的条件语句可以包含若干块。<br>相较于语句测试，块测试对控制流程提供了更好的敏感度。</p>
<p>结构测试的价值取决于测试员分析控制流程以及设计测试以确保各个不同的控制路径至少执行一次的能力。</p>
<p>控制流程图（CFD）就是函数或类的模型。一个CFD必须有一个入口和一个出口。在函数的入口和出口之间，CFD提供了程序代码的一种抽象表示或模型，从而帮助测试人员通过遍历一个复杂函数的不同代码路径来追踪控制流程。</p>
<p>矩形：语句或语句块；菱形：决策或条件子句；圆形：函数中的决策点。</p>
<p>如果目的是进行单元测试，块测试一般已经足够，但它只是结构测试的一个相对较弱的形式。</p>
<p>适合于块测试的一种结构类型是case&#x2F;switch语句。</p>
<p>块测试体现其重要性的另一个地方是异常处理。</p>
<p>块测试是健壮的结构测试中相对较弱的标准，它还可能漏掉控制流程的一些重要的分支。此外，块测试还容易忽略一些潜在的问题，特别是在我们测试的目的只是要提高代码覆盖率而不是要仔细分析被测试代码的情况下。</p>
<p>决策测试（Decision Testing）对条件子句求值，根据条件为真为假，简单的布尔表达式就可以确定控制流程的分支。决策测试的主要目标是设计既能够验证布尔表达中的真也能验证假结果的测试。</p>
<p>决策测试不是用于执行代码的连续代码块，而是注重于评价函数中的条件子句。优点在于它对控制流提供更好的敏感度。它的目的不是测试所有可能的输入或输出，而是简单的帮助我们测试贯穿函数的控制流程。</p>
<p>决策测试对简单条件语句是行之有效的，这些条件语句只需要计算布尔条件表达式的值，比如if语句或循环结构。但与块结构类似，决策测试并不能充分验证条件语句中的关系运算符。决策测试也不能有效地评估符合条件判断的控制流程。</p>
<p>条件测试（Condition Testing）</p>
<p>又是一个函数中的控制流程取决于多个条件语句的结果，可以使用一个由多个布尔子表达式经逻辑运算符AND或OR连接承德条件语句来简化代码，而不是用级联的多个条件语句。</p>
<p>当一个条件语句包含两个货两个以上的布尔子表达式，我们可以使用条件测试这种结构测试技术。它用于评估复合条件语句中每个子表达式估值为“真”和“假”的结果。在测试符合条件语句时，条件测试比决策测试对控制流程提供更好的敏感度。</p>
<p>？基础路径测试（Basis Path Testing）</p>
<p>路径测试试图遍历程序中所有可能的途径。每次控制流程通过一次循环体就被认为是一条不同的路径。</p>
<p>圈复杂性是用来帮助开发人员测定他们的函数复杂性的一个测量单位。用于在软件开发生命周期中评价一个模块的潜在可靠性、可测试性和可维护性。也可被测试人员用来确定最低的测试数量，从而对一个函数的控制流程进行比块测试和决策测试更加严格的测试。圈复杂性衡量控制一个模块或函数流程的决策逻辑。</p>
<p>计算圈复杂性的公式 V(G)&#x3D;边的数目-节点数+2</p>
<p>线性独立的基础路径是通过一个函数的独特路径的有限集合。</p>
<p>测试人员可以使用基准路径技术来查明通过一个函数的线性独立的基础路径集合。</p>
<p>简化基准路径技术流程：<br>     1. 确认从被测函数入口到出口的最短基准路径。<br>     2. 回到函数入口。<br>     3. 跟踪控制流程，从入口点到第一个未被先后评估为真和假两种结果的条件语句。<br>     4. 改变该条件语句的结果。<br>     5. 按最短路径从这个条件语句到函数出口。<br>     6. 重复2至6，直到所有的基础路径被定义。</p>
<p>实用基准路径技术流程：<br>     1. 确定一个有可能的功能性的通过函数的基准路径，它代表一个非常可能的通过函数的控制流程。该流程是运行时最常见的，或是最重要或最关键的路径。<br>     2. 回到函数入口点。<br>     3. 跟踪控制流程，从函数入口点到第一个未被先后评估为真和假两种结果的条件路径。<br>     4. 改变该条件语句的结果。<br>     5. 沿一条包括最大数量的被基准路径所遍历的条件语句到函数出口点的路径。<br>     6. 重复步骤2至6，直到没一个条件语句都被先后评估为真和假两种结果，而且所有基础路径都被定义。</p>
<p>基础路径测试与块测试和决策测试的不同之处在于：每一个条件语句的每个结果都必须被独立的测试。但是，基础路径测试需要一个测试把控制流程绕过循环，另一个测试的程序控制流程经过循环结构。所以，类似于条件覆盖范围，基础路径测试包含了块和决策测试。</p>
<p>当分析有简单条件语句的函数，特别是使用循环结构的函数时，基础路径测试提供了鞥好的控制流程敏感性。但是，当评估一个符合条件语句时，基础路径测试包含了块和决策测试。</p>
<p>结构测试技术的目的是支持和加强其他测试方式和方法，通过设计和运行能遍历其他测试方法所不能遍历的代码路径测试，还可以提供更深入的信息和降低风险。</p>
<h3 id="第7章-用代码复杂度分析风险"><a href="#第7章-用代码复杂度分析风险" class="headerlink" title="第7章  用代码复杂度分析风险"></a>第7章  用代码复杂度分析风险</h3><p>基于风险的测试，就是基于缓解产品中潜在风险的测试方法。它倾向于把可用的测试资源集中在最需要的区域。</p>
<p>80&#x2F;20法则：在很多度量标准下80%的结果源自20%的原因。</p>
<p>80%的用户使用仅仅20%的功能，80%的缺陷存在于20%的产品中，或者说80%的运行时间耗费在20%的代码上。</p>
<p>复杂的代码和不同代码的复杂部分之间的交互通常会更容易的带来错误。复杂的代码更容易产生更多的缺陷，也更难维护。</p>
<p>代码复杂度是衡量代码“难度”的重要标准（LOC）。</p>
<p>最简单的代码复杂度测量方式可能是代码行数。</p>
<p>确定程序中判断的数目的最常用的方法中，有一种称为回路复杂度的度量方法。它是辨别函数中线性独立路径（或者判断）数目的度量方法。</p>
<p>一个没有包含条件操作（比如条件语句，循环，或者三元算子）的函数在整个程序中只有一条线性独立的路径。条件语句在程序流中加入了分支也就在函数中创建了另外的路径。</p>
<p>计算复杂度最常用的方法是首先基于源代码创建一个控制流程图，然后基于此图计算出结果。<br>     计算公式：边-节点+2</p>
<p>快速计算回路复杂度的方法是简单地将条件语句的数量加1.</p>
<p>回路复杂度主要用在衡量函数的可测试度。<br>1-10：低风险的简单程序<br>11-20：中等的复杂度和风险<br>21-50：高复杂度和风险<br>50+：非常高的风险&#x2F;不可测试</p>
<p>Halstead度量是一套完全不同的复杂度度量，基于对程序中语法要素的以下4个度量：<br>     独特算子的数量n1；<br>     独特算域的数量n2；<br>     所有算子出现的总数N1；<br>     所有算域出现的总数N2；</p>
<p>面向对象度量是在各种语言中类和类结构相关的度量<br>CK度量包括：<br>     每个类的权重方法（WMC）：一个类中方法的数目；<br>     继承树的深度（DIT）：一个类所继承的类的数目；<br>     对象类之间的耦合（CBO）：一个类引用其他类的方法或者实例变量的数目</p>
<p>在面向对象的编程中，扇入和扇出度量分别用来计算有多少类调用到某一个特定的类和多少类被某一个特定的类调用。例如，如果一个类包含的方法被其他5个类调用而且这些方法也调用了其他10个类，那么她的扇入就是5，扇出就是10。</p>
<p>这些度量值作为可维护性度量是非常有效的，同时也表明了需要额外的测试的区域。</p>
<p>当被用在函数或者模块层面，扇入和扇出度量对于非面向对象编程也很有价值。另一方面，扇出度量表明了程序中有多少依赖关系。</p>
<p>减少复杂度度量误诊的方法就是同时检视各种不同的复杂度度量，通过结合和权衡这些数据来减少误诊。</p>
<p>微软Visual Studio工具集的最新版本包含了多个复杂度度量的测量方法，包括回路复杂度、Halstead度量、和代码行数的度量方法。</p>
<p>高的复杂度只能表示这段代码可能会有很多缺陷，仍然需要额外更多的调查来证实这个结果。</p>
<h3 id="第8章-基于模型的测试（MBT）"><a href="#第8章-基于模型的测试（MBT）" class="headerlink" title="第8章 基于模型的测试（MBT）"></a>第8章 基于模型的测试（MBT）</h3><p>一个模型可以是对系统的任意描述。一个典型的行为模型中会有一个开始状态，一个或多个转变，以及一个结束状态。</p>
<p>每次生成模型时考虑的三个问题：<br>     1. 我在哪里？<br>     2. 我可以进行什么操作？<br>     3. 我做这些事的结果会怎样？</p>
<p>模型的测试自动化并不是对端到端场景进行自动化，而是将重点放在过渡自动化和状态验证上。</p>
<p>在MBT中，边和节点分别代表转移和状态。MBT的主要功效体现在遍历算法中。随机的通过每种状态的测试时有趣的，并且经常会发现缺陷，但将图论的概念应用于遍历会有利而且有效。</p>
<p>随机行走遍历会随机选择一个可用的转换。它没有指导或计划；它只是在设定时间内尽可能的走遍各个状态。随机行走通常会发现缺陷，但可能会花特别长的时间来遍历大的模型。</p>
<p>加权遍历在某种程度上是有指导的随机行走。选择哪个转换仍然是随机的，但最有可能的选择都进行了加权，以便它们的发生更频繁。</p>
<p>最短路径遍历使用最少量的转换走过两个节点间的路径。</p>
<p>所有转换路径也包括所有节点。而所有状态遍历则不保证所有转换路径都被尝试过。</p>
<p>用于API测试的模型</p>
<p>在较低级别，许多操作系统或平台功能也可以由基于状态的方法来测试。</p>
<p>随机模型</p>
<p>基于模型的另一简单形式是猴子测试。猴子测试会生成随机（或假随机）输入，以期找到缺陷。猴子测试在压力测试中很通用，而且通常也不难创建。它的缺点是这种测试一般难于进行调试。</p>
<p>语法模型</p>
<p>MBT的另一种常用形式是使用语法模型进行测试。语法模型描述数据的特征和结构。正则表达式就是一种语法模型的实现。正则表达式的一个常见用途是搜索文本。<br>语法模型对于创建测试数据而言是很有用的。</p>
<p>基于模型的测试，可以通过少量工作实现非常广泛的测试覆盖。最困难的问题之一是创建模型来描述我们讨论的系统。一旦通过正确定义所有可能的输入、转换和输出，就会发现准确的定义从任何可能的参数组中得出的结果是很容易的。</p>
<p>基于模型的测试非常健壮，可以用它来测试从API到UI的各种领域。当模型实现时，就可以完全取消手动测试。经过适当调整，基于模型的测试可以提供从快速验证测试到全面功能测试的覆盖。这是通过将我们的输入、转换盒输出列表删减到我们感兴趣的子集实现的。</p>
<p>使用MBT生成的测试用例花费更少的时间，得到更好的覆盖率。另外，模型十分容易扩展。作为一个好的建模实践，应该首先为最基本的功能建模，然后逐步扩展它。</p>
<p>关于基于模型测试的总结：<br>     MBT为功能的设计提供了不同的视角；<br>     测试时自动生成的，而且保证用最少的步骤达到对模型的完全覆盖。<br>     扩展模型十分容易，而且可以利用以前生成的测试。</p>
<p>基于模型的测试最常见的错误：<br>     过多的建模；<br>     建模并不能代替其他的测试；<br>     只能为验证的东西建模；<br>     仔细设计。</p>
<p>第三部分 测试工具和系统</p>
<h3 id="第9章-缺陷和测试用例管理"><a href="#第9章-缺陷和测试用例管理" class="headerlink" title="第9章  缺陷和测试用例管理"></a>第9章  缺陷和测试用例管理</h3><p>测试用例描述测试过程的意图，缺陷则描述了这些测试用例的结果。</p>
<p>缺陷的工作流程描述了一个缺陷从创建到关闭的过程，所有的参与者，以及缺陷报告的所有可能途径。</p>
<p>缺陷的工作流程：<br>     产品代码→运行测试用例→创建缺陷报告→三方会审讨论缺陷。<br>     如果缺陷没有被批准，把缺陷安装不修正来解决→关闭缺陷。<br>     如果缺陷批准了要调查→研究是代码错误，还是设计错误。<br>     如果是代码错误，提议修正代码错误，再进行三方会审→如果修正批准了→修正代码→解决缺陷→重现缺陷→通过则关闭缺陷，如果不通过，重新激活缺陷→重新调查是代码错误还是设计错误。<br>     如果是设计错误，修正设计指导批准→再进行三方会审。其他后续流程和以上类似。</p>
<p>缺陷跟踪系统的特性：简单好用、可设置性、可靠性、缺陷通知、互操作性、外部用户访问。</p>
<p>好缺陷报告的特点：属性、标题、说明、状态、版本号、功能区、重现步骤、分配、严重性、客户影响、环境、决断。如何发现、问题类型、缺陷类型、资源来源。</p>
<p>缺陷的优先顺序通常设定值如下：<br>     必须修正；应修正；有时间就修正。</p>
<p>缺陷报告中常见缺陷：<br>     电子邮件讨论；缺陷渐变；多个缺陷。</p>
<p>缺陷度量：修复的缺陷&#x2F;所有解决了的缺陷；每种语言总计缺陷；缺陷发现率；错误修正率；每个代码区的缺陷数；每个功能区发现的缺陷；不同严重性的缺陷；哪里发现；如何发现；缺陷发生时候；缺陷重新激活率；每个测试活动发现的缺陷；平均解决缺陷的时间；平均关闭缺陷的时间。</p>
<p>缺陷数据的可变因素：所测试功能的复杂性；开发人员编程能力；规格完整性；缺陷预防与缺陷发现；报告的及时性。</p>
<p>一个测试用例管理器（TCM）是一个系统，它可以管理测试用例的定义、版本、储存和执行。测试用例管理器与缺陷管理系统有着许多相同的属性。</p>
<p>一个测试用例描述了针对某一特定的软件组件及预期的结果的与其操作。该组件可以是一个小的应用程序编程接口（API），一个用户界面（UI）的控制，或设备驱动程序的端口（port）处理。</p>
<p>测试用例可以由一组步骤和预期结果组成。自动化测试用例应该自我核查。</p>
<p>测试用例可以验证程序功能正常或验证错误能被正确处理。测试用例的其他用处是可以尝试增加代码覆盖或专门的用于覆盖很少使用的路径。</p>
<p>测试用例文档的优点：历史借鉴；测试进展跟踪；可重复性。<br>测试用例文档的缺点：建立文档的时间；功能变化引起测试用例过期；很难设想读者的知识。</p>
<p>测试用例的属性：目的；条件；具体的输入和步骤；预测结果。测试频率；配置；自动化（手动，半自动化，自动化）。</p>
<p>测试用例的误区：步骤缺乏；太多细节；行话太多；不明确的通过&#x2F;失败标准。</p>
<p>测试用例是为执行一个测试行为设定的一组步骤的一个单一实例，而测试点是那个测试用例在某个特殊环境里的一个具体实现。众多测试点的结果可以与横跨测试矩阵或以前已有记录的测试点互相进行比较，而此时这些测试点基于的测试用例也许根本没改变。</p>
<p>测试术语：<br>     测试用例、<br>     测试点（一个测试用例和它的一种运行环境的组合）、<br>     测试套件（相关测试用例或测试点的一个集合。通常一个测试套件是被测试功能的单位，常限于产品的某组件或特性）、<br>     测试运行、<br>     测试通过。</p>
<p>测试常用的度量：通过比率；通过&#x2F;失败的数目；测试用例的总数&#x2F;计划的测试用例的总数；自动化比率、测试类型的数目；发现缺陷的测试数目或百分比。</p>
<h3 id="第10章-测试自动化"><a href="#第10章-测试自动化" class="headerlink" title="第10章  测试自动化"></a>第10章  测试自动化</h3><p>是否自动化的考量因素：<br>     投入；测试的生命期；价值；切入点；准确性。</p>
<p>误报：测试用例报告一个错误，但实际上并没有错误存在。<br>漏报：当一个测试用例汇报验证通过，而被测试的软件功能其实有问题。</p>
<p>是否自动化测试的因素：支持平台；复杂度；其他因素（自动化所需时间、自动化测试的测试人员的技能、产品设计早期的设计对可测试性和自动化支持的考虑、管理层对自动化的指导意见）。</p>
<p>面向公众的函数或任何通过编程界面面向公众的功能，都很适合做自动化测试。通过针对单个API功能的自动化测试，可以使用测试应用程序有效测试多个参数的组合。</p>
<p>很多非功能测试都适合自动化，如性能测试、负载测试、压力测试和泄露测试。</p>
<p>用户界面自动化：<br>使用击键和鼠标点击写成的代码是重现用户与软件互动行为最相近的自动化测试方法，但也是最不稳定的UI自动化测试方法之一。控件会移动，控件的标识符会改变，文本也会更新或者本地化。<br>另一种自动化的方式是自动化那些用户与用户界面互动时发生的行为。</p>
<p>自动化的组成部分：</p>
<ul>
<li>设置Setup：指的是将软件准备好，让实际的测试操作可以开始执行；</li>
<li>执行Execute：包括检验软件功能的特定步骤，充分的错误处理，或者一些其他的相关工作；</li>
<li>分析Analysis：确定测试通过还是失败的过程。</li>
<li>报告Reporting：包括分析结果的显示和传播，例如日志文件、数据库或者其他分析过程中生成的文件；</li>
<li>清理Cleanup：将软件返回到已知状态使得接下来的测试能继续执行；</li>
<li>帮助Help：使测试用例在其生存周期中保持可维护性和健壮性的帮助系统。</li>
</ul>
<p>一个完整的自动化方案要求自动化不仅仅测试执行这一环节。在一个自动化策略中，如果没有一个把应用程序准备好到测试可以执行状态的计划，也没有自动的测试结果报告和分析，就很少能带来什么益处。</p>
<p>测试用具的工作流程：</p>
<ol>
<li>测试用具启动并检查任何传给它的附加数据。把控环境变量、要运行的测试、文件位置、网络地址或者测试需要的其他任何数据。</li>
<li>测试用具执行测试用例。取决于测试用具或者可选数据，自动化测试用例可能依次运行，也可能随机运行，或按特定的顺序运行。</li>
<li>测试用例可以记录测试数据（包括测试状态）并输出到一个文件、一个调试流或者别的固定的位置。日志文件必备元素：测试标识符、测试名称、环境信息、被测程序信息、测试结果。</li>
</ol>
<blockquote>
<p>测试结果的分类：通过、失败、跳过、放弃、阻断、警告。</p>
</blockquote>
<p>自动化测试代码中一些常见的错误：</p>
<ul>
<li>硬编码路径；</li>
<li>过于复杂；</li>
<li>难于调试；</li>
<li>误报和漏报；</li>
</ul>
<h3 id="第11章-非功能测试"><a href="#第11章-非功能测试" class="headerlink" title="第11章  非功能测试"></a>第11章  非功能测试</h3><p>定义为肺功能的测试领域包括了性能、负载、安全、可靠性和其他很多方面。非功能测试有时也被称作行为测试或质量测试。</p>
<p>非功能属性：<br>     可靠性（是度量软件如何在主流情形和非预期情形下维持它的功能，有时也包括软件出错时的自恢复能力）、<br>     可用性（用户学习和控制软件以达到用户需求的容易程度）、<br>     可维护性（描述了修改软件而不引入新错误所需的工作量）、<br>     可移植性。</p>
<p>性能测试</p>
<p>最常见的性能测试可以称作读秒测试。旨在测量某些重要操作的执行时间。它是设计单个测试或一组测试去测量软件对不同的用户操作的响应时间，或是测量在受控环境下的产品功能。大多数的性能测试实际上是通过执行测试用例并记录所用时间的自动化测试来实现的。</p>
<p>在设计过程的早期就积极地介入代码评审和分析性能目标是绝对必要的。</p>
<p>在设计阶段发现潜在性能问题的技巧：<br>     提出疑问；<br>     考虑全局；<br>     明确目标。</p>
<p>性能测试的技巧：<br>     建立基线；<br>     经常运行测试；<br>     测试响应效率；<br>     测试的是性能；<br>     充分利用性能测试；<br>     预估瓶颈；<br>     使用工具；<br>     合理使用资源（响应时间，延迟，CPU负荷，硬盘或网络I&#x2F;O，内存）；<br>     “干净机器”：用还是不用；<br>     避免改变。</p>
<p>性能计数器是揭示应用软件或系统的某些性能指标的细节测量工具，它使得检测和分析这些指标成为可能。</p>
<p>压力测试</p>
<p>应用软件在预期的和重负载条件下的表现和处理容量增大的能力，通常被归类为在性能测试下面。</p>
<p>广义上，压力测试（通过模拟比预期要大的工作负载来让只在峰值条件下才出现的缺陷曝光。如内存泄露、竞态条件、数据库中的线程或数据行直接的死锁条件和其他同步问题）经常包括:<br>     负载测试（探讨在高峰或高于正常水平的负载下，系统或应用软件会发生什么情况）、<br>     平均无故障时间（MTBF）测试（测量系统或应用软件在出错或当机前的平均运行时间）、<br>     低资源测试（确定当系统在重要资源&lt;内存、硬盘空间等&gt;降低或完全没有的情况下的状况）、<br>     容量测试（一般是用来执行服务器或服务测试，目的是确定一台或多台计算机能支持的最多用户数目）、<br>     重复性测试（确定重复某一程序或场景的效果而采取的一项简单而粗暴的技术，循环运行测试直到达到一个具体界限或临界值）。</p>
<p>分布式压力测试</p>
<p>多客户端压力测试的特点：无穷运行、内存使用、没有已知问题。</p>
<p>兼容性测试</p>
<p>应用程序兼容性测试一般注重于应用程序之间或所测试的目标系统与其他应用程序之间的交互。其他应用程序可能包括内部和外部两种。</p>
<p>可达性测试</p>
<p>可达性是指为每个人提供接触信息和工具的相等机会，这些信息和工具是他们每天工作所必需的。它的根本点是让用户有一种感觉，他有能力创造和维护应用程序、网站或者 文件，并且有能力与之互动。</p>
<p>可达性测试的特性：<br>     操作系统的设置：设置大字体、高DPI、高反差界面风格、光标闪烁速度、粘滞键、过滤键、鼠标设置子键、串行键设置子键、切换键设置子键、屏幕分辨率、自定义鼠标设置及从屏幕键盘的输入。<br>     “内置”可达性特性：Tab键顺序、热键、快捷键。<br>     编程访问。<br>     可达性的技术工具：屏幕阅读器、放大镜、语音识别或者其他输入程序。</p>
<p>应用程序的可达性测试方法：<br>     遵守系统范围的可达性设置；<br>     支持高反差界面风格；<br>     尺寸事关重大；<br>     注意音频功能；<br>     能够对UI元素和文本进行编程访问。</p>
<p>可用性测试</p>
<p>可用性是指用户能不能很容易的理解和与用户界面互动。有用的文档、工具提示、容易找到的功能等</p>
<p>可用性实验的目标：<br>     用户的需要是什么？<br>     什么样的设计能够解决用户的问题？<br>     用户需要做哪些工作，他们能不能很好的解决问题？<br>     用户如何学习软件，以及保持他们对软件的技能？<br>     软件用起来是否有意思？</p>
<p>安全测试</p>
<Hunting Security Bugs>
<How to break> James Whittaker
<编写安全代码>

<p>安全测试的主要方法和技巧：<br>     威胁建模（审查应用程序结构以找到潜在的安全威胁和弱点。输入校验、数据处理、会话管理等。在程序设计时完成最佳。意图是找出一个程序被攻击的所有可能的方法，然后根据概率和可能的危害来排优先级）；<br>     模糊测试（一种用来决定程序对无效输入数据会怎样反应的技术。简单办法就是用十六进制的编辑器来改变程序所使用的数据文件的文件格式。处理随机改动数据之外，模糊测试通常还包括将数据改变成更易暴露潜在的安全问题的样子。它的适用范围还有数据库测试、协议测试或者任何一种必需读取和解释数据的系统或应用程序中）</p>
<h3 id="第12章-其他工具"><a href="#第12章-其他工具" class="headerlink" title="第12章  其他工具"></a>第12章  其他工具</h3><p>代码改动量：指的是在一段时间内，一个文件或模块中的代码变化的总量。</p>
<p>代码改动的计量方法：<br>     修改的次数、增加的代码行数、删除的代码行数、修改的代码行数。</p>
<p>使用“代码改动”指标可以显示出软件中哪一部分出现缺陷的可能性较高。</p>
<p>“代码改动”只是一个警示的指标，如果一个产品具有很高的“代码改动”值，并不总是意味着那个产品存在很多问题，只是提醒产品某些部分发生了大的变化。</p>
<p>需要被严密监测的并不局限于源代码的变更，同样重要的是还要对所有规范说明和所有辅助文档进行控制管理。</p>
<p>软件构建</p>
<p>构建过程包括编译，链接，和运行应用程序所需的其他步骤：如构建安装程序和部署到新版本发布服务器上。</p>
<p>构建验收测试（BATs）或构建验证测试（BVTs）确保每天的构建是可用于测试的。</p>
<p>BVT属性：自动化一切，测试一小部分，快速测试，报错恰到好处，广泛测试而非深入测试，可调试和可维护性，可信，关键。</p>
<p>每日构建和BVT过程可以减少大的集成或全面的更改引发错误的机会。保持该产品天天成功的构建和运行时一个健康软件团队的关键。</p>
<p>每日构建至少确保编译错误在代码签入24小时之内被发现。</p>
<p>最常见的编译错误也是最容易预防的：开发人员代码中的语法错误。</p>
<p>构建中断通常由语法错误以外的其他原因引起。忘记签入某个文件是引起构建中断最常见的原因之一。当改动大型的复杂系统时，因为有依赖关系的系统的另一部分发生变化造成构建中断也很常见。</p>
<p>停止构建过程中的中断的有效方法：<br>     滚动构建：基于该产品最新的源代码自动连续的构建。基本步骤包括：一个良好，没有问题的构建环境；自动同步到最新的源代码；构建整个系统；自动报告构建结果。最简单的的实现方法是用简单的windows脚本语言写一个控制文件。<br>     签入系统。</p>
<p>静态分析</p>
<p>一个在测试代码中寻找缺陷的有效方法是利用工具做自动静态分析。静态分析工具可以分析源代码或二进制文件，发现许多类型的缺陷，而不必实际运行程序。</p>
<p>……</p>
<h3 id="第13章-用户反馈系统"><a href="#第13章-用户反馈系统" class="headerlink" title="第13章  用户反馈系统"></a>第13章  用户反馈系统</h3><p>寻找并收集客户反馈信息的方法：<br>     客户体验改善计划（在产品生产周期中，经常分析从测试用户和主要合作伙伴那儿得到的数据，可使测试团队有可能更好的了解用户的使用模式和疼痛点，不断更新测试场景和测试优先级）、<br>     Windows错误报告、<br>     发送微笑（对独特错误的贡献；提高顾客意识；用户的实际问题影响错误的优先级；理解用户是如何使用我们的产品；加强其他客户反馈）、<br>     Microsoft Connect。</p>
<p>通过这些反馈机制，测试工程师能够发现漏掉的测试场景，找到测试漏洞，并直接针对用户的使用模式设计出新的场景测试。开发高质量软件的一个关键因素是，如何平衡使用用户反馈方法还是通过功能而是和代码覆盖分析等深入的技术分析方法。</p>
<p>……</p>
<h3 id="第14章-测试“软件加服务”"><a href="#第14章-测试“软件加服务”" class="headerlink" title="第14章  测试“软件加服务”"></a>第14章  测试“软件加服务”</h3><p>软件加服务（ Software Plus Services ）是微软创造的术语。这种分布式软件集成了在线服务的集中和协作之功能，同时又可以利用超过 8亿台计算机和数十亿台智能设备的处理能力和脱机功能，这些设备是消费者、知识工作者和游戏玩家已经拥有的。 </p>
<p>【服务组】是功能基本上相互独立的生产单元。一个服务组是生产规模的单元，同时也是下一次升级的部署单元。服务组也为网站级别的服务中断提供缓冲。</p>
<p>【现场可更换单元】把主板、硬盘和电源黏在一个平板上。</p>
<p>合适的软件加服务的测试方法：客户端支持；建造于服务器上；服务平台与顶级服务；松散耦合与紧密耦合的服务</p>
<p>在计算机科学中，耦合或依赖是指每一个程序对另一个程序的依赖程度。在源程序或目标程序频繁更改的情况下，松散耦合的系统使最好的。</p>
<p>好的安装程序的关键特征：零停工期、零数据损失、部分成品更新（或混合模式）、滚动式更新和快速反转机能。</p>
<p>部分成品更新提供了一个新版本和现有版本的混合模式来让在线服务能够控制风险。滚动式更新和部分成品更新相似，只不过采取全自动的方式。如果在安装部署的过程中发现了需回收产品的大缺陷时，快速反转机能可以使服务快速回到上一个好的状态。</p>
<p>……</p>
<p>第四部分  关于未来</p>
<h3 id="第15章-今天解决明天的问题"><a href="#第15章-今天解决明天的问题" class="headerlink" title="第15章  今天解决明天的问题"></a>第15章  今天解决明天的问题</h3><p>就像测试自动化室解决测试无穷多的产品配置的一种方法一样，自动失败分析（AFA）是一种处理很多测试失败的解决方案。防止瘫痪最有效的方法是预见到它。</p>
<p>失败分析架构：<br>AFA系统最重要的部分是失败匹配。为了能使AFA工作，自动化的测试需要报告导致错误发生的关于环境、场景、和步骤的一致性的信息，好的记录实践是一个可靠地失败分析的脊柱，如果测试日志是非结构性的，或者没有包含足够信息，就没有可能进行失败匹配。</p>
<p>日志实践：日志在成功时要简短，失败是要极其详细；当测试失败时，记下所看到的失败前的成功操作；日志应该跟踪产品信息；跟踪足够的和有帮助的失败上下文；避免记录没有必要的信息；如果结果已经被确认和证实了，每个测试点都应该记录这个结果；跟随团队的命名标准。</p>
<p>日志文件剖析：测试用例；系统信息；日期时间；测试输入界限；测试下限；测试下限通过；测试上限；期望结果；实际结果；结果。</p>
<p>大型测试自动化要想有非常好的投资回报需要集成自动化的每一个阶段，检入系统，和缺陷跟踪系统。一个成功的方案能够极大的减少手动干涉分析测试结果和失败的需要。AFA的另一个用途是分析测试失败的走势。</p>
<p>核查清单会在代码评审时引导评审员找到最容易检测到的缺陷类型，也会在代码评审时找到最关键的缺陷。核查清单的例子可能有：功能核查；可测性；检查错误并正确处理错误；资源管理；线程安全（同步，重入，计时）；简单性&#x2F;可维护性；安全（中断溢出，缓冲溢出，类型不匹配）；运行时的性能；输入校验。</p>
<p>面临挑战：失败分析、代码评审、虚拟机的应用、和代码重用方面的改进。</p>
<h3 id="第16章-建设未来"><a href="#第16章-建设未来" class="headerlink" title="第16章 建设未来"></a>第16章 建设未来</h3><p>早期的检测和预防对于防止以后很难“治愈”的问题最关键。</p>
<p>测试是一种被动方法——通过多重的检测盒调查技术来找到潜藏在产品中的缺陷，而质量保证是一种主动方法——建造一个预防和质量文化固化在开发周期中的环境。</p>
<p>质量成本，是“未能”生成优质产品或服务的代价。每次需要返工的时候，质量成本就提高了。</p>
<p>质量成本划分为三类：鉴定成本、预防成本和失败成本。鉴定成本包括薪资，和发布所需的费用。预防成本是跟实现和维护预防技术相关的开销。失败成本是返工的花费。</p>
<p>在一个每个人都把质量当成习惯的组织中，测试角色的着重点就从找到一大堆缺陷转移到了集中模拟用户场景、同时评审和校验方面。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>测试类书籍阅读笔记综述</p><p><a href="https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/">https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Nathan</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-09-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-03-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%B5%8B%E8%AF%95/">测试</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=63f0be096a51ed001aa3655d&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/10/15/tech/design-patterns-all-in-one/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">15分钟入门23种设计模式：图解，范例和对比</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/09/18/read/21-leadership-laws/"><span class="level-item">领导力21法则读书笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://hydraxman.github.io/2022/09/25/tech/testing/books-on-testing/';
            this.page.identifier = '2022/09/25/tech/testing/books-on-testing/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'hydraxman-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#阅读书目"><span class="level-left"><span class="level-item">1</span><span class="level-item">阅读书目</span></span></a></li><li><a class="level is-mobile" href="#知识梳理"><span class="level-left"><span class="level-item">2</span><span class="level-item">知识梳理</span></span></a></li><li><a class="level is-mobile" href="#书摘"><span class="level-left"><span class="level-item">3</span><span class="level-item">书摘</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#构建之法"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">构建之法</span></span></a></li><li><a class="level is-mobile" href="#Google软件测试之道"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Google软件测试之道</span></span></a></li><li><a class="level is-mobile" href="#探索吧！深入理解探索式软件测试"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">探索吧！深入理解探索式软件测试</span></span></a></li><li><a class="level is-mobile" href="#软件测试"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">软件测试</span></span></a></li><li><a class="level is-mobile" href="#软件测试的艺术"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">软件测试的艺术</span></span></a></li><li><a class="level is-mobile" href="#探索式软件测试"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">探索式软件测试</span></span></a></li><li><a class="level is-mobile" href="#微软的软件测试之道"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">微软的软件测试之道</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第3章-工程生命周期"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">第3章  工程生命周期</span></span></a></li><li><a class="level is-mobile" href="#第4章-软件测试用例设计的实用方法"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">第4章  软件测试用例设计的实用方法</span></span></a></li><li><a class="level is-mobile" href="#第5章-功能测试相关技术"><span class="level-left"><span class="level-item">3.7.3</span><span class="level-item">第5章  功能测试相关技术</span></span></a></li><li><a class="level is-mobile" href="#第6章-结构测试技术"><span class="level-left"><span class="level-item">3.7.4</span><span class="level-item">第6章  结构测试技术</span></span></a></li><li><a class="level is-mobile" href="#第7章-用代码复杂度分析风险"><span class="level-left"><span class="level-item">3.7.5</span><span class="level-item">第7章  用代码复杂度分析风险</span></span></a></li><li><a class="level is-mobile" href="#第8章-基于模型的测试（MBT）"><span class="level-left"><span class="level-item">3.7.6</span><span class="level-item">第8章 基于模型的测试（MBT）</span></span></a></li><li><a class="level is-mobile" href="#第9章-缺陷和测试用例管理"><span class="level-left"><span class="level-item">3.7.7</span><span class="level-item">第9章  缺陷和测试用例管理</span></span></a></li><li><a class="level is-mobile" href="#第10章-测试自动化"><span class="level-left"><span class="level-item">3.7.8</span><span class="level-item">第10章  测试自动化</span></span></a></li><li><a class="level is-mobile" href="#第11章-非功能测试"><span class="level-left"><span class="level-item">3.7.9</span><span class="level-item">第11章  非功能测试</span></span></a></li><li><a class="level is-mobile" href="#第12章-其他工具"><span class="level-left"><span class="level-item">3.7.10</span><span class="level-item">第12章  其他工具</span></span></a></li><li><a class="level is-mobile" href="#第13章-用户反馈系统"><span class="level-left"><span class="level-item">3.7.11</span><span class="level-item">第13章  用户反馈系统</span></span></a></li><li><a class="level is-mobile" href="#第14章-测试“软件加服务”"><span class="level-left"><span class="level-item">3.7.12</span><span class="level-item">第14章  测试“软件加服务”</span></span></a></li><li><a class="level is-mobile" href="#第15章-今天解决明天的问题"><span class="level-left"><span class="level-item">3.7.13</span><span class="level-item">第15章  今天解决明天的问题</span></span></a></li><li><a class="level is-mobile" href="#第16章-建设未来"><span class="level-left"><span class="level-item">3.7.14</span><span class="level-item">第16章 建设未来</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/headshot.jpeg" alt="内森 Nathan"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">内森 Nathan</p><p class="is-size-6 is-block">Senior Software Engineer Manager @ Microsoft</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hydraxman" target="_blank" rel="noopener">关注我</a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.svg" alt="内森淼文" height="28"></a><p class="is-size-7"><span>&copy; 2023 Nathan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="My GitHub Index" href="https://github.com/hydraxman"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>